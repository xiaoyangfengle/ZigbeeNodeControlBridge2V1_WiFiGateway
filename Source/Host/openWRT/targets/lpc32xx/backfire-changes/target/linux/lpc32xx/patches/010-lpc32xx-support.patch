diff --git a/arch/arm/configs/ea3250_defconfig b/arch/arm/configs/ea3250_defconfig
new file mode 100644
index 0000000..7cd1a74
--- /dev/null
+++ b/arch/arm/configs/ea3250_defconfig
@@ -0,0 +1,1861 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 2.6.39.2 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+# CONFIG_TINY_RCU is not set
+# CONFIG_TINY_PREEMPT_RCU is not set
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+CONFIG_ARCH_LPC32XX=y
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+# CONFIG_MACH_PHY3250 is not set
+CONFIG_MACH_EA3250=y
+# CONFIG_MACH_FDI3250 is not set
+
+#
+# Standard UARTS
+#
+# CONFIG_ARCH_LPC32XX_UART3_SELECT is not set
+# CONFIG_ARCH_LPC32XX_UART4_SELECT is not set
+CONFIG_ARCH_LPC32XX_UART5_SELECT=y
+# CONFIG_ARCH_LPC32XX_UART6_SELECT is not set
+
+#
+# High speed UARTS
+#
+# CONFIG_ARCH_LPC32XX_HSUART1_SELECT is not set
+# CONFIG_ARCH_LPC32XX_HSUART2_SELECT is not set
+# CONFIG_ARCH_LPC32XX_HSUART7_SELECT is not set
+
+#
+# LPC32XX chip components
+#
+# CONFIG_ARCH_LPC32XX_IRAM_FOR_NET is not set
+# CONFIG_ARCH_LPC32XX_MII_SUPPORT is not set
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200n81 root=/dev/ram0"
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+CONFIG_MTD_NAND_MUSEUM_IDS=y
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_SLC_LPC32XX=y
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM63XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+CONFIG_NATIONAL_PHY=y
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_LPC_ENET=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=240
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=320
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LPC32XX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_ADS7846=y
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_LPC32XX is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_HS_LPC32XX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
+CONFIG_PNX4008_WATCHDOG=y
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+CONFIG_SND_SEQUENCER=y
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
+CONFIG_SND_LPC3XXX_SOC=y
+CONFIG_SND_LPC3XXX_SOC_I2S_UDA1380=y
+CONFIG_SND_LPC32XX_USEI2S1=y
+# CONFIG_SND_LPC32XX_USEI2S_SLAVE_MODETX is not set
+# CONFIG_SND_LPC32XX_USEI2S_SLAVE_MODERX is not set
+CONFIG_SND_LPC32XX_SLAVE_TX_CLK_TO_RX=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_UDA1380=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_3M_PCT is not set
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CANDO is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MOSART is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_ARVO is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_STANTUM is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_ARMMMCI=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+CONFIG_LEDS_PCA9532=y
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_GPIO_PLATFORM=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_NFC_DEVICES is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_LPC32XX=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_AVERAGE is not set
diff --git a/arch/arm/configs/fdi3250_defconfig b/arch/arm/configs/fdi3250_defconfig
new file mode 100644
index 0000000..d6a288e
--- /dev/null
+++ b/arch/arm/configs/fdi3250_defconfig
@@ -0,0 +1,1748 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 2.6.39.2 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+# CONFIG_TINY_RCU is not set
+# CONFIG_TINY_PREEMPT_RCU is not set
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_MODVERSIONS=y
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+CONFIG_ARCH_LPC32XX=y
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_MACH_PHY3250 is not set
+# CONFIG_MACH_EA3250 is not set
+CONFIG_MACH_FDI3250=y
+CONFIG_SOM9DIMM3250_LCD_PANEL=y
+CONFIG_SOM9DIMM3250_LCD_OKAYA_VGA_35=y
+# CONFIG_SOM9DIMM3250_LCD_TOSHIBA_QVGA_35 is not set
+
+#
+# Standard UARTS
+#
+# CONFIG_ARCH_LPC32XX_UART3_SELECT is not set
+# CONFIG_ARCH_LPC32XX_UART4_SELECT is not set
+CONFIG_ARCH_LPC32XX_UART5_SELECT=y
+# CONFIG_ARCH_LPC32XX_UART6_SELECT is not set
+
+#
+# High speed UARTS
+#
+CONFIG_ARCH_LPC32XX_HSUART1_SELECT=y
+# CONFIG_ARCH_LPC32XX_HSUART2_SELECT is not set
+# CONFIG_ARCH_LPC32XX_HSUART7_SELECT is not set
+
+#
+# LPC32XX chip components
+#
+# CONFIG_ARCH_LPC32XX_IRAM_FOR_NET is not set
+# CONFIG_ARCH_LPC32XX_MII_SUPPORT is not set
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyTX0,115200n81 init=/sbin/init"
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=m
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+CONFIG_MTD_NAND_MUSEUM_IDS=y
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_SLC_LPC32XX=y
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_PLATFORM=y
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=4
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+# CONFIG_MISC_DEVICES is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM63XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_LPC_ENET=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=640
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=480
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+CONFIG_TOUCHSCREEN_LPC32XX=y
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+# CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_CONSOLE is not set
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+CONFIG_SERIAL_HS_LPC32XX=y
+CONFIG_SERIAL_HS_LPC32XX_CONSOLE=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_COMPAT is not set
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
+CONFIG_PNX4008_WATCHDOG=y
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_3M_PCT is not set
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_CANDO is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MOSART is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_ARVO is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_ROCCAT_KONEPLUS is not set
+# CONFIG_HID_ROCCAT_KOVAPLUS is not set
+# CONFIG_HID_ROCCAT_PYRA is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_STANTUM is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+CONFIG_USB_STORAGE_DEBUG=y
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_MMC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_GPIO is not set
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_NFC_DEVICES is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_LPC32XX=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_FS_MBCACHE=y
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=m
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=m
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+# CONFIG_EARLY_PRINTK is not set
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=m
+CONFIG_CRYPTO_ALGAPI2=m
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=m
+# CONFIG_CRYPTO_MANAGER is not set
+# CONFIG_CRYPTO_MANAGER2 is not set
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=m
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_AVERAGE is not set
diff --git a/arch/arm/configs/phy3250_defconfig b/arch/arm/configs/phy3250_defconfig
new file mode 100644
index 0000000..0c80560
--- /dev/null
+++ b/arch/arm/configs/phy3250_defconfig
@@ -0,0 +1,1800 @@
+#
+# Automatically generated make config: don't edit
+# Linux/arm 2.6.39.2 Kernel Configuration
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_VECTORS_BASE=0xffff0000
+# CONFIG_ARM_PATCH_PHYS_VIRT is not set
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+CONFIG_HAVE_IRQ_WORK=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_FHANDLE is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_GENERIC_HARDIRQS=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_HAVE_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_SHOW=y
+# CONFIG_SPARSE_IRQ is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_PREEMPT_RCU=y
+# CONFIG_TINY_RCU is not set
+# CONFIG_TINY_PREEMPT_RCU is not set
+CONFIG_PREEMPT_RCU=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+CONFIG_SYSFS_DEPRECATED=y
+CONFIG_SYSFS_DEPRECATED_V2=y
+# CONFIG_RELAY is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+# CONFIG_RD_BZIP2 is not set
+# CONFIG_RD_LZMA is not set
+# CONFIG_RD_XZ is not set
+# CONFIG_RD_LZO is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_DMA_API_DEBUG=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_MXS is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+CONFIG_ARCH_LPC32XX=y
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P64X0 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_EXYNOS4 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_TCC_926 is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_VT8500 is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_KEYBOARD_GPIO_POLLED is not set
+CONFIG_MACH_PHY3250=y
+# CONFIG_MACH_EA3250 is not set
+# CONFIG_MACH_FDI3250 is not set
+
+#
+# Standard UARTS
+#
+# CONFIG_ARCH_LPC32XX_UART3_SELECT is not set
+# CONFIG_ARCH_LPC32XX_UART4_SELECT is not set
+CONFIG_ARCH_LPC32XX_UART5_SELECT=y
+# CONFIG_ARCH_LPC32XX_UART6_SELECT is not set
+
+#
+# High speed UARTS
+#
+# CONFIG_ARCH_LPC32XX_HSUART1_SELECT is not set
+# CONFIG_ARCH_LPC32XX_HSUART2_SELECT is not set
+# CONFIG_ARCH_LPC32XX_HSUART7_SELECT is not set
+
+#
+# LPC32XX chip components
+#
+# CONFIG_ARCH_LPC32XX_IRAM_FOR_NET is not set
+# CONFIG_ARCH_LPC32XX_MII_SUPPORT is not set
+
+#
+# System MMU
+#
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+CONFIG_CPU_USE_DOMAINS=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+
+#
+# Bus support
+#
+CONFIG_ARM_AMBA=y
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_COMPACTION is not set
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_CC_STACKPROTECTOR is not set
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="console=ttyS0,115200n81 root=/dev/ram0"
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+# CONFIG_CRASH_DUMP is not set
+# CONFIG_AUTO_ZRELADDR is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+CONFIG_VFP=y
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+CONFIG_BINFMT_AOUT=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+# CONFIG_BATMAN_ADV is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_WIRELESS is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
+# CONFIG_MTD_M25P80 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_BCH is not set
+# CONFIG_MTD_SM_COMMON is not set
+CONFIG_MTD_NAND_MUSEUM_IDS=y
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_SLC_LPC32XX=y
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_BLK_DEV_CRYPTOLOOP=y
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=1
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+# CONFIG_BLK_DEV_RBD is not set
+# CONFIG_SENSORS_LIS3LV02D is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1780 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_TI_DAC7512 is not set
+# CONFIG_BMP085 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_MULTI_LUN is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_LIBFC is not set
+# CONFIG_LIBFCOE is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_MII=y
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+CONFIG_SMSC_PHY=y
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_BCM63XX_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ENC28J60 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8851 is not set
+# CONFIG_KS8851_MLL is not set
+CONFIG_LPC_ENET=y
+# CONFIG_FTMAC100 is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+# CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+
+#
+# CAIF transport drivers
+#
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=240
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=320
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_QT1070 is not set
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_LPC32XX is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_MCS is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+CONFIG_TOUCHSCREEN_LPC32XX=y
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_AMBAKMI is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_SERIO_PS2MULT is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+CONFIG_SERIAL_8250_RUNTIME_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_AMBA_PL010 is not set
+# CONFIG_SERIAL_AMBA_PL011 is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX3107 is not set
+# CONFIG_SERIAL_HS_LPC32XX is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+CONFIG_I2C_CHARDEV=y
+# CONFIG_I2C_MUX is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+CONFIG_I2C_PNX=y
+# CONFIG_I2C_PXA_PCI is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_OC_TINY is not set
+CONFIG_SPI_PL022=y
+# CONFIG_SPI_PXA2XX_PCI is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_DESIGNWARE is not set
+
+#
+# SPI Protocol Masters
+#
+# CONFIG_SPI_SPIDEV is not set
+# CONFIG_SPI_TLE62X0 is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+
+#
+# PPS generators support
+#
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+# CONFIG_DEBUG_GPIO is not set
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_BASIC_MMIO is not set
+# CONFIG_GPIO_IT8761E is not set
+# CONFIG_GPIO_PL061 is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_SX150X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MCP23S08 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_74X164 is not set
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_SUPPLY is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ARM_SP805_WATCHDOG is not set
+CONFIG_PNX4008_WATCHDOG=y
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+CONFIG_MFD_SUPPORT=y
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_HTC_EGPIO is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_MC13XXX is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_REGULATOR is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_DRM is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_WMT_GE_ROPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+# CONFIG_FB_MODE_HELPERS is not set
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+CONFIG_FB_ARMCLCD=y
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+CONFIG_SND_SEQUENCER=y
+# CONFIG_SND_SEQ_DUMMY is not set
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_SEQUENCER_OSS=y
+# CONFIG_SND_HRTIMER is not set
+CONFIG_SND_DYNAMIC_MINORS=y
+CONFIG_SND_SUPPORT_OLD_API=y
+# CONFIG_SND_VERBOSE_PROCFS is not set
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+# CONFIG_SND_DRIVERS is not set
+# CONFIG_SND_ARM is not set
+# CONFIG_SND_SPI is not set
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_CACHE_LZO is not set
+CONFIG_SND_LPC3XXX_SOC=y
+CONFIG_SND_LPC3XXX_SOC_I2S_UDA1380=y
+CONFIG_SND_LPC32XX_USEI2S1=y
+# CONFIG_SND_LPC32XX_USEI2S_SLAVE_MODETX is not set
+# CONFIG_SND_LPC32XX_USEI2S_SLAVE_MODERX is not set
+CONFIG_SND_LPC32XX_SLAVE_TX_CLK_TO_RX=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_UDA1380=y
+# CONFIG_SOUND_PRIME is not set
+# CONFIG_HID_SUPPORT is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+# CONFIG_USB_ARCH_HAS_EHCI is not set
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+CONFIG_USB_DEVICE_CLASS=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_CLKGATE is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_MMC_BLOCK_BOUNCE is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+CONFIG_MMC_ARMMMCI=y
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+# CONFIG_MMC_DW is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_GPIO_PLATFORM=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_GPIO is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_NFC_DEVICES is not set
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+CONFIG_RTC_INTF_DEV_UIE_EMUL=y
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_DS3234 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_PL030 is not set
+# CONFIG_RTC_DRV_PL031 is not set
+CONFIG_RTC_DRV_LPC32XX=y
+# CONFIG_DMADEVICES is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_STAGING is not set
+CONFIG_CLKDEV_LOOKUP=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_FS_POSIX_ACL is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_QUOTACTL is not set
+CONFIG_AUTOFS4_FS=y
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+CONFIG_JFFS2_FS_WBUF_VERIFY=y
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V3_ACL is not set
+# CONFIG_NFS_V4 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+# CONFIG_OSF_PARTITION is not set
+# CONFIG_AMIGA_PARTITION is not set
+# CONFIG_ATARI_PARTITION is not set
+# CONFIG_MAC_PARTITION is not set
+CONFIG_MSDOS_PARTITION=y
+# CONFIG_BSD_DISKLABEL is not set
+# CONFIG_MINIX_SUBPARTITION is not set
+# CONFIG_SOLARIS_X86_PARTITION is not set
+# CONFIG_UNIXWARE_DISKLABEL is not set
+# CONFIG_LDM_PARTITION is not set
+# CONFIG_SGI_PARTITION is not set
+# CONFIG_ULTRIX_PARTITION is not set
+# CONFIG_SUN_PARTITION is not set
+# CONFIG_KARMA_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+CONFIG_ENABLE_WARN_DEPRECATED=y
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_SHIRQ is not set
+# CONFIG_LOCKUP_DETECTOR is not set
+# CONFIG_HARDLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_TIMER_STATS is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_PREEMPT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_RT_MUTEX_TESTER is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_SPARSE_RCU_POINTER is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_VM is not set
+# CONFIG_DEBUG_WRITECOUNT is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_TEST_LIST_SORT is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+CONFIG_FRAME_POINTER=y
+# CONFIG_BOOT_PRINTK_DELAY is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_BACKTRACE_SELF_TEST is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_DMA_API_DEBUG is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_TEST_KSTRTOX is not set
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_UNWIND is not set
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+CONFIG_DEBUG_LL=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_DEBUG_ICEDCC is not set
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_ZLIB is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_HW is not set
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+CONFIG_CRC_CCITT=y
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+# CONFIG_XZ_DEC is not set
+# CONFIG_XZ_DEC_BCJ is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
+# CONFIG_AVERAGE is not set
diff --git a/arch/arm/mach-lpc32xx/Kconfig b/arch/arm/mach-lpc32xx/Kconfig
index fde6635..0ba9736 100644
--- a/arch/arm/mach-lpc32xx/Kconfig
+++ b/arch/arm/mach-lpc32xx/Kconfig
@@ -1,6 +1,57 @@
 if ARCH_LPC32XX
 
-menu "Individual UART enable selections"
+choice
+    prompt "LPC32XX SoC based board implementations"
+    default MACH_PHY3250
+    help
+        This menu selects the LPC3250 board to support for this build
+
+    config MACH_PHY3250
+        bool "Phytec 3250 development board"
+        help
+            Support for the Phytec 3250 development board
+
+    config MACH_EA3250
+        bool "Embedded Artists LPC3250 Developer's Kit"
+        help
+            Support for the Embedded Artists LPC3250 Developer's Kit
+
+    config MACH_FDI3250
+        bool "Future Designs LPC3250 Touch screen kit"
+        help
+            Support for the Future Designs LPC3250 Touch screen kit
+
+endchoice
+
+
+
+config SOM9DIMM3250_LCD_PANEL
+	bool "Enables support for SOM9DIMM-LPC3250 (FDI board) LCDs"
+	depends on MACH_FDI3250
+	default TRUE
+	help
+	  Say Y here to enable QVGA/VGA panel support
+	  
+choice
+    prompt "FDI LCD Display"
+    depends on SOM9DIMM3250_LCD_PANEL
+    default SOM9DIMM3250_LCD_OKAYA_VGA
+    help
+        Select type of LCD display to be used.
+
+config SOM9DIMM3250_LCD_OKAYA_VGA_35
+    bool "OKAYA VGA LCD on 3-5 LCD CARRIER board"
+    help
+      Select this option if you are using an OKAYA RV640480T on a FDI 3-5 LCD CARRIER board
+      
+config SOM9DIMM3250_LCD_TOSHIBA_QVGA_35
+    bool "Toshiba QVGA LCD on 3-5 LCD CARRIER board"
+    help
+      Select this option if you are using a Toshiba LTA057A347F on a FDI 3-5 LCD CARRIER board
+
+endchoice
+
+menu "Standard UARTS"
 
 config ARCH_LPC32XX_UART3_SELECT
 	bool "Add support for standard UART3"
@@ -29,5 +80,42 @@ config ARCH_LPC32XX_UART6_SELECT
 
 endmenu
 
+menu "High speed UARTS"
+
+config ARCH_LPC32XX_HSUART1_SELECT
+        bool "Add support for high speed UART1"
+        help
+                Enables high speed UART1 as a TTYSx device
+
+config ARCH_LPC32XX_HSUART2_SELECT
+        bool "Add support for high speed UART2"
+        help
+                Enables high speed UART2 as a TTYSx device
+
+config ARCH_LPC32XX_HSUART7_SELECT
+        bool "Add support for high speed UART7"
+        help
+                Enables high speed UART7 as a TTYSx device
+
+endmenu
+
+menu "LPC32XX chip components"
+
+config ARCH_LPC32XX_IRAM_FOR_NET
+        bool "Use IRAM for network buffers"
+        help
+          If the total combined required buffer sizes is larger than the
+          size of IRAM, then SDRAM will be used instead.
+
+config ARCH_LPC32XX_MII_SUPPORT
+        bool "Check to enable MII support or leave disabled for RMII support"
+        default FALSE
+        help
+          Say Y here to enable MII support, or N to RMII support. Regardless of
+          which support is selected, the ethernet interface driver needs to be
+          selected in the device driver networking section.
+
+endmenu
+
 endif
 
diff --git a/arch/arm/mach-lpc32xx/Makefile b/arch/arm/mach-lpc32xx/Makefile
index f5db805..e3d51b4 100644
--- a/arch/arm/mach-lpc32xx/Makefile
+++ b/arch/arm/mach-lpc32xx/Makefile
@@ -3,6 +3,7 @@
 #
 
 obj-y	:= timer.o irq.o common.o serial.o clock.o
-obj-y	+= pm.o suspend.o
-obj-y	+= phy3250.o
-
+obj-y	+= dma.o pm.o suspend.o
+obj-$(CONFIG_MACH_PHY3250)     += phy3250.o
+obj-$(CONFIG_MACH_EA3250)      += ea3250.o
+obj-$(CONFIG_MACH_FDI3250)     += fdi3250.o
diff --git a/arch/arm/mach-lpc32xx/clock.c b/arch/arm/mach-lpc32xx/clock.c
index 1e02751..9591ed3 100644
--- a/arch/arm/mach-lpc32xx/clock.c
+++ b/arch/arm/mach-lpc32xx/clock.c
@@ -86,6 +86,7 @@
 #include <linux/list.h>
 #include <linux/errno.h>
 #include <linux/device.h>
+#include <linux/delay.h>
 #include <linux/err.h>
 #include <linux/clk.h>
 #include <linux/amba/bus.h>
@@ -97,9 +98,12 @@
 #include "clock.h"
 #include "common.h"
 
+static DEFINE_SPINLOCK(global_clkregs_lock);
+
+static int usb_pll_enable, usb_pll_valid;
+
 static struct clk clk_armpll;
 static struct clk clk_usbpll;
-static DEFINE_MUTEX(clkm_lock);
 
 /*
  * Post divider values for PLLs based on selected register value
@@ -127,7 +131,7 @@ static struct clk osc_32KHz = {
 static int local_pll397_enable(struct clk *clk, int enable)
 {
 	u32 reg;
-	unsigned long timeout = 1 + msecs_to_jiffies(10);
+	unsigned long timeout = jiffies + msecs_to_jiffies(10);
 
 	reg = __raw_readl(LPC32XX_CLKPWR_PLL397_CTRL);
 
@@ -156,7 +160,7 @@ static int local_pll397_enable(struct clk *clk, int enable)
 static int local_oscmain_enable(struct clk *clk, int enable)
 {
 	u32 reg;
-	unsigned long timeout = 1 + msecs_to_jiffies(10);
+	unsigned long timeout = jiffies + msecs_to_jiffies(10);
 
 	reg = __raw_readl(LPC32XX_CLKPWR_MAIN_OSC_CTRL);
 
@@ -382,30 +386,63 @@ static u32 local_clk_usbpll_setup(struct clk_pll_setup *pHCLKPllSetup)
 static int local_usbpll_enable(struct clk *clk, int enable)
 {
 	u32 reg;
-	int ret = -ENODEV;
-	unsigned long timeout = 1 + msecs_to_jiffies(10);
+	int ret = 0;
+	unsigned long timeout = jiffies + msecs_to_jiffies(20);
 
 	reg = __raw_readl(LPC32XX_CLKPWR_USB_CTRL);
 
-	if (enable == 0) {
-		reg &= ~(LPC32XX_CLKPWR_USBCTRL_CLK_EN1 |
-			LPC32XX_CLKPWR_USBCTRL_CLK_EN2);
-		__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
-	} else if (reg & LPC32XX_CLKPWR_USBCTRL_PLL_PWRUP) {
+	__raw_writel(reg & ~(LPC32XX_CLKPWR_USBCTRL_CLK_EN2 |
+		LPC32XX_CLKPWR_USBCTRL_PLL_PWRUP),
+		LPC32XX_CLKPWR_USB_CTRL);
+	__raw_writel(reg & ~LPC32XX_CLKPWR_USBCTRL_CLK_EN1,
+		LPC32XX_CLKPWR_USB_CTRL);
+
+	if (enable && usb_pll_valid && usb_pll_enable) {
+		ret = -ENODEV;
+		/*
+		 * If the PLL rate has been previously set, then the rate
+		 * in the PLL register is valid and can be enabled here.
+		 * Otherwise, it needs to be enabled as part of setrate.
+		 */
+
+		/*
+		 * Gate clock into PLL
+		 */
 		reg |= LPC32XX_CLKPWR_USBCTRL_CLK_EN1;
 		__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
 
-		/* Wait for PLL lock */
-		while ((timeout > jiffies) & (ret == -ENODEV)) {
+		/*
+		 * Enable PLL
+		 */
+		reg |= LPC32XX_CLKPWR_USBCTRL_PLL_PWRUP;
+		__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
+
+		/*
+		 * Wait for PLL to lock
+		 */
+		while ((timeout > jiffies) && (ret == -ENODEV)) {
 			reg = __raw_readl(LPC32XX_CLKPWR_USB_CTRL);
 			if (reg & LPC32XX_CLKPWR_USBCTRL_PLL_STS)
 				ret = 0;
+			else
+				udelay(10);
 		}
 
+		/*
+		 * Gate clock from PLL if PLL is locked
+		 */
 		if (ret == 0) {
-			reg |= LPC32XX_CLKPWR_USBCTRL_CLK_EN2;
-			__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
+			__raw_writel(reg | LPC32XX_CLKPWR_USBCTRL_CLK_EN2,
+				LPC32XX_CLKPWR_USB_CTRL);
+		}
+		else {
+			__raw_writel(reg & ~(LPC32XX_CLKPWR_USBCTRL_CLK_EN1 |
+				LPC32XX_CLKPWR_USBCTRL_PLL_PWRUP),
+				LPC32XX_CLKPWR_USB_CTRL);
 		}
+	} else if ((enable == 0) && usb_pll_valid  && usb_pll_enable) {
+		usb_pll_valid = 0;
+		usb_pll_enable = 0;
 	}
 
 	return ret;
@@ -423,7 +460,7 @@ static unsigned long local_usbpll_round_rate(struct clk *clk,
 	 */
 	rate = rate * 1000;
 
-	clkin = clk->parent->rate;
+	clkin = clk->get_rate(clk);
 	usbdiv = (__raw_readl(LPC32XX_CLKPWR_USBCLK_PDIV) &
 		LPC32XX_CLKPWR_USBPDIV_PLL_MASK) + 1;
 	clkin = clkin / usbdiv;
@@ -437,7 +474,8 @@ static unsigned long local_usbpll_round_rate(struct clk *clk,
 
 static int local_usbpll_set_rate(struct clk *clk, unsigned long rate)
 {
-	u32 clkin, reg, usbdiv;
+	int ret = -ENODEV;
+	u32 clkin, usbdiv;
 	struct clk_pll_setup pllsetup;
 
 	/*
@@ -446,7 +484,7 @@ static int local_usbpll_set_rate(struct clk *clk, unsigned long rate)
 	 */
 	rate = rate * 1000;
 
-	clkin = clk->get_rate(clk);
+	clkin = clk->get_rate(clk->parent);
 	usbdiv = (__raw_readl(LPC32XX_CLKPWR_USBCLK_PDIV) &
 		LPC32XX_CLKPWR_USBPDIV_PLL_MASK) + 1;
 	clkin = clkin / usbdiv;
@@ -455,22 +493,25 @@ static int local_usbpll_set_rate(struct clk *clk, unsigned long rate)
 	if (local_clk_find_pll_cfg(clkin, rate, &pllsetup) == 0)
 		return -EINVAL;
 
+	/*
+	 * Disable PLL clocks during PLL change
+	 */
 	local_usbpll_enable(clk, 0);
-
-	reg = __raw_readl(LPC32XX_CLKPWR_USB_CTRL);
-	reg |= LPC32XX_CLKPWR_USBCTRL_CLK_EN1;
-	__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
-
-	pllsetup.analog_on = 1;
+	pllsetup.analog_on = 0;
 	local_clk_usbpll_setup(&pllsetup);
 
-	clk->rate = clk_check_pll_setup(clkin, &pllsetup);
+	/*
+	 * Start USB PLL and check PLL status
+	 */
 
-	reg = __raw_readl(LPC32XX_CLKPWR_USB_CTRL);
-	reg |= LPC32XX_CLKPWR_USBCTRL_CLK_EN2;
-	__raw_writel(reg, LPC32XX_CLKPWR_USB_CTRL);
+	usb_pll_valid = 1;
+	usb_pll_enable = 1;
 
-	return 0;
+	ret = local_usbpll_enable(clk, 1);
+	if (ret >= 0)
+		clk->rate = clk_check_pll_setup(clkin, &pllsetup);
+
+	return ret;
 }
 
 static struct clk clk_usbpll = {
@@ -730,6 +771,10 @@ static int mmc_onoff_enable(struct clk *clk, int enable)
 	if (enable != 0)
 		tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_EN;
 
+	/* Start clock at highest rate */
+	if (!(tmp & LPC32XX_CLKPWR_MSCARD_SDCARD_DIV(0xF)))
+		tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_DIV(1);
+
 	__raw_writel(tmp, LPC32XX_CLKPWR_MS_CTRL);
 
 	return 0;
@@ -737,14 +782,9 @@ static int mmc_onoff_enable(struct clk *clk, int enable)
 
 static unsigned long mmc_get_rate(struct clk *clk)
 {
-	u32 div, rate, oldclk;
+	u32 div, rate;
 
-	/* The MMC clock must be on when accessing an MMC register */
-	oldclk = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
-	__raw_writel(oldclk | LPC32XX_CLKPWR_MSCARD_SDCARD_EN,
-		LPC32XX_CLKPWR_MS_CTRL);
 	div = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
-	__raw_writel(oldclk, LPC32XX_CLKPWR_MS_CTRL);
 
 	/* Get the parent clock rate */
 	rate = clk->parent->get_rate(clk->parent);
@@ -772,12 +812,19 @@ static unsigned long mmc_round_rate(struct clk *clk, unsigned long rate)
 	if (div > 0xf)
 		div = 0xf;
 
+	/*
+	 * The divider is forced to 1 to keep the SD clock granularity
+	 * good. Using a non-0 divider will limit the SD card clock rates
+	 * the SD driver can generate. Remove it if your feeling crazy.
+	 */
+	div = 1;
+
 	return prate / div;
 }
 
 static int mmc_set_rate(struct clk *clk, unsigned long rate)
 {
-	u32 oldclk, tmp;
+	u32 tmp;
 	unsigned long prate, div, crate = mmc_round_rate(clk, rate);
 
 	prate = clk->parent->get_rate(clk->parent);
@@ -785,19 +832,17 @@ static int mmc_set_rate(struct clk *clk, unsigned long rate)
 	div = prate / crate;
 
 	/* The MMC clock must be on when accessing an MMC register */
-	oldclk = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
-	__raw_writel(oldclk | LPC32XX_CLKPWR_MSCARD_SDCARD_EN,
-		LPC32XX_CLKPWR_MS_CTRL);
 	tmp = __raw_readl(LPC32XX_CLKPWR_MS_CTRL) &
 		~LPC32XX_CLKPWR_MSCARD_SDCARD_DIV(0xf);
 	tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_DIV(div);
 	__raw_writel(tmp, LPC32XX_CLKPWR_MS_CTRL);
 
-	__raw_writel(oldclk, LPC32XX_CLKPWR_MS_CTRL);
-
 	return 0;
 }
 
+/*
+ * This is the MMC IP clock, not the MMC CLK signal rate!
+ */
 static struct clk clk_mmc = {
 	.parent		= &clk_armpll,
 	.set_rate	= mmc_set_rate,
@@ -891,19 +936,9 @@ static struct clk clk_lcd = {
 	.enable_mask	= LPC32XX_CLKPWR_LCDCTRL_CLK_EN,
 };
 
-static inline void clk_lock(void)
-{
-	mutex_lock(&clkm_lock);
-}
-
-static inline void clk_unlock(void)
-{
-	mutex_unlock(&clkm_lock);
-}
-
 static void local_clk_disable(struct clk *clk)
 {
-	WARN_ON(clk->usecount == 0);
+	// WARN_ON(clk->usecount == 0);
 
 	/* Don't attempt to disable clock if it has no users */
 	if (clk->usecount > 0) {
@@ -947,10 +982,11 @@ static int local_clk_enable(struct clk *clk)
 int clk_enable(struct clk *clk)
 {
 	int ret;
+	unsigned long flags;
 
-	clk_lock();
+	spin_lock_irqsave(&global_clkregs_lock, flags);
 	ret = local_clk_enable(clk);
-	clk_unlock();
+	spin_unlock_irqrestore(&global_clkregs_lock, flags);
 
 	return ret;
 }
@@ -961,9 +997,11 @@ EXPORT_SYMBOL(clk_enable);
  */
 void clk_disable(struct clk *clk)
 {
-	clk_lock();
+	unsigned long flags;
+
+	spin_lock_irqsave(&global_clkregs_lock, flags);
 	local_clk_disable(clk);
-	clk_unlock();
+	spin_unlock_irqrestore(&global_clkregs_lock, flags);
 }
 EXPORT_SYMBOL(clk_disable);
 
@@ -972,13 +1010,7 @@ EXPORT_SYMBOL(clk_disable);
  */
 unsigned long clk_get_rate(struct clk *clk)
 {
-	unsigned long rate;
-
-	clk_lock();
-	rate = clk->get_rate(clk);
-	clk_unlock();
-
-	return rate;
+	return clk->get_rate(clk);
 }
 EXPORT_SYMBOL(clk_get_rate);
 
@@ -994,11 +1026,8 @@ int clk_set_rate(struct clk *clk, unsigned long rate)
 	 * the actual rate set as part of the peripheral dividers
 	 * instead of high level clock control
 	 */
-	if (clk->set_rate) {
-		clk_lock();
+	if (clk->set_rate)
 		ret = clk->set_rate(clk, rate);
-		clk_unlock();
-	}
 
 	return ret;
 }
@@ -1009,15 +1038,11 @@ EXPORT_SYMBOL(clk_set_rate);
  */
 long clk_round_rate(struct clk *clk, unsigned long rate)
 {
-	clk_lock();
-
 	if (clk->round_rate)
 		rate = clk->round_rate(clk, rate);
 	else
 		rate = clk->get_rate(clk);
 
-	clk_unlock();
-
 	return rate;
 }
 EXPORT_SYMBOL(clk_round_rate);
@@ -1075,10 +1100,10 @@ static struct clk_lookup lookups[] = {
 	_REGISTER_CLOCK("dev:ssp1", NULL, clk_ssp1)
 	_REGISTER_CLOCK("lpc32xx_keys.0", NULL, clk_kscan)
 	_REGISTER_CLOCK("lpc32xx-nand.0", "nand_ck", clk_nand)
-	_REGISTER_CLOCK("tbd", "i2s0_ck", clk_i2s0)
-	_REGISTER_CLOCK("tbd", "i2s1_ck", clk_i2s1)
+        _REGISTER_CLOCK(NULL, "i2s0_ck", clk_i2s0)
+        _REGISTER_CLOCK(NULL, "i2s1_ck", clk_i2s1)
 	_REGISTER_CLOCK("ts-lpc32xx", NULL, clk_tsc)
-	_REGISTER_CLOCK("dev:mmc0", "MCLK", clk_mmc)
+	_REGISTER_CLOCK("dev:mmc0", "NULL", clk_mmc)
 	_REGISTER_CLOCK("lpc-net.0", NULL, clk_net)
 	_REGISTER_CLOCK("dev:clcd", NULL, clk_lcd)
 	_REGISTER_CLOCK("lpc32xx_udc", "ck_usbd", clk_usbd)
diff --git a/arch/arm/mach-lpc32xx/common.c b/arch/arm/mach-lpc32xx/common.c
index 369b152..74690d2 100644
--- a/arch/arm/mach-lpc32xx/common.c
+++ b/arch/arm/mach-lpc32xx/common.c
@@ -30,6 +30,7 @@
 #include <mach/i2c.h>
 #include <mach/hardware.h>
 #include <mach/platform.h>
+#include <mach/board.h>
 #include "common.h"
 
 /*
@@ -51,6 +52,28 @@ struct platform_device lpc32xx_watchdog_device = {
 };
 
 /*
+ * Real Time Clock
+ */
+static struct resource rtc_resources[] = {
+	[0] = {
+		.start = LPC32XX_RTC_BASE,
+		.end = LPC32XX_RTC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_RTC,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+struct platform_device lpc32xx_rtc_device = {
+	.name =  "rtc-lpc32xx",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(rtc_resources),
+	.resource = rtc_resources,
+};
+
+/*
  * I2C busses
  */
 static struct i2c_pnx_data i2c0_data = {
@@ -116,25 +139,117 @@ struct platform_device lpc32xx_tsc_device = {
 	.resource = lpc32xx_tsc_resources,
 };
 
-/* RTC */
+#if defined (CONFIG_USB_OHCI_HCD)
+/* The dmamask must be set for OHCI to work */
+static u64 ohci_dmamask = ~(u32) 0;
+static struct resource ohci_resources[] = {
+	{
+		.start = IO_ADDRESS(LPC32XX_USB_BASE),
+		.end = IO_ADDRESS(LPC32XX_USB_BASE + 0x100),
+		.flags = IORESOURCE_MEM,
+	}, {
+		.start = IRQ_LPC32XX_USB_HOST,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+struct platform_device lpc32xx_ohci_device = {
+	.name = "usb-ohci",
+	.id = -1,
+	.dev = {
+		.dma_mask = &ohci_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFF,
+	},
+	.num_resources = ARRAY_SIZE(ohci_resources),
+	.resource = ohci_resources,
+};
+#endif
+
+
+#if defined(CONFIG_USB_GADGET_LPC32XX)
+static void phy3250_usbd_conn_chg(int conn) {
+	/* Do nothing, it might be nice to enable an LED
+	 * based on conn state being !0 */
+}
+
+static void phy3250_usbd_susp_chg(int susp) {
+    /* Device suspend if susp != 0 */
+}
+
+static void phy3250_rmwkup_chg(int remote_wakup_enable) {
+    /* Enable or disable USB remote wakeup */
+}
 
-static struct resource lpc32xx_rtc_resources[] = {
+struct lpc32xx_usbd_cfg lpc32xx_usbddata = {
+	.vbus_drv_pol = 1,
+	.conn_chgb = &phy3250_usbd_conn_chg,
+	.susp_chgb = &phy3250_usbd_susp_chg,
+	.rmwk_chgb = &phy3250_rmwkup_chg,
+};
+
+/* The dmamask must be set for OHCI to work, align to 128 bytes */
+static u64 usbd_dmamask = ~(u32) 0x7F;
+static struct resource usbd_resources[] = {
 	{
-		.start = LPC32XX_RTC_BASE,
-		.end = LPC32XX_RTC_BASE + SZ_4K - 1,
+		.start = LPC32XX_USB_BASE,
+		.end = LPC32XX_USB_BASE + 0x100,
 		.flags = IORESOURCE_MEM,
-	},{
-		.start = IRQ_LPC32XX_RTC,
-		.end = IRQ_LPC32XX_RTC,
+	}, {
+		.start = IRQ_LPC32XX_USB_DEV_LP,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.start = IRQ_LPC32XX_USB_DEV_HP,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.start = IRQ_LPC32XX_USB_DEV_DMA,
+		.flags = IORESOURCE_IRQ,
+	}, {
+		.start = IRQ_LPC32XX_USB_OTG_ATX,
 		.flags = IORESOURCE_IRQ,
 	},
 };
 
-struct platform_device lpc32xx_rtc_device = {
-	.name =  "rtc-lpc32xx",
+struct platform_device lpc32xx_usbd_device = {
+	.name = "lpc32xx_udc",
 	.id = -1,
-	.num_resources = ARRAY_SIZE(lpc32xx_rtc_resources),
-	.resource = lpc32xx_rtc_resources,
+	.dev = {
+		.dma_mask = &usbd_dmamask,
+		.coherent_dma_mask = 0xFFFFFFFF,
+		.platform_data  = &lpc32xx_usbddata,
+	},
+	.num_resources = ARRAY_SIZE(usbd_resources),
+	.resource = usbd_resources,
+};
+#endif
+
+/*
+ * I2S
+ */
+static struct resource i2s_resources[] = {
+	[0] = {
+		.start = LPC32XX_I2S0_BASE,
+		.end = LPC32XX_I2S0_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = LPC32XX_I2S1_BASE,
+		.end = LPC32XX_I2S1_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+};
+
+struct platform_device lpc32xx_i2s_device = {
+	.name = "lpc3xxx-i2s",
+	.id = -1,
+	.num_resources = ARRAY_SIZE(i2s_resources),
+	.resource = i2s_resources,
+};
+
+/*
+ * ASOC platform device
+ */
+struct platform_device lpc32xx_asoc_plat_device = {
+	.name = "lpc3xxx-audio",
+	.id = 0,
 };
 
 /*
diff --git a/arch/arm/mach-lpc32xx/common.h b/arch/arm/mach-lpc32xx/common.h
index 4b4e700..6fd925c 100644
--- a/arch/arm/mach-lpc32xx/common.h
+++ b/arch/arm/mach-lpc32xx/common.h
@@ -19,6 +19,8 @@
 #ifndef __LPC32XX_COMMON_H
 #define __LPC32XX_COMMON_H
 
+#include <linux/pm.h>
+#include <linux/suspend.h>
 #include <linux/platform_device.h>
 
 /*
@@ -30,6 +32,10 @@ extern struct platform_device lpc32xx_i2c1_device;
 extern struct platform_device lpc32xx_i2c2_device;
 extern struct platform_device lpc32xx_tsc_device;
 extern struct platform_device lpc32xx_rtc_device;
+extern struct platform_device lpc32xx_ohci_device;
+extern struct platform_device lpc32xx_usbd_device;
+extern struct platform_device lpc32xx_i2s_device;
+extern struct platform_device lpc32xx_asoc_plat_device;
 
 /*
  * Other arch specific structures and functions
@@ -65,9 +71,12 @@ extern u32 clk_get_pclk_div(void);
  */
 extern void lpc32xx_get_uid(u32 devid[4]);
 
-extern void lpc32xx_watchdog_reset(void);
 extern u32 lpc32xx_return_iram_size(void);
 
+/* Power Management functions */
+extern void lpc32xx_irq_suspend(suspend_state_t state);
+extern void lpc32xx_irq_resume(suspend_state_t state);
+
 /*
  * Pointers used for sizing and copying suspend function data
  */
diff --git a/arch/arm/mach-lpc32xx/dma.c b/arch/arm/mach-lpc32xx/dma.c
new file mode 100644
index 0000000..3dfec4b
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/dma.c
@@ -0,0 +1,761 @@
+/*
+ *  linux/arch/arm/mach-lpc32xx/ma-lpc32xx.c
+ *
+ *  Copyright (C) 2008 NXP Semiconductors
+ *  (Based on parts of the PNX4008 DMA driver)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/err.h>
+#include <linux/dma-mapping.h>
+#include <linux/clk.h>
+
+#include <asm/system.h>
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <asm/dma-mapping.h>
+#include <asm/io.h>
+#include <mach/dma.h>
+#include <mach/dmac.h>
+
+#define DMAIOBASE io_p2v(LPC32XX_DMA_BASE)
+#define VALID_CHANNEL(c) (((c) >= 0) && ((c) < MAX_DMA_CHANNELS))
+
+static DEFINE_SPINLOCK(dma_lock);
+
+struct dma_linked_list {
+	u32 src;
+	u32 dest;
+	u32 next_lli;
+	u32 ctrl;
+};
+
+/* For DMA linked list operation, a linked list of DMA descriptors
+   is maintained along with some data to manage the list in software. */
+struct dma_list_ctrl {
+	struct dma_linked_list dmall; /* DMA list descriptor */
+	struct dma_list_ctrl *next_list_addr;   /* Virtual address to next list entry */
+        struct dma_list_ctrl *prev_list_addr;   /* Virtual address to previous list entry */
+	u32 next_list_phy;    /* Physical address to next list entry */
+        u32 prev_list_phy;    /* Physical address to previous list entry */
+};
+
+/* Each DMA channel has one of these structures */
+struct dma_channel {
+	char *name;
+	void (*irq_handler) (int, int, void *);
+	void *data;
+	struct dma_config *dmacfg;
+	u32 control;
+	u32 config;
+	u32 config_int_mask;
+
+	int list_entries; /* Number of list entries */
+	u32 list_size; /* Total size of allocated list in bytes */
+	u32 list_vstart; /* Allocated (virtual) address of list */
+	u32 list_pstart; /* Allocated (physical) address of list */
+	int free_entries; /* Number of free descriptors */
+	struct dma_list_ctrl *list_head, *list_tail, *list_curr;
+};
+
+struct dma_control {
+	struct clk *clk;
+	int num_clks;
+	struct dma_channel dma_channels[MAX_DMA_CHANNELS];
+};
+static struct dma_control dma_ctrl;
+static unsigned long flags;
+
+static inline void __dma_regs_lock(void)
+{
+	spin_lock_irqsave(&dma_lock, flags);
+}
+
+static inline void __dma_regs_unlock(void)
+{
+	spin_unlock_irqrestore(&dma_lock, flags);
+}
+
+static inline void __dma_enable(int ch) {
+	u32 ch_cfg = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	ch_cfg |= DMAC_CHAN_ENABLE;
+	__raw_writel(ch_cfg, DMACH_CONFIG_CH(DMAIOBASE, ch));
+}
+
+static inline void __dma_disable(int ch) {
+	u32 ch_cfg = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	ch_cfg &= ~DMAC_CHAN_ENABLE;
+	__raw_writel(ch_cfg, DMACH_CONFIG_CH(DMAIOBASE, ch));
+}
+
+static void dma_clocks_up(void)
+{
+	/* Enable DMA clock if needed */
+	if (dma_ctrl.num_clks == 0)
+	{
+		clk_enable(dma_ctrl.clk);
+		__raw_writel(DMAC_CTRL_ENABLE, DMA_CONFIG(DMAIOBASE));
+	}
+
+	dma_ctrl.num_clks++;
+}
+
+static void dma_clocks_down(void)
+{
+	dma_ctrl.num_clks--;
+
+	/* Disable DMA clock if needed */
+	if (dma_ctrl.num_clks == 0)
+	{
+		__raw_writel(0, DMA_CONFIG(DMAIOBASE));
+		clk_disable(dma_ctrl.clk);
+	}
+}
+
+static int lpc32xx_ch_setup(struct dma_config *dmachcfg)
+{
+	u32 tmpctrl, tmpcfg, tmp;
+	int ch = dmachcfg->ch;
+
+	/* Channel control setup */
+	tmpctrl = 0;
+	switch (dmachcfg->src_size)
+	{
+		case 1:
+			tmpctrl |= DMAC_CHAN_SRC_WIDTH_8;
+			break;
+
+		case 2:
+			tmpctrl |= DMAC_CHAN_SRC_WIDTH_16;
+			break;
+
+		case 4:
+			tmpctrl |= DMAC_CHAN_SRC_WIDTH_32;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+	switch (dmachcfg->dst_size)
+	{
+		case 1:
+			tmpctrl |= DMAC_CHAN_DEST_WIDTH_8;
+			break;
+
+		case 2:
+			tmpctrl |= DMAC_CHAN_DEST_WIDTH_16;
+			break;
+
+		case 4:
+			tmpctrl |= DMAC_CHAN_DEST_WIDTH_32;
+			break;
+
+		default:
+			return -EINVAL;
+	}
+	if (dmachcfg->src_inc != 0)
+	{
+		tmpctrl |= DMAC_CHAN_SRC_AUTOINC;
+	}
+	if (dmachcfg->dst_inc != 0)
+	{
+		tmpctrl |= DMAC_CHAN_DEST_AUTOINC;
+	}
+	if (dmachcfg->src_ahb1 != 0)
+	{
+		tmpctrl |= DMAC_CHAN_SRC_AHB1;
+	}
+	if (dmachcfg->dst_ahb1 != 0)
+	{
+		tmpctrl |= DMAC_CHAN_DEST_AHB1;
+	}
+	if (dmachcfg->tc_inten != 0)
+	{
+		tmpctrl |= DMAC_CHAN_INT_TC_EN;
+	}
+	tmpctrl |= dmachcfg->src_bsize | dmachcfg->dst_bsize;
+	dma_ctrl.dma_channels[ch].control = tmpctrl;
+
+	/* Channel config setup */
+	tmpcfg = dmachcfg->src_prph | dmachcfg->dst_prph |
+		dmachcfg->flowctrl;
+	dma_ctrl.dma_channels[ch].config = tmpcfg;
+
+	dma_ctrl.dma_channels[ch].config_int_mask = 0;
+	if (dmachcfg->err_inten != 0)
+	{
+		dma_ctrl.dma_channels[ch].config_int_mask |=
+			DMAC_CHAN_IE;
+	}
+	if (dmachcfg->tc_inten != 0)
+	{
+		dma_ctrl.dma_channels[ch].config_int_mask |=
+			DMAC_CHAN_ITC;
+	}
+
+	tmp = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	tmp &= ~DMAC_CHAN_ENABLE;
+	__raw_writel(tmp, DMACH_CONFIG_CH(DMAIOBASE, ch));
+
+	/* Clear interrupts for channel */
+	__raw_writel((1 << ch), DMA_INT_TC_CLEAR(DMAIOBASE));
+	__raw_writel((1 << ch), DMA_INT_ERR_CLEAR(DMAIOBASE));
+
+	/* Write control and config words */
+	__raw_writel(tmpctrl, DMACH_CONTROL(DMAIOBASE, ch));
+	__raw_writel(tmpcfg, DMACH_CONFIG_CH(DMAIOBASE, ch));
+
+	return 0;
+}
+
+int lpc32xx_dma_ch_enable(int ch)
+{
+	if (!VALID_CHANNEL(ch) || !dma_ctrl.dma_channels[ch].name)
+		return -EINVAL;
+
+	__dma_regs_lock();
+	__dma_enable(ch);
+	__dma_regs_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_ch_enable);
+
+int lpc32xx_dma_ch_disable(int ch)
+{
+	if (!VALID_CHANNEL(ch) || !dma_ctrl.dma_channels[ch].name)
+		return -EINVAL;
+
+	__dma_regs_lock();
+	__dma_disable(ch);
+	__dma_regs_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_ch_disable);
+
+int lpc32xx_dma_ch_get(struct dma_config *dmachcfg, char *name,
+		void *irq_handler, void *data) {
+	int ret;
+
+	if (!VALID_CHANNEL(dmachcfg->ch))
+		return -EINVAL;
+
+	/* If the channel is already enabled, return */
+	if (dma_ctrl.dma_channels[dmachcfg->ch].name != NULL)
+		return -ENODEV;
+
+	/* Save channel data */
+	dma_ctrl.dma_channels[dmachcfg->ch].dmacfg = dmachcfg;
+	dma_ctrl.dma_channels[dmachcfg->ch].name = name;
+	dma_ctrl.dma_channels[dmachcfg->ch].irq_handler = irq_handler;
+	dma_ctrl.dma_channels[dmachcfg->ch].data = data;
+
+	/* Setup channel */
+	__dma_regs_lock();
+	dma_clocks_up();
+	ret = lpc32xx_ch_setup(dmachcfg);
+	__dma_regs_unlock();
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_ch_get);
+
+int lpc32xx_dma_ch_put(int ch)
+{
+	u32 tmp;
+
+	if (!VALID_CHANNEL(ch))
+		return -EINVAL;
+
+	/* If the channel is already disabled, return */
+	if (dma_ctrl.dma_channels[ch].name == NULL)
+		return -EINVAL;
+
+	tmp = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	tmp &= ~DMAC_CHAN_ENABLE;
+	__raw_writel(tmp, DMACH_CONFIG_CH(DMAIOBASE, ch));
+
+	__dma_regs_lock();
+	lpc32xx_dma_ch_disable(ch);
+	dma_clocks_down();
+	__dma_regs_unlock();
+
+	dma_ctrl.dma_channels[ch].name = NULL;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_ch_put);
+
+int lpc32xx_dma_ch_pause_unpause(int ch, int pause) {
+	u32 tmp;
+
+	if (!VALID_CHANNEL(ch))
+		return -EINVAL;
+
+	/* If the channel is already disabled, return */
+	if (dma_ctrl.dma_channels[ch].name == NULL)
+		return -EINVAL;
+
+	tmp = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	if (pause) {
+		tmp |= DMAC_CHAN_HALT;
+	}
+	else {
+		tmp &= ~DMAC_CHAN_HALT;
+	}
+	__raw_writel(tmp, DMACH_CONFIG_CH(DMAIOBASE, ch));
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_ch_pause_unpause);
+
+int lpc32xx_dma_start_pflow_xfer(int ch,
+				void *src,
+				void *dst,
+				int enable)
+{
+	u32 tmp;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL))
+		return -EINVAL;
+
+	/* When starting a DMA transfer where the peripheral is the flow
+	   controller, DMA must be previously disabled */
+	tmp = __raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch));
+	if (tmp & DMAC_CHAN_ENABLE)
+		return -EBUSY;
+
+	__dma_regs_lock();
+	__raw_writel((u32) src, DMACH_SRC_ADDR(DMAIOBASE, ch));
+	__raw_writel((u32) dst, DMACH_DEST_ADDR(DMAIOBASE, ch));
+	__raw_writel(0, DMACH_LLI(DMAIOBASE, ch));
+	__raw_writel(dma_ctrl.dma_channels[ch].control, DMACH_CONTROL(DMAIOBASE, ch));
+
+	tmp = dma_ctrl.dma_channels[ch].config |
+		dma_ctrl.dma_channels[ch].config_int_mask;
+	if (enable != 0)
+		tmp |= DMAC_CHAN_ENABLE;
+	__raw_writel(tmp, DMACH_CONFIG_CH(DMAIOBASE, ch));
+
+	__dma_regs_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_start_pflow_xfer);
+
+int lpc32xx_dma_is_active(int ch)
+{
+	int active = 0;
+
+	if ((VALID_CHANNEL(ch)) && (dma_ctrl.dma_channels[ch].name != NULL)) {
+		if (__raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch)) &
+			DMAC_CHAN_ENABLE)
+			active = 1;
+	}
+
+	return active;
+
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_is_active);
+
+extern u32 lpc32xx_dma_llist_v_to_p(int ch,
+				    u32 vlist) {
+	u32 pptr;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	pptr = vlist - dma_ctrl.dma_channels[ch].list_vstart;
+	pptr += dma_ctrl.dma_channels[ch].list_pstart;
+
+	return pptr;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_llist_v_to_p);
+
+u32 lpc32xx_dma_llist_p_to_v(int ch,
+			     u32 plist) {
+	u32 vptr;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	vptr = plist - dma_ctrl.dma_channels[ch].list_pstart;
+	vptr += dma_ctrl.dma_channels[ch].list_vstart;
+
+	return vptr;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_llist_p_to_v);
+
+u32 lpc32xx_dma_alloc_llist(int ch,
+			     int entries) {
+	int i;
+	dma_addr_t dma_handle;
+	struct dma_list_ctrl *pdmalist, *pdmalistst;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL))
+		return 0;
+
+	/*
+	 * Limit number of list entries, but add 1 extra entry as a spot holder
+	 * for the end of the list
+	 */
+	if (entries < 2) {
+		entries = 2;
+	}
+	if (entries > 64) {
+		entries = 64;
+	}
+	entries++;
+
+	/* Save list information */
+	dma_ctrl.dma_channels[ch].list_entries = entries;
+	dma_ctrl.dma_channels[ch].list_size = (entries * sizeof(struct dma_list_ctrl));
+	dma_ctrl.dma_channels[ch].list_vstart = (u32) dma_alloc_coherent(NULL,
+		dma_ctrl.dma_channels[ch].list_size, &dma_handle, GFP_KERNEL);
+	if (dma_ctrl.dma_channels[ch].list_vstart == 0) {
+		/* No allocated DMA space */
+		return 0;
+	}
+	dma_ctrl.dma_channels[ch].list_pstart = (u32) dma_handle;
+
+	/* Setup list tail and head pointers */
+	pdmalist = pdmalistst = (struct dma_list_ctrl *) dma_ctrl.dma_channels[ch].list_vstart;
+	for (i = 0; i < entries; i++) {
+		pdmalistst->next_list_addr = pdmalistst + 1;
+		pdmalistst->prev_list_addr = pdmalistst - 1;
+		pdmalistst->next_list_phy = lpc32xx_dma_llist_v_to_p(ch, (u32) pdmalistst->next_list_addr);
+		pdmalistst->prev_list_phy = lpc32xx_dma_llist_v_to_p(ch, (u32) pdmalistst->prev_list_addr);
+		pdmalistst++;
+	}
+	pdmalist[entries - 1].next_list_addr = pdmalist;
+	pdmalist[entries - 1].next_list_phy = lpc32xx_dma_llist_v_to_p(ch,
+		(u32) pdmalist[entries - 1].next_list_addr);
+	pdmalist->prev_list_addr = &pdmalist[entries - 1];
+	pdmalist->prev_list_phy = lpc32xx_dma_llist_v_to_p(ch, (u32) pdmalist->prev_list_addr);
+
+	/* Save current free descriptors and current head/tail */
+	dma_ctrl.dma_channels[ch].free_entries = entries - 1;
+	dma_ctrl.dma_channels[ch].list_head = pdmalist;
+	dma_ctrl.dma_channels[ch].list_tail = pdmalist;
+	dma_ctrl.dma_channels[ch].list_curr = pdmalist;
+
+	return dma_ctrl.dma_channels[ch].list_vstart;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_alloc_llist);
+
+void lpc32xx_dma_dealloc_llist(int ch) {
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return;
+
+	dma_free_coherent(NULL, dma_ctrl.dma_channels[ch].list_size,
+		(void *) dma_ctrl.dma_channels[ch].list_vstart,
+		(dma_addr_t) dma_ctrl.dma_channels[ch].list_pstart);
+	dma_ctrl.dma_channels[ch].list_head = 0;
+	dma_ctrl.dma_channels[ch].list_tail = 0;
+	dma_ctrl.dma_channels[ch].list_entries = 0;
+	dma_ctrl.dma_channels[ch].free_entries = 0;
+	dma_ctrl.dma_channels[ch].list_vstart = 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_dealloc_llist);
+
+extern u32 lpc32xx_dma_get_llist_head(int ch) {
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	/* Return the current list pointer (virtual) for the
+	   DMA channel */
+	return lpc32xx_dma_llist_p_to_v(ch,
+		__raw_readl(DMACH_LLI(DMAIOBASE, ch)));
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_get_llist_head);
+
+extern void lpc32xx_dma_flush_llist(int ch) {
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return;
+
+	/* Disable channel and clear LLI */
+	__dma_regs_lock();
+	__dma_disable(ch);
+	__raw_writel(0, DMACH_LLI(DMAIOBASE, ch));
+	__dma_regs_unlock();
+
+	dma_ctrl.dma_channels[ch].list_head = (struct dma_list_ctrl *)
+		dma_ctrl.dma_channels[ch].list_vstart;
+	dma_ctrl.dma_channels[ch].list_tail = (struct dma_list_ctrl *)
+		dma_ctrl.dma_channels[ch].list_vstart;
+	dma_ctrl.dma_channels[ch].list_curr = (struct dma_list_ctrl *)
+		dma_ctrl.dma_channels[ch].list_vstart;
+	dma_ctrl.dma_channels[ch].free_entries =
+		dma_ctrl.dma_channels[ch].list_entries - 1;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_flush_llist);
+
+u32 lpc32xx_dma_queue_llist_entry(int ch,
+				  void *src,
+				  void *dst,
+				  int size) {
+	struct dma_list_ctrl *plhead;
+	u32 ctrl, cfg;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	/* Exit if all the buffers are used */
+	if (dma_ctrl.dma_channels[ch].free_entries == 0) {
+		return 0;
+	}
+
+	/* Next available DMA link descriptor */
+	plhead = dma_ctrl.dma_channels[ch].list_head;
+
+	/* Adjust size to number of transfers (vs bytes) */
+	size = size / dma_ctrl.dma_channels[ch].dmacfg->dst_size;
+
+	/* Setup control and config words */
+	ctrl = dma_ctrl.dma_channels[ch].control | size;
+	cfg = dma_ctrl.dma_channels[ch].config | DMAC_CHAN_ENABLE |
+		dma_ctrl.dma_channels[ch].config_int_mask;
+
+	/* Populate DMA linked data structure */
+	plhead->dmall.src = (u32) src;
+	plhead->dmall.dest = (u32) dst;
+	plhead->dmall.next_lli = 0;
+	plhead->dmall.ctrl = ctrl;
+
+	__dma_regs_lock();
+
+	/* Append this link to the end of the previous link */
+	plhead->prev_list_addr->dmall.next_lli = lpc32xx_dma_llist_v_to_p(ch, (u32) plhead);
+
+	/* Decrement available buffers */
+	dma_ctrl.dma_channels[ch].free_entries--;
+
+	/* If the DMA channel is idle, then the buffer needs to be placed directly into
+	   the DMA registers */
+	if ((__raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch)) & DMAC_CHAN_ENABLE) == 0) {
+		/* DMA is disabled, so move the current buffer into the
+		   channel registers and start transfer */
+		__raw_writel((u32) src, DMACH_SRC_ADDR(DMAIOBASE, ch));
+		__raw_writel((u32) dst, DMACH_DEST_ADDR(DMAIOBASE, ch));
+		__raw_writel(0, DMACH_LLI(DMAIOBASE, ch));
+		__raw_writel(ctrl, DMACH_CONTROL(DMAIOBASE, ch));
+		__raw_writel(cfg, DMACH_CONFIG_CH(DMAIOBASE, ch));
+	}
+	else if (__raw_readl(DMACH_LLI(DMAIOBASE, ch)) == 0) {
+		/* Update current entry to next entry */
+		__raw_writel(dma_ctrl.dma_channels[ch].list_tail->next_list_phy,
+			DMACH_LLI(DMAIOBASE, ch));
+
+		/*
+		 * If the channel was stopped before the next entry made it into the
+		 * hardware descriptor, the next entry didn't make it there fast enough,
+		 * so load the new descriptor here.
+		 */
+		if ((__raw_readl(DMACH_CONFIG_CH(DMAIOBASE, ch)) & DMAC_CHAN_ENABLE) == 0) {
+			__raw_writel((u32) src, DMACH_SRC_ADDR(DMAIOBASE, ch));
+			__raw_writel((u32) dst, DMACH_DEST_ADDR(DMAIOBASE, ch));
+			__raw_writel(0, DMACH_LLI(DMAIOBASE, ch));
+			__raw_writel(ctrl, DMACH_CONTROL(DMAIOBASE, ch));
+			__raw_writel(cfg, DMACH_CONFIG_CH(DMAIOBASE, ch));
+		}
+	}
+
+	/* Process next link on next call */
+	dma_ctrl.dma_channels[ch].list_head = plhead->next_list_addr;
+
+	__dma_regs_unlock();
+
+	return (u32) plhead;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_queue_llist_entry);
+
+extern u32 lpc32xx_get_free_llist_entry(int ch) {
+	struct dma_list_ctrl *pltail;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	/* Exit if no entries to free */
+	if (dma_ctrl.dma_channels[ch].free_entries ==
+		dma_ctrl.dma_channels[ch].list_entries) {
+		return 0;
+	}
+
+	/* Get tail pointer */
+	pltail = dma_ctrl.dma_channels[ch].list_tail;
+
+	/* Next tail */
+	dma_ctrl.dma_channels[ch].list_tail = pltail->next_list_addr;
+
+	/* Increment available buffers */
+	dma_ctrl.dma_channels[ch].free_entries++;
+
+	return (u32) pltail;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_get_free_llist_entry);
+
+int lpc32xx_dma_start_xfer(int ch, u32 config)
+{
+	struct dma_list_ctrl *plhead;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return -1;
+
+	plhead = dma_ctrl.dma_channels[ch].list_head;
+	__dma_regs_lock();
+	__raw_writel(plhead->dmall.src, DMACH_SRC_ADDR(DMAIOBASE, ch));
+	__raw_writel(plhead->dmall.dest, DMACH_DEST_ADDR(DMAIOBASE, ch));
+	__raw_writel(plhead->dmall.next_lli, DMACH_LLI(DMAIOBASE, ch));
+	__raw_writel(plhead->dmall.ctrl, DMACH_CONTROL(DMAIOBASE, ch));
+	__raw_writel(config, DMACH_CONFIG_CH(DMAIOBASE, ch));
+	__dma_regs_unlock();
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_start_xfer);
+
+u32 lpc32xx_dma_queue_llist(int ch, void *src, void *dst,
+				  int size, u32 ctrl)
+{
+	struct dma_list_ctrl *plhead;
+
+	if ((!VALID_CHANNEL(ch)) || (dma_ctrl.dma_channels[ch].name == NULL) ||
+		(dma_ctrl.dma_channels[ch].list_vstart == 0))
+		return 0;
+
+	/* Exit if all the buffers are used */
+	if (dma_ctrl.dma_channels[ch].free_entries == 0) {
+		return 0;
+	}
+
+	/* Next available DMA link descriptor */
+	plhead = dma_ctrl.dma_channels[ch].list_curr;
+
+	/* Populate DMA linked data structure */
+	plhead->dmall.src = (u32) src;
+	plhead->dmall.dest = (u32) dst;
+	plhead->dmall.next_lli = 0;
+	plhead->dmall.ctrl = ctrl;
+
+	/* Append this link to the end of the previous link */
+	plhead->prev_list_addr->dmall.next_lli = lpc32xx_dma_llist_v_to_p(ch, (u32) plhead);
+
+	/* Decrement available buffers */
+	dma_ctrl.dma_channels[ch].free_entries--;
+
+	/* Process next link on next call */
+	dma_ctrl.dma_channels[ch].list_curr = plhead->next_list_addr;
+
+	return (u32) plhead;
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_queue_llist);
+
+extern void lpc32xx_dma_force_burst(int ch, int src)
+{
+	__raw_writel(1 << src, DMA_SW_BURST_REQ(DMAIOBASE));
+}
+EXPORT_SYMBOL_GPL(lpc32xx_dma_force_burst);
+
+static irqreturn_t dma_irq_handler(int irq, void *dev_id)
+{
+	int i;
+	unsigned long dint = __raw_readl(DMA_INT_STAT(DMAIOBASE));
+	unsigned long tcint = __raw_readl(DMA_INT_TC_STAT(DMAIOBASE));
+	unsigned long eint = __raw_readl(DMA_INT_ERR_STAT(DMAIOBASE));
+	unsigned long i_bit;
+
+	for (i = MAX_DMA_CHANNELS - 1; i >= 0; i--) {
+		i_bit = 1 << i;
+		if (dint & i_bit) {
+			struct dma_channel *channel = &dma_ctrl.dma_channels[i];
+
+			if (channel->name && channel->irq_handler) {
+				int cause = 0;
+
+				if (eint & i_bit) {
+					__raw_writel(i_bit, DMA_INT_ERR_CLEAR(DMAIOBASE));
+					cause |= DMA_ERR_INT;
+				}
+				if (tcint & i_bit) {
+					__raw_writel(i_bit, DMA_INT_TC_CLEAR(DMAIOBASE));
+					cause |= DMA_TC_INT;
+				}
+
+				channel->irq_handler(i, cause, channel->data);
+			} else {
+				/*
+				 * IRQ for an unregistered DMA channel
+				 */
+				__raw_writel(i_bit, DMA_INT_ERR_CLEAR(DMAIOBASE));
+				__raw_writel(i_bit, DMA_INT_TC_CLEAR(DMAIOBASE));
+				printk(KERN_WARNING
+				       "spurious IRQ for DMA channel %d\n", i);
+			}
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int __init lpc32xx_dma_init(void)
+{
+	int ret;
+
+	ret = request_irq(IRQ_LPC32XX_DMA, dma_irq_handler, 0, "DMA", NULL);
+	if (ret) {
+		printk(KERN_CRIT "Wow!  Can't register IRQ for DMA\n");
+		goto out;
+	}
+
+	/* Get DMA clock */
+	dma_ctrl.clk = clk_get(NULL, "clk_dmac");
+	if (IS_ERR(dma_ctrl.clk)) {
+		ret = -ENODEV;
+		goto errout;
+	}
+	clk_enable(dma_ctrl.clk);
+
+	/* Clear DMA controller */
+	__raw_writel(1, DMA_CONFIG(DMAIOBASE));
+	__raw_writel(0xFF, DMA_INT_TC_CLEAR(DMAIOBASE));
+	__raw_writel(0xFF, DMA_INT_ERR_CLEAR(DMAIOBASE));
+
+	/* Clock is only enabled when needed to save power */
+	clk_disable(dma_ctrl.clk);
+
+	return 0;
+
+errout:
+	free_irq(IRQ_LPC32XX_DMA, NULL);
+
+out:
+	return ret;
+}
+arch_initcall(lpc32xx_dma_init);
diff --git a/arch/arm/mach-lpc32xx/ea3250.c b/arch/arm/mach-lpc32xx/ea3250.c
new file mode 100644
index 0000000..ec53f76
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/ea3250.c
@@ -0,0 +1,1662 @@
+/*
+ * arch/arm/mach-lpc32xx/ea3250.c
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/eeprom.h>
+#include <linux/leds.h>
+#include <linux/leds-pca9532.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+#include <linux/amba/pl022.h>
+#include <linux/amba/mmci.h>
+#include <linux/kthread.h>
+#include <mtd/mtd-abi.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <mach/gpio.h>
+#include <mach/irqs.h>
+#include <mach/board.h>
+#include "common.h"
+
+#include <linux/spi/ads7846.h>
+
+#define I2C_PCA9532_ADDR 0x60
+#define I2C_24LC256_ADDR 0x50
+
+/*
+ * Mapped GPIOLIB GPIOs
+ */
+#define	LED_GPIO	LPC32XX_GPIO(LPC32XX_GPIO_P2_GRP, 1)
+#define	SPI0_CS_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 11)
+#define	ADS_TS_GPIO	LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 0)
+#define	NAND_WP_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 19)
+#define	LCD_CS_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 4)
+#define	LCD_RS_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 5)
+#define	BKL_POW_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 14)
+#define	SSEL0_GPIO5	LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 5)
+#define	MMC_POWER_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 1)
+
+/*
+ * LCD controller functions
+ */
+#define SET_RS		(gpio_set_value(LCD_RS_GPIO, 1))
+#define RESET_RS	(gpio_set_value(LCD_RS_GPIO, 0))
+
+#define LCDB_PCA9532_I2C_ADDR       (0x64)
+#define LCDB_CONFIG_EEPROM_I2C_ADDR (0x56)
+
+/* PCA9532 registers*/
+#define LCDB_PCA9532_INPUT0   0x00
+#define LCDB_PCA9532_INPUT1   0x01
+#define LCDB_PCA9532_PSC0     0x02
+#define LCDB_PCA9532_PWM0     0x03
+#define LCDB_PCA9532_PSC1     0x04
+#define LCDB_PCA9532_PWM1     0x05
+#define LCDB_PCA9532_LS0      0x06
+#define LCDB_PCA9532_LS1      0x07
+#define LCDB_PCA9532_LS2      0x08
+#define LCDB_PCA9532_LS3      0x09
+#define LCDB_PCA9532_AUTO_INC 0x10
+
+#define LCDB_LS_MODE_ON     0x01
+#define LCDB_LS_MODE_BLINK0 0x02
+#define LCDB_LS_MODE_BLINK1 0x03
+
+#define LCDB_CTRL_3V3     0x0001
+#define LCDB_CTRL_5V      0x0002
+#define LCDB_CTRL_DISP_EN 0x0010
+#define LCDB_CTRL_BL_EN   0x0080
+#define LCDB_CTRL_BL_C    0x0100
+#define LCDB_EEPROM_WP    0x8000
+
+#define LCDB_MAGIC 0xEA01CDAE
+
+#define LCDB_NAME_BUF_SZ 30
+
+static uint16_t blink0Shadow = 0;
+static uint16_t blink1Shadow = 0;
+static uint16_t ledStateShadow = 0;
+
+typedef struct {
+  uint32_t magic;        // magic number
+  uint8_t  lcd_name[LCDB_NAME_BUF_SZ]; // LCD name
+  uint8_t  lcd_mfg[LCDB_NAME_BUF_SZ];  // manufacturer name
+  uint16_t lcdParamOff;  // offset to LCD parameters
+  uint16_t initOff;      // offset to init sequence string
+  uint16_t pdOff;        // offset to power down sequence string
+  uint16_t tsOff;        // offset to touch parameters
+  uint16_t end;          // end offset
+} eaLcdbStore_t;
+
+/* LCD display types */
+typedef enum
+{
+  TFT = 0,      /* Panel type is standard TFT */
+  ADTFT,        /* Panel type is advanced TFT */
+  HRTFT,        /* Panel type is highly reflective TFT */
+  MONO_4BIT,    /* Panel type is 4-bit mono */
+  MONO_8BIT,    /* Panel type is 8-bit mono */
+  CSTN          /* Panel type is color STN */
+} LCD_PANEL_T;
+
+/* Structure containing the parameters for the LCD panel */
+typedef struct
+{
+  uint8_t           h_back_porch;         /* Horizontal back porch in
+                                             clocks (minimum of 1) */
+  uint8_t           h_front_porch;        /* Horizontal front porch in
+                                             clocks (minimum of 1) */
+  uint8_t           h_sync_pulse_width;   /* HSYNC pulse width in
+                                             clocks (minimum of 1) */
+  uint16_t          pixels_per_line;      /* Pixels per line (horizontal
+                                             resolution) */
+  uint8_t           v_back_porch;         /* Vertical back porch in
+                                             clocks */
+  uint8_t           v_front_porch;        /* Vertical front porch in
+                                             clocks */
+  uint8_t           v_sync_pulse_width;   /* VSYNC pulse width in
+                                             clocks (minimum 1 clock) */
+  uint16_t          lines_per_panel;      /* Lines per panel (vertical
+                                             resolution) */
+  uint8_t           invert_output_enable; /* Invert output enable, 1 =
+                                             invert*/
+  uint8_t           invert_panel_clock;   /* Invert panel clock, 1 =
+                                             invert*/
+  uint8_t           invert_hsync;         /* Invert HSYNC, 1 = invert */
+  uint8_t           invert_vsync;         /* Invert VSYNC, 1 = invert */
+  uint8_t           ac_bias_frequency;    /* AC bias frequency in
+                                             clocks (minimum 1) */
+  uint8_t           bits_per_pixel;       /* Maximum bits per pixel the
+                                             display supports */
+  uint32_t          optimal_clock;        /* Optimal clock rate (Hz) */
+  LCD_PANEL_T     lcd_panel_type;       /* LCD panel type */
+  uint8_t           dual_panel;           /* Dual panel, 1 = dual panel
+                                             display */
+
+  /* The following parameters are needed for ADTFT and HRTFT panels
+     only. For all other panels, these should be programmed to 0 */
+  uint8_t           hrtft_cls_enable;     /* HRTFT CLS enable flag, 1 =
+                                             enable */
+  uint8_t           hrtft_sps_enable;     /* HRTFT SPS enable flag, 1 =
+                                             enable */
+  uint8_t           hrtft_lp_to_ps_delay; /* HRTFT LP to PS delay in
+                                             clocks */
+  uint8_t           hrtft_polarity_delay; /* HRTFT polarity delay in
+                                             clocks */
+  uint8_t           hrtft_lp_delay;       /* HRTFT LP delay in clocks */
+  uint8_t           hrtft_spl_delay;      /* HRTFT SPL delay in
+                                             clocks */
+  /* HRTFT SPL to CLKS delay */
+  uint16_t          hrtft_spl_to_cls_delay;
+} LCD_PARAM_T;
+
+#define LCD_SEQUENCE_BUF_SZ  100
+typedef struct
+{
+  char init_seq[LCD_SEQUENCE_BUF_SZ];
+  char power_down_seq[LCD_SEQUENCE_BUF_SZ];
+  char hardware_name[LCDB_NAME_BUF_SZ];
+  char panel_name[LCDB_NAME_BUF_SZ];
+
+  struct clcd_panel lcd_panel_from_eeprom;
+} lpc32xx_lcd_parameters_t;
+
+lpc32xx_lcd_parameters_t* lpc32xx_lcd_parameters = NULL;
+
+static struct i2c_client *ea_i2c_video_client;
+
+struct clcd_board lpc32xx_clcd_data;
+
+/* SPI LCDC device structure */
+struct spi_device *ea3250_spi_lcd_dev = NULL;
+
+/*
+ * Tick LED
+ */
+static struct gpio_led phy_leds[] = {
+	{
+		.name			= "led0",
+		.gpio			= LED_GPIO,
+		.active_low		= 1,
+		.default_trigger	= "heartbeat",
+	},
+};
+
+static struct gpio_led_platform_data led_data = {
+	.leds = phy_leds,
+	.num_leds = ARRAY_SIZE(phy_leds),
+};
+
+static struct platform_device lpc32xx_gpio_led_device = {
+	.name			= "leds-gpio",
+	.id			= -1,
+	.dev.platform_data	= &led_data,
+};
+
+static struct pca9532_platform_data ea3250_leds = {
+	.leds = {
+	{ 	.type = PCA9532_TYPE_NONE }, /* Key 1 */
+	{ 	.type = PCA9532_TYPE_NONE }, /* Key 2 */
+	{ 	.type = PCA9532_TYPE_NONE }, /* Key 3 */
+	{ 	.type = PCA9532_TYPE_NONE }, /* Key 4 */
+	{ 	.type = PCA9532_TYPE_NONE }, /* MMC CD */
+	{ 	.type = PCA9532_TYPE_NONE }, /* MMC WP */
+	{ 	.type = PCA9532_TYPE_NONE }, /* not used */
+	{ 	.type = PCA9532_TYPE_NONE }, /* not used */
+	{	.name = "eabb:red:led1",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led2",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led3",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led4",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led5",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led6",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led7",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	},
+	{	.name = "eabb:red:led8",
+		.state = PCA9532_OFF,
+		.type = PCA9532_TYPE_LED,
+	}, },
+	.psc = { 0, 0 },
+	.pwm = { 0, 0 },
+};
+
+/*
+ * AMBA SSP (SPI)
+ */
+static struct pl022_ssp_controller lpc32xx_ssp0_data = {
+	.bus_id			= 0,
+	.num_chipselect		= 2,
+	.enable_dma		= 0,
+};
+
+static struct amba_device lpc32xx_ssp0_device = {
+	.dev	= {
+		.coherent_dma_mask	= ~0,
+		.init_name		= "dev:ssp0",
+		.platform_data		= &lpc32xx_ssp0_data,
+	},
+	.res				= {
+		.start			= LPC32XX_SSP0_BASE,
+		.end			= (LPC32XX_SSP0_BASE + SZ_4K - 1),
+		.flags			= IORESOURCE_MEM,
+	},
+	.dma_mask			= ~0,
+	.irq				= {IRQ_LPC32XX_SSP0, NO_IRQ},
+};
+
+/*
+ * Touchscreen device
+ */
+/* Touch screen chip select function */
+static void ea3250_spi_cs_set(u32 control)
+{
+	gpio_set_value(SPI0_CS_GPIO, (int) control);
+}
+
+/* Touch screen SPI parameters */
+static struct pl022_config_chip spi0_chip_info = {
+	.com_mode		= INTERRUPT_TRANSFER,
+	.iface			= SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy		= SSP_MASTER,
+	.slave_tx_disable	= 0,
+	.rx_lev_trig		= SSP_RX_4_OR_MORE_ELEM,
+	.tx_lev_trig		= SSP_TX_4_OR_MORE_EMPTY_LOC,
+	.ctrl_len		= SSP_BITS_8,
+	.wait_state		= SSP_MWIRE_WAIT_ZERO,
+	.duplex			= SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control		= ea3250_spi_cs_set,
+};
+
+/* Touch screen interrupt status function */
+static int ea3250_ads7846_pendown_state(void)
+{
+	u32 tmp = gpio_get_value(ADS_TS_GPIO);
+	return (tmp == 0);
+}
+
+/* Touch screen platform data */
+static struct ads7846_platform_data ea_ads7846_platform_data __initdata = {
+	.model      = 7846,
+	.debounce_max	= 10,
+	.debounce_tol	= 3,
+	.pressure_max	= 1024,
+	.get_pendown_state = ea3250_ads7846_pendown_state,
+	.wakeup = true,
+};
+
+/*
+ * SPI based LCDC data
+ */
+/* LCDC chip select function */
+static void ea3250_spi_lcdc_cs_set(u32 control)
+{
+	gpio_set_value(LCD_CS_GPIO, (int) control);
+}
+
+/* LCDC SPI parameters */
+static struct pl022_config_chip spi0_chip_info1 = {
+	.com_mode		= INTERRUPT_TRANSFER,
+	.iface			= SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy		= SSP_MASTER,
+	.slave_tx_disable	= 0,
+	.rx_lev_trig		= SSP_RX_4_OR_MORE_ELEM,
+	.tx_lev_trig		= SSP_TX_4_OR_MORE_EMPTY_LOC,
+	.ctrl_len		= SSP_BITS_8,
+	.wait_state		= SSP_MWIRE_WAIT_ZERO,
+	.duplex			= SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control		= ea3250_spi_lcdc_cs_set,
+};
+
+/* SPI devices registration */
+static int __init ea3250_spi_devices_register(void)
+{
+#if defined(CONFIG_SPI_SPIDEV) || defined(CONFIG_SPI_SPIDEV_MODULE)
+	static struct spi_board_info info[] = {
+		{
+			.modalias = "spidev",
+			.max_speed_hz = 2500000,
+			.bus_num = 0,
+			.chip_select = 0,
+			.controller_data = &spi0_chip_info,
+		},
+	};
+#else
+	struct spi_board_info info[] = {
+		{
+			.modalias      = "ads7846",
+			.max_speed_hz  = 2500000,
+			.chip_select   = 0,
+			.irq           = IRQ_LPC32XX_GPIO_00,
+			.platform_data = &ea_ads7846_platform_data,
+			.controller_data = &spi0_chip_info,
+		},
+		{
+			.modalias      = "ea3250_lcdc",
+			.max_speed_hz  = 10000000,
+			.chip_select   = 1,
+			.controller_data = &spi0_chip_info1,
+		},
+	};
+#endif
+
+	/* Configure ADS TS INT GPIO pin as input */
+	if (gpio_request(ADS_TS_GPIO, "ADS7846 TS INT"))
+		return -EIO;
+	if(gpio_direction_input(ADS_TS_GPIO))
+		return -EIO;
+
+	/* Configure LCDC CS GPIO pin */
+	if (gpio_request(LCD_CS_GPIO, "LCDC CS"))
+		return -EIO;
+	if(gpio_direction_output(LCD_CS_GPIO, 1))
+		return -EIO;
+
+	return spi_register_board_info(info, ARRAY_SIZE(info));
+}
+arch_initcall(ea3250_spi_devices_register);
+
+#if defined (CONFIG_FB_ARMCLCD)
+/*
+ * LCDC AMBA Driver Board Functions
+ */
+/*
+ * Support for Embedded Artists 3.2 inch QVGA LCD panel
+ */
+static struct clcd_panel conn_lcd_panel = {
+	.mode = {
+		.name = "QVGA portrait",
+		.refresh = 60,
+		.xres = 240,
+		.yres = 320,
+		.pixclock = 121654,
+		.left_margin = 28,
+		.right_margin = 10,
+		.upper_margin = 2,
+		.lower_margin = 2,
+		.hsync_len = 3,
+		.vsync_len = 2,
+		.sync = 0,
+		.vmode = FB_VMODE_NONINTERLACED,
+	},
+	.width = -1,
+	.height = -1,
+	.tim2 = (TIM2_IVS | TIM2_IHS | TIM2_IPC),
+	.cntl = (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) |
+			CNTL_LCDBPP16_565),
+	.bpp = 16,
+};
+
+
+static int lpc32xx_clcd_setup(struct clcd_fb *fb)
+{
+	dma_addr_t dma;
+	size_t panel_size = 3 * SZ_64K;
+	struct clcd_panel* panel_to_use = &conn_lcd_panel;
+
+    if (lpc32xx_lcd_parameters != NULL) {
+      panel_to_use = &lpc32xx_lcd_parameters->lcd_panel_from_eeprom;
+    }
+
+	while (panel_size < ((panel_to_use->bpp / 8) * panel_to_use->mode.xres * panel_to_use->mode.yres)) {
+	  panel_size += SZ_64K;
+	}
+
+	fb->fb.screen_base = dma_alloc_writecombine(&fb->dev->dev,
+	    panel_size, &dma, GFP_KERNEL);
+	if (!fb->fb.screen_base) {
+		printk(KERN_ERR "CLCD: unable to map framebuffer\n");
+		return -ENOMEM;
+	}
+
+	fb->fb.fix.smem_start = dma;
+	fb->fb.fix.smem_len = panel_size;
+	fb->panel = panel_to_use;
+
+	if (gpio_request(SSEL0_GPIO5, "Unused GPIO5 input"))
+		return -EIO;
+	if(gpio_direction_input(SSEL0_GPIO5))
+		return -EIO;
+
+	/* Configure LCDC RS GPIO pin */
+	if (gpio_request(LCD_RS_GPIO, "LCDC RS"))
+		return -EIO;
+
+	if(gpio_direction_output(LCD_RS_GPIO, 1))
+		return -EIO;
+
+	/* Configure LCDC Backlight GPIO pin */
+	if (gpio_request(BKL_POW_GPIO, "LCDC BKL"))
+		return -EIO;
+
+	if(gpio_direction_output(BKL_POW_GPIO, 1)) {
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int lpc32xx_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
+{
+	return dma_mmap_writecombine(&fb->dev->dev, vma,
+															fb->fb.screen_base,
+															fb->fb.fix.smem_start,
+															fb->fb.fix.smem_len);
+}
+
+static void lpc32xx_clcd_remove(struct clcd_fb *fb)
+{
+	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
+			fb->fb.screen_base, fb->fb.fix.smem_start);
+}
+
+static int lcdb_eeprom_read(struct i2c_client *client, uint8_t* buf, uint16_t offset, uint16_t len)
+{
+  int i = 0;
+  int ret;
+  uint8_t off[2];
+
+  off[0] = ((offset >> 8) & 0xff);
+  off[1] = (offset & 0xff);
+
+  ret = i2c_master_send(client, off, 2);
+  if (ret != 2)
+  {
+    return -EIO;
+  }
+  for (i = 0; i < 0x2000; i++);
+  ret = i2c_master_recv(client, buf, len);
+  if (ret != len)
+  {
+    return -EIO;
+  }
+  return ret;
+}
+
+/*
+ * Automatically detects the presence of the 4.3" and 7" displays
+ * from Embedded Artists. This is done by reading the display
+ * configuration from an EEPROM on the display board. If the
+ * configuration is present it will be used to setup the display.
+ * If the EEPROM is not found or the configuration is incorrect then
+ * it is assumed that the display is the 3.2" display. The 3.2" display
+ * is present on both the QVGA Base Board and as a separate display
+ * board to use with the OEM Base Board.
+ */
+static int ea_i2c_display_eeprom_probe(struct i2c_client *client,
+      const struct i2c_device_id *id)
+{
+  int result = 0;
+  size_t size;
+  eaLcdbStore_t store;
+  LCD_PARAM_T lcdParams;
+
+  do
+  {
+    /* Read parameter header */
+    size = sizeof(store);
+    result = lcdb_eeprom_read(client, (uint8_t*)&store, 0, size);
+    if (result != size)
+    {
+      break;
+    }
+    if (store.magic != LCDB_MAGIC)
+    {
+      result = -ENODEV;
+      break;
+    }
+
+    /* Found header with correct magic number, now read the LCD parameters */
+    size = (store.initOff-store.lcdParamOff);
+    result = lcdb_eeprom_read(client, (uint8_t*)&lcdParams, store.lcdParamOff, size);
+    if (result != size)
+    {
+      break;
+    }
+
+    /* Allocate memory for display parameters that need to be kept */
+    lpc32xx_lcd_parameters = NULL;
+    size = sizeof(lpc32xx_lcd_parameters_t);
+    lpc32xx_lcd_parameters = kmalloc(size, GFP_KERNEL);
+    if (!lpc32xx_lcd_parameters) {
+      result = -ENOMEM;
+      break;
+    }
+
+    /* Read initialization sequence */
+    size = (store.pdOff-store.initOff);
+    BUG_ON(size > LCD_SEQUENCE_BUF_SZ);
+    result = lcdb_eeprom_read(client, (uint8_t*)lpc32xx_lcd_parameters->init_seq, store.initOff, size);
+    if (result != size)
+    {
+      break;
+    }
+
+    /* Read power down sequence */
+    size = (store.tsOff-store.pdOff);
+    BUG_ON(size > LCD_SEQUENCE_BUF_SZ);
+    result = lcdb_eeprom_read(client, (uint8_t*)lpc32xx_lcd_parameters->power_down_seq, store.pdOff, size);
+    if (result != size)
+    {
+      break;
+    }
+
+    memcpy(lpc32xx_lcd_parameters->hardware_name, store.lcd_name, LCDB_NAME_BUF_SZ);
+
+    if (lcdParams.pixels_per_line == 800 && lcdParams.lines_per_panel == 480) {
+      sprintf(lpc32xx_lcd_parameters->panel_name, "7 inch WVGA landscape");
+    } else if (lcdParams.pixels_per_line == 480 && lcdParams.lines_per_panel == 272) {
+      sprintf(lpc32xx_lcd_parameters->panel_name, "4.3 inch WVGA landscape");
+    } else {
+      sprintf(lpc32xx_lcd_parameters->panel_name, "%d x %d unknown", lcdParams.pixels_per_line, lcdParams.lines_per_panel);
+    }
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.name = lpc32xx_lcd_parameters->panel_name;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.refresh = 60;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.xres = lcdParams.pixels_per_line;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.yres = lcdParams.lines_per_panel;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.pixclock = KHZ2PICOS((lcdParams.optimal_clock / 1000)); //optimal_clock is in Hz
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.left_margin = lcdParams.h_front_porch;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.right_margin = lcdParams.h_back_porch;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.upper_margin = lcdParams.v_front_porch;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.lower_margin = lcdParams.v_back_porch;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.hsync_len = lcdParams.h_sync_pulse_width;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.vsync_len = lcdParams.v_sync_pulse_width;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.sync = 0;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.mode.vmode = FB_VMODE_NONINTERLACED;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.width = -1;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.height = -1;
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.tim2 = (TIM2_IVS | TIM2_IHS);
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.cntl = (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) | CNTL_LCDBPP16_565);
+    lpc32xx_lcd_parameters->lcd_panel_from_eeprom.bpp = 16;
+
+    lpc32xx_clcd_data.name = lpc32xx_lcd_parameters->hardware_name;
+    return 0;
+  } while(0);
+
+  if (lpc32xx_lcd_parameters != NULL)
+  {
+    kfree(lpc32xx_lcd_parameters);
+    lpc32xx_lcd_parameters = NULL;
+  }
+
+  return result;
+}
+
+static int __devexit ea_i2c_display_eeprom_remove(struct i2c_client *client)
+{
+  if (lpc32xx_lcd_parameters != NULL)
+  {
+    kfree(lpc32xx_lcd_parameters);
+    lpc32xx_lcd_parameters = NULL;
+  }
+
+  return 0;
+}
+
+static int ea_i2c_video_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+  ea_i2c_video_client = client;
+  return 0;
+}
+
+static int __devexit ea_i2c_video_remove(struct i2c_client *client)
+{
+  ea_i2c_video_client = NULL;
+  return 0;
+}
+
+static const struct i2c_device_id ea_i2c_video_id[] = {
+    { "ea_i2c_video", 0 },
+    { }
+};
+
+static struct i2c_driver ea_i2c_video_driver = {
+	.driver = {
+		.name	= "ea_i2c_video",
+	},
+	.probe		= ea_i2c_video_probe,
+	.remove		= ea_i2c_video_remove,
+	.id_table	= ea_i2c_video_id,
+};
+
+static const struct i2c_device_id ea_i2c_display_eeprom_id[] = {
+    { "ea_i2c_disp_cfg", 0 },
+    { }
+};
+
+static struct i2c_driver ea_i2c_display_eeprom_driver = {
+  .driver = {
+    .name = "ea_i2c_disp_cfg",
+  },
+  .probe    = ea_i2c_display_eeprom_probe,
+  .remove   = ea_i2c_display_eeprom_remove,
+  .id_table = ea_i2c_display_eeprom_id,
+};
+
+static void init_ea_i2c_video(void)
+{
+  i2c_add_driver(&ea_i2c_display_eeprom_driver);
+  i2c_add_driver(&ea_i2c_video_driver);
+}
+
+/**
+ * Helper function to set LED states
+ */
+static void setLsStates(uint16_t states, uint8_t* ls, uint8_t mode)
+{
+#define IS_LED_SET(bit, x) ( ( ((x) & (bit)) != 0 ) ? 1 : 0 )
+
+    int i = 0;
+
+    for (i = 0; i < 4; i++) {
+
+        ls[i] |= ( (IS_LED_SET(0x0001, states)*mode << 0)
+                | (IS_LED_SET(0x0002, states)*mode << 2)
+                | (IS_LED_SET(0x0004, states)*mode << 4)
+                | (IS_LED_SET(0x0008, states)*mode << 6) );
+
+        states >>= 4;
+    }
+}
+
+/**
+ * Set LEDs (PCA9532 on LCD board)
+ */
+static void setLeds(void)
+{
+    uint8_t buf[5];
+    uint8_t ls[4] = {0,0,0,0};
+    uint16_t states = ledStateShadow;
+
+    /* LEDs in On/Off state */
+    setLsStates(states, ls, LCDB_LS_MODE_ON);
+
+    /* set the LEDs that should blink */
+    setLsStates(blink0Shadow, ls, LCDB_LS_MODE_BLINK0);
+    setLsStates(blink1Shadow, ls, LCDB_LS_MODE_BLINK1);
+
+    buf[0] = LCDB_PCA9532_LS0 | LCDB_PCA9532_AUTO_INC;
+    buf[1] = ls[0];
+    buf[2] = ls[1];
+    buf[3] = ls[2];
+    buf[4] = ls[3];
+    i2c_master_send(ea_i2c_video_client, buf, 5);
+}
+
+/**
+ * Set LED states (on or off).
+ *
+ * Params:
+ *    [in]  ledOnMask  - The LEDs that should be turned on. This mask has
+ *                       priority over ledOffMask
+ *    [in]  ledOffMask - The LEDs that should be turned off.
+ *
+ */
+static void lcdb_pca9532_setLeds (uint16_t ledOnMask, uint16_t ledOffMask)
+{
+    /* turn off leds */
+    ledStateShadow &= (~(ledOffMask) & 0xffff);
+
+    /* ledOnMask has priority over ledOffMask */
+    ledStateShadow |= ledOnMask;
+
+    /* turn off blinking */
+    blink0Shadow &= (~(ledOffMask) & 0xffff);
+    blink1Shadow &= (~(ledOffMask) & 0xffff);
+
+    setLeds();
+}
+
+/**
+ *  Set the blink period for PWM0. Valid values are 0 - 255 where 0
+ *  means 152 Hz and 255 means 0.59 Hz. A value of 151 means 1 Hz.
+ *
+ * Params:
+ *    [in]  period  - the period for pwm0
+ *
+ */
+static void lcdb_pca9532_setBlink0Period(uint8_t period)
+{
+    uint8_t buf[2];
+
+    buf[0] = LCDB_PCA9532_PSC0;
+    buf[1] = period;
+    i2c_master_send(ea_i2c_video_client, buf, 2);
+}
+
+/**
+ * Set the duty cycle for PWM0. Valid values are 0 - 100. 25 means the LED
+ * is on 25% of the period.
+ *
+ * Params:
+ *    [in]  duty  - duty cycle
+ *
+ */
+static void lcdb_pca9532_setBlink0Duty(uint8_t duty)
+{
+    uint8_t buf[2];
+    uint32_t tmp = duty;
+    if (tmp > 100) {
+        tmp = 100;
+    }
+
+    tmp = (255 * tmp)/100;
+
+    buf[0] = LCDB_PCA9532_PWM0;
+    buf[1] = tmp;
+    i2c_master_send(ea_i2c_video_client, buf, 2);
+}
+
+/**
+ *  Set the LEDs that should blink with rate and duty cycle from PWM0.
+ *  Blinking is turned off with pca9532_setLeds.
+ *
+ * Params:
+ *    [in]  ledMask  - LEDs that should blink.
+ *
+ */
+static void lcdb_pca9532_setBlink0Leds(uint16_t ledMask)
+{
+    blink0Shadow |= ledMask;
+    setLeds();
+}
+
+/******************************************************************************
+ *
+ * Description:
+ *    Enable/disable 3V3 signal
+ *
+ *****************************************************************************/
+static void ea_lcdb_ctrl_3v3(uint32_t enable)
+{
+  if (enable) {
+    lcdb_pca9532_setLeds(LCDB_CTRL_3V3, 0);
+  } else {
+    lcdb_pca9532_setLeds(0, LCDB_CTRL_3V3);
+  }
+
+}
+
+/******************************************************************************
+ *
+ * Description:
+ *    Enable/disable 5V signal
+ *
+ *****************************************************************************/
+static void ea_lcdb_ctrl_5v(uint32_t enable)
+{
+  if (enable) {
+    lcdb_pca9532_setLeds(LCDB_CTRL_5V, 0);
+  } else {
+    lcdb_pca9532_setLeds(0, LCDB_CTRL_5V);
+  }
+}
+
+/******************************************************************************
+ *
+ * Description:
+ *    Enable/disable display enable signal
+ *
+ *****************************************************************************/
+static void ea_lcdb_ctrl_display(uint32_t enable)
+{
+  if (!enable) {
+    lcdb_pca9532_setLeds(LCDB_CTRL_DISP_EN, 0);
+  } else {
+    lcdb_pca9532_setLeds(0, LCDB_CTRL_DISP_EN);
+  }
+}
+
+/******************************************************************************
+ *
+ * Description:
+ *    Set backlight contrast
+ *
+ * Params:
+ *   [in] value - backlight value; valid values 0-100
+ *
+ *****************************************************************************/
+static void ea_lcdb_ctrl_backlightContrast(uint32_t value)
+{
+  lcdb_pca9532_setBlink0Duty(100-value);
+  lcdb_pca9532_setBlink0Period(0);
+  lcdb_pca9532_setBlink0Leds(LCDB_CTRL_BL_C);
+}
+
+
+static void spiSend(u8 *buf, size_t len)
+{
+	BUG_ON(ea3250_spi_lcd_dev == NULL);
+	spi_write(ea3250_spi_lcd_dev, buf, len);
+}
+
+static void writeToReg(u16 addr, u16 data)
+{
+	u8 buf[3];
+
+	RESET_RS;
+	buf[0] = 0x00;
+	buf[1] = addr & 0xff;
+	spiSend(buf, 2);
+
+	SET_RS;
+	buf[0] = data >> 8;
+	buf[1] = data & 0xff;
+	spiSend(buf, 2);
+
+	RESET_RS;
+	buf[0] = 0x00;
+	buf[1] = 0x22;
+	spiSend(buf, 2);
+}
+
+static void clcd_display_init(void)
+{
+	u32 tmp;
+
+	/* setup MUX register to use SSP0 */
+	__raw_writel(( _BIT(12) | _BIT(10) | _BIT(9) ), LPC32XX_GPIO_P_MUX_SET);
+	tmp = __raw_readl(LPC32XX_GPIO_P_MUX_SET);
+
+	writeToReg (0x00,0x0001);
+	mdelay(20);
+	writeToReg (0x03,0xA2A4);
+	writeToReg (0x0C,0x0004);
+	writeToReg (0x0D,0x0308);
+	writeToReg (0x0E,0x3000);
+	mdelay(50);
+	writeToReg (0x1E,0x00AF);
+	writeToReg (0x01,0x2B3F);
+	writeToReg (0x02,0x0600);
+	writeToReg (0x10,0x0000);
+	writeToReg (0x07,0x0233);
+	writeToReg (0x0B,0x0039);
+	writeToReg (0x0F,0x0000);
+	mdelay(50);
+
+	writeToReg (0x30,0x0707);
+	writeToReg (0x31,0x0204);
+	writeToReg (0x32,0x0204);
+	writeToReg (0x33,0x0502);
+	writeToReg (0x34,0x0507);
+	writeToReg (0x35,0x0204);
+	writeToReg (0x36,0x0204);
+	writeToReg (0x37,0x0502);
+	writeToReg (0x3A,0x0302);
+	writeToReg (0x3B,0x0302);
+
+	writeToReg (0x23,0x0000);
+	writeToReg (0x24,0x0000);
+
+	writeToReg (0x48,0x0000);
+	writeToReg (0x49,0x013F);
+	writeToReg (0x4A,0x0000);
+	writeToReg (0x4B,0x0000);
+
+	writeToReg (0x41,0x0000);
+	writeToReg (0x42,0x0000);
+
+	writeToReg (0x44,0xEF00);
+	writeToReg (0x45,0x0000);
+	writeToReg (0x46,0x013F);
+	mdelay(50);
+
+	writeToReg (0x44,0xEF00);
+	writeToReg (0x45,0x0000);
+	writeToReg (0x4E,0x0000);
+	writeToReg (0x4F,0x0000);
+	writeToReg (0x46,0x013F);
+}
+
+/**
+ * Convert a string to an integer
+ *
+ * @params str - the string to convert
+ * @params len - length of the string (it might not be null terminated)
+ */
+static uint32_t str_to_uint(char* str, uint32_t len)
+{
+  uint32_t val = 0;
+
+  while(len > 0 && *str <= '9' && *str >= '0') {
+    val = (val * 10) + (*str - '0');
+    str++;
+    len--;
+  }
+
+  return val;
+}
+
+/**
+ * Check if the sequence string version can be handled.
+ *
+ */
+static int checkVersion(char* v, uint32_t len)
+{
+  uint32_t ver = str_to_uint(v, len);
+
+  if (ver > 1) {
+    return -1; //only supports v1
+  }
+
+  return 0;
+}
+
+/**
+ * Execute a control request (PCA9532)
+ */
+static int execSeqCtrl(char* cmd, uint32_t len)
+{
+
+  switch (*cmd++) {
+    // display enable
+    case 'd':
+      ea_lcdb_ctrl_display(*cmd == '1');
+      break;
+
+    // backlight contrast
+    case 'c':
+      ea_lcdb_ctrl_backlightContrast(str_to_uint(cmd, len));
+      break;
+
+    // 3v3 enable
+    case '3':
+      ea_lcdb_ctrl_3v3(*cmd == '1');
+      break;
+
+    // 5v enable
+    case '5':
+      ea_lcdb_ctrl_5v(*cmd == '1');
+      break;
+
+  }
+
+  return 0;
+}
+
+static void lcd_processSequence(char* str)
+{
+  char* c = NULL;
+  int result = 0;
+  uint32_t len;
+
+  BUG_ON(str == NULL);
+
+  while(*str != '\0') {
+
+    // skip whitespace
+    while(*str == ' ') {
+      str++;
+    }
+
+    c = str;
+
+    // find end of command
+    while(*str != ',' && *str != '\0') {
+      str++;
+    }
+
+    len = (str-c);
+
+    if (*str == ',') {
+      str++;
+    }
+
+    switch (*c++) {
+
+      case 'v':
+        result = checkVersion(c, len-1);
+        break;
+
+      // sequence control command (pca9532)
+      case 'c':
+        execSeqCtrl(c, len-1);
+        break;
+
+      // delay
+      case 'd':
+        //execDelay(c, len-1);
+        mdelay(str_to_uint(c, len-1));
+        break;
+
+      // open lcd (init LCD controller)
+      case 'o':
+//        if (lcdParams != NULL) {
+//          *pDev = lcd_open(CLCDC, (int32_t)lcdParams);
+//        }
+//        else {
+//          result = LCDB_RESULT_INVALID_ARG;
+//        }
+        break;
+    }
+
+    if (result != 0) {
+      break;
+    }
+  }
+}
+
+static void lpc32xx_clcd_disable(struct clcd_fb *fb)
+{
+    /* Disable the backlight */
+  if (lpc32xx_lcd_parameters != NULL)
+  {
+    lcd_processSequence(lpc32xx_lcd_parameters->power_down_seq);
+  }
+  else
+  {
+    gpio_set_value(BKL_POW_GPIO, 1);
+  }
+}
+
+static void lpc32xx_clcd_enable(struct clcd_fb *fb)
+{
+  if (lpc32xx_lcd_parameters != NULL)
+  {
+    lcd_processSequence(lpc32xx_lcd_parameters->init_seq);
+  }
+  else
+  {
+    clcd_display_init();
+    gpio_set_value(BKL_POW_GPIO, 0);
+  }
+}
+
+struct clcd_board lpc32xx_clcd_data = {
+    .name = "Default 3.2 inch LCD",
+	.check = clcdfb_check,
+	.decode = clcdfb_decode,
+	.disable = lpc32xx_clcd_disable,
+	.enable = lpc32xx_clcd_enable,
+	.setup = lpc32xx_clcd_setup,
+	.mmap = lpc32xx_clcd_mmap,
+	.remove = lpc32xx_clcd_remove,
+};
+
+struct amba_device lpc32xx_clcd_device = {
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.init_name = "dev:clcd",
+		.platform_data = &lpc32xx_clcd_data,
+	},
+	.res                            = {
+		.start = LPC32XX_LCD_BASE,
+		.end = (LPC32XX_LCD_BASE + SZ_4K - 1),
+		.flags = IORESOURCE_MEM,
+	},
+	.dma_mask = ~0,
+	.irq = {IRQ_LPC32XX_LCD, NO_IRQ},
+};
+
+
+/*
+ * SPI LCDC Driver Probe function
+ */
+static int ea3250_spi_lcdc_probe(struct spi_device *spi)
+{
+	int err;
+
+	spi->mode = SPI_MODE_0;
+	ea3250_spi_lcd_dev = spi;
+
+	/* SPI settings */
+	err = spi_setup(spi);
+	if (err < 0) {
+		dev_err(&spi->dev, "Err in setting SPI \n");
+		return err;
+	}
+
+	return 0;
+}
+
+/*
+ *  * SPI LCDC Driver remove function
+ *   * */
+static int ea3250_spi_lcdc_remove(struct spi_device *spi)
+{
+	return 0;
+}
+
+static struct spi_driver ea3250_spi_lcdc_driver = {
+	.driver = {
+		.name   = "ea3250_lcdc",
+		.bus    = &spi_bus_type,
+		.owner  = THIS_MODULE,
+	},
+	.probe  = ea3250_spi_lcdc_probe,
+	.remove = __devexit_p(ea3250_spi_lcdc_remove),
+};
+
+void __init ea3250_spi_lcdc_drv_init(void)
+{
+  if (lpc32xx_lcd_parameters == NULL)
+  {
+    spi_register_driver(&ea3250_spi_lcdc_driver);
+  }
+}
+#endif //defined (CONFIG_FB_ARMCLCD)
+
+#if defined (CONFIG_MMC_ARMMMCI)
+
+static int card_inserted = 1;
+
+static int card_detect_thread(void __iomem* d)
+{
+    int err = 0;
+    struct i2c_adapter *adap;
+    struct i2c_client *client;
+    u8 data = 0;
+
+    while (!kthread_should_stop()) {
+        adap = i2c_get_adapter(0);
+
+        if (!adap) {
+            set_current_state(TASK_INTERRUPTIBLE);
+            schedule_timeout(HZ);
+
+            continue;
+        }
+
+        list_for_each_entry(client, &adap->userspace_clients, detected) {
+            if (client->addr == I2C_PCA9532_ADDR) {
+
+                i2c_put_adapter(adap);
+
+                /* select input0 register */
+                data = 0;
+                err = i2c_master_send(client, (char*)&data ,1);
+
+                /* read value from register */
+                err = i2c_master_recv(client, (char*)&data, 1);
+
+                /* LED4 input on PCA9532 is connected to card detect (active low) */
+                card_inserted = ((data & 0x10) == 0);
+
+                break;
+            }
+        }
+
+        set_current_state(TASK_INTERRUPTIBLE);
+        schedule_timeout(HZ);
+    }
+
+    return 0;
+}
+
+static struct task_struct *cd_thread;
+
+static void card_detect_start(void)
+{
+    cd_thread = kthread_run(card_detect_thread, NULL, "card-detect");
+    if (IS_ERR(cd_thread)) {
+        printk(KERN_INFO "Failed to start card detect thread\n");
+    }
+}
+
+static void card_detect_stop(void)
+{
+    kthread_stop(cd_thread);
+}
+
+/*
+ * Returns !0 when card is removed, 0 when present
+ */
+unsigned int mmc_card_detect(struct device *dev)
+{
+	/*
+	 * This function may be adapted to retrieve the actual 'card detect'
+	 * status over the I2C bus, from PCA9532 pin 8 (LED4). For now, simply
+	 * indicate that a card is always present.
+	*/
+	return card_inserted;
+}
+
+/*
+ * Enable or disable SD slot power
+ */
+void mmc_power_enable(int enable)
+{
+	if (enable != 0) {
+	    card_detect_start();
+
+		/* active low */
+		gpio_set_value(MMC_POWER_GPIO,0);
+	}
+	else {
+	    card_detect_stop();
+
+		gpio_set_value(MMC_POWER_GPIO,1);
+	}
+}
+
+/*
+ * Board specific MMC driver data
+ */
+struct mmci_platform_data lpc32xx_plat_data = {
+	.ocr_mask	= MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33|MMC_VDD_33_34,
+	.vdd_handler	= NULL,
+	.capabilities	= MMC_CAP_4_BIT_DATA,
+
+	/*
+	 * Indicate no direct GPIO, so MMC driver will assume card is NOT
+	 * write-protected
+	 */
+	.gpio_wp        = -ENOSYS,
+
+	/*
+	 * Indicate no direct GPIO, so MMC driver will call 'status' callback
+	 * function
+	 */
+	.gpio_cd        = -ENOSYS,
+
+	/*
+	 * Callback function, used by MMC driver in case 'gpio_cd'
+	 * equals -ENOSYS
+	 */
+	.status		= mmc_card_detect,
+};
+
+/*
+ * SD card controller resources
+ */
+struct amba_device lpc32xx_mmc_device = {
+	.dev				= {
+		.coherent_dma_mask	= ~0,
+		.init_name		= "dev:mmc0",
+		.platform_data		= &lpc32xx_plat_data,
+	},
+	.res				= {
+		.start			= LPC32XX_SD_BASE,
+		.end			= (LPC32XX_SD_BASE + SZ_4K - 1),
+		.flags			= IORESOURCE_MEM,
+	},
+	.dma_mask			= ~0,
+	.irq				= {IRQ_LPC32XX_SD0, IRQ_LPC32XX_SD1},
+};
+#endif
+
+/* AMBA based devices list */
+static struct amba_device *amba_devs[] __initdata = {
+	&lpc32xx_ssp0_device,
+#if defined (CONFIG_FB_ARMCLCD)
+	&lpc32xx_clcd_device,
+#endif
+#if defined (CONFIG_MMC_ARMMMCI)
+	&lpc32xx_mmc_device,
+#endif
+};
+
+/*
+ * Register AMBA BUS Devices.
+ * Call AMBA device restration after SPI driver probe(),
+ * as LCD controller uses SPI driver for initialization
+ */
+static int __init ea3250_amba_devices_register(void)
+{
+	u32 i = 0;
+
+	/* Add AMBA devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		struct amba_device *d = amba_devs[i];
+		amba_device_register(d, &iomem_resource);
+	}
+
+	return 0;
+}
+device_initcall_sync(ea3250_amba_devices_register);
+
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+/*
+ *  * Board specific NAND setup data
+ *   */
+static int nandwp_enable(int enable)
+{
+	if (enable != 0)
+		gpio_set_value(NAND_WP_GPIO,0);
+	else
+		gpio_set_value(NAND_WP_GPIO,1);
+
+	return 1;
+}
+#define BLK_SIZE (2048 * 64)
+static struct mtd_partition ea3250_nand_partition[] = {
+	{
+		.name = "ea3250-boot",
+		.offset = 0,
+		.size = (BLK_SIZE * 4),
+		.mask_flags = MTD_WRITEABLE,
+	},
+	{
+		.name = "ea3250-uboot",
+		.offset = MTDPART_OFS_APPEND,
+		.size = (BLK_SIZE * 6)
+	},
+	{
+		.name = "ea3250-kernel",
+		.offset = MTDPART_OFS_APPEND,
+		.size = (BLK_SIZE * 32)
+	},
+	{
+		.name = "ea3250-jffs2",
+		.offset = MTDPART_OFS_APPEND,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+static struct mtd_partition * ea3250_nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(ea3250_nand_partition);
+	return ea3250_nand_partition;
+}
+struct lpc32XX_nand_cfg lpc32xx_nandcfg =
+{
+	.wdr_clks = 14,
+	.wwidth = 260000000,
+	.whold = 104000000,
+	.wsetup = 200000000,
+	.rdr_clks = 14,
+	.rwidth = 34666666,
+	.rhold = 104000000,
+	.rsetup = 200000000,
+	.use_bbt = true,
+	.polled_completion = false,
+	.enable_write_prot = nandwp_enable,
+	.partition_info = ea3250_nand_partitions,
+};
+
+/*
+ *  * SLC NAND resources
+ *   */
+static struct resource slc_nand_resources[] = {
+	[0] = {
+		.start = LPC32XX_SLC_BASE,
+		.end = LPC32XX_SLC_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_FLASH,
+		.end = IRQ_LPC32XX_FLASH,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 lpc32xx_slc_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_slc_nand_device = {
+	.name = "lpc32xx-nand",
+	.id = 0,
+	.dev = {
+		.platform_data = &lpc32xx_nandcfg,
+		.dma_mask = &lpc32xx_slc_dma_mask,
+		.coherent_dma_mask = ~0UL,
+	},
+	.num_resources = ARRAY_SIZE(slc_nand_resources),
+	.resource = slc_nand_resources,
+};
+#endif
+
+/*
+ * Network Support
+ */
+static struct lpc_net_cfg lpc32xx_netdata =
+{
+	.phy_irq        = -1,
+	.phy_mask       = 0xFFFFFFF0,
+};
+
+static struct resource net_resources[] = {
+	[0] = {
+		.start = LPC32XX_ETHERNET_BASE,
+		.end = LPC32XX_ETHERNET_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start = IRQ_LPC32XX_ETHERNET,
+		.end = IRQ_LPC32XX_ETHERNET,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 lpc32xx_mac_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_net_device = {
+	.name = "lpc-net",
+	.id = 0,
+	.dev = {
+		.dma_mask = &lpc32xx_mac_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data = &lpc32xx_netdata,
+	},
+	.num_resources = ARRAY_SIZE(net_resources),
+	.resource = net_resources,
+};
+
+/*
+ * I2C devices support
+ */
+#if defined (CONFIG_LEDS_PCA9532) || defined (CONFIG_EEPROM_AT24) || defined (CONFIG_FB_ARMCLCD)
+	static struct i2c_board_info __initdata ea3250_i2c_board_info [] = {
+#if defined (CONFIG_LEDS_PCA9532)
+		{
+			I2C_BOARD_INFO("pca9532", I2C_PCA9532_ADDR),
+			.platform_data = &ea3250_leds,
+		},
+#endif
+#if defined (CONFIG_FB_ARMCLCD)
+		{
+			/* 8Kb Configuration EEPROM on display board */
+			I2C_BOARD_INFO("ea_i2c_disp_cfg", LCDB_CONFIG_EEPROM_I2C_ADDR),
+		},
+		{
+			I2C_BOARD_INFO("ea_i2c_video", LCDB_PCA9532_I2C_ADDR),
+		},
+#endif
+#if defined (CONFIG_EEPROM_AT24)
+		{
+			I2C_BOARD_INFO("24c256", I2C_24LC256_ADDR),
+		},
+#endif
+	};
+#endif
+
+static struct platform_device* ea3250_devs[] __initdata = {
+	&lpc32xx_i2c0_device,
+	&lpc32xx_i2c1_device,
+	&lpc32xx_i2c2_device,
+	&lpc32xx_watchdog_device,
+	&lpc32xx_gpio_led_device,
+	&lpc32xx_rtc_device,
+	&lpc32xx_net_device,
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+	&lpc32xx_slc_nand_device,
+#endif
+#if defined(CONFIG_USB_OHCI_HCD)
+	&lpc32xx_ohci_device,
+#endif
+#if defined(CONFIG_USB_GADGET_LPC32XX)
+	&lpc32xx_usbd_device,
+#endif
+	&lpc32xx_i2s_device,
+	&lpc32xx_asoc_plat_device,
+};
+
+
+/*
+ * Board specific functions
+ */
+void __init ea3250_board_init(void)
+{
+	u32 tmp;
+
+	/* Intiliase GPIO */
+	lpc32xx_gpio_init();
+
+#if defined (CONFIG_MMC_ARMMMCI)
+	/* Enable SD slot power */
+	mmc_power_enable(1);
+#endif
+
+	/* Set SPI CS GPIO to output */
+	gpio_request(SPI0_CS_GPIO, "spi0 cs");
+	gpio_direction_output(SPI0_CS_GPIO, 1);
+
+	/* Setup network interface for RMII mode */
+	tmp = __raw_readl(LPC32XX_CLKPWR_MACCLK_CTRL);
+	tmp &= ~LPC32XX_CLKPWR_MACCTRL_PINS_MSK;
+	tmp |= LPC32XX_CLKPWR_MACCTRL_USE_RMII_PINS;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MACCLK_CTRL);
+
+	/* Setup SLC NAND controller */
+	__raw_writel(LPC32XX_CLKPWR_NANDCLK_SEL_SLC,
+			LPC32XX_CLKPWR_NAND_CLK_CTRL);
+
+	/* Setup LCD muxing to RGB565 */
+	tmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL) &
+		~(LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_MSK |
+				LPC32XX_CLKPWR_LCDCTRL_PSCALE_MSK);
+	tmp |= LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT16;
+	__raw_writel(tmp, LPC32XX_CLKPWR_LCDCLK_CTRL);
+
+	/* Set up I2C pull levels */
+	tmp = __raw_readl(LPC32XX_CLKPWR_I2C_CLK_CTRL);
+	tmp |= LPC32XX_CLKPWR_I2CCLK_USBI2CHI_DRIVE |
+		LPC32XX_CLKPWR_I2CCLK_I2C2HI_DRIVE;
+	__raw_writel(tmp, LPC32XX_CLKPWR_I2C_CLK_CTRL);
+
+	/* Enable DMA for I2S1 channel */
+	tmp = __raw_readl(LPC32XX_CLKPWR_I2S_CLK_CTRL);
+	tmp = LPC32XX_CLKPWR_I2SCTRL_I2S1_USE_DMA;
+	__raw_writel(tmp, LPC32XX_CLKPWR_I2S_CLK_CTRL);
+
+	/* Initalise Serial device */
+	lpc32xx_serial_init();
+
+	/*
+	 * AMBA peripheral clocks need to be enabled prior to AMBA device
+	 * detection or a data fault will occur, so enable the clocks
+	 * here. However, we don't want to enable them if the peripheral
+	 * isn't included in the image
+	 */
+	/* Initialise SSP clock */
+	tmp = __raw_readl(LPC32XX_CLKPWR_SSP_CLK_CTRL);
+	__raw_writel((tmp | LPC32XX_CLKPWR_SSPCTRL_SSPCLK0_EN),
+			LPC32XX_CLKPWR_SSP_CLK_CTRL);
+
+	/* Initialise LCD clock */
+	tmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL);
+	__raw_writel((tmp | LPC32XX_CLKPWR_LCDCTRL_CLK_EN),
+			LPC32XX_CLKPWR_LCDCLK_CTRL);
+
+	/* Enable SD card clock so AMBA driver will work correctly. The
+	   AMBA driver needs the clock before the SD card controller
+	   driver initializes it. The clock will turn off once the driver
+	   has been initialized. */
+	tmp = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
+	tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_EN |
+		LPC32XX_CLKPWR_MSCARD_MSDIO_PU_EN;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MS_CTRL);
+
+	/* Disable UART5->USB transparent mode or USB won't work */
+	tmp = __raw_readl(LPC32XX_UARTCTL_CTRL);
+	tmp &= ~LPC32XX_UART_U5_ROUTE_TO_USB;
+	__raw_writel(tmp, LPC32XX_UARTCTL_CTRL);
+
+	/* Add platform devcies */
+	platform_add_devices(ea3250_devs, ARRAY_SIZE(ea3250_devs));
+
+	/* Test clock needed for UDA1380 initial init */
+	__raw_writel(LPC32XX_CLKPWR_TESTCLK2_SEL_MOSC |
+			LPC32XX_CLKPWR_TESTCLK_TESTCLK2_EN,
+			LPC32XX_CLKPWR_TEST_CLK_SEL);
+
+#if defined (CONFIG_LEDS_PCA9532) || defined (CONFIG_EEPROM_AT24) || defined (CONFIG_FB_ARMCLCD)
+	i2c_register_board_info(0, ea3250_i2c_board_info,
+			ARRAY_SIZE(ea3250_i2c_board_info));
+#endif
+
+#if defined (CONFIG_FB_ARMCLCD)
+	/* Register the I2C driver for LCD */
+	init_ea_i2c_video();
+
+	/* Register SPI driver for LCD */
+	ea3250_spi_lcdc_drv_init();
+#endif
+}
+
+static int __init lpc32xx_display_uid(void)
+{
+	u32 uid[4];
+
+	lpc32xx_get_uid(uid);
+
+	printk(KERN_INFO "LPC32XX unique ID: %08x%08x%08x%08x\n",
+			uid[3], uid[2], uid[1], uid[0]);
+
+	return 1;
+}
+arch_initcall(lpc32xx_display_uid);
+
+MACHINE_START (EA3250, "Embedded Artists LPC3250 OEM board with the LPC3250 Microcontroller")
+	/* Maintainer: Embedded Artists */
+	.atag_offset	= 0x100,
+	.map_io		= lpc32xx_map_io,
+	.init_irq	= lpc32xx_init_irq,
+	.timer		= &lpc32xx_timer,
+	.init_machine	= ea3250_board_init,
+MACHINE_END
+
+/* For backwards compatibility with older bootloaders only */
+MACHINE_START (LPC3XXX, "Embedded Artists LPC3250 OEM board with the LPC3250 Microcontroller")
+	/* Maintainer: Embedded Artists */
+	.atag_offset	= 0x100,
+	.map_io		= lpc32xx_map_io,
+	.init_irq	= lpc32xx_init_irq,
+	.timer		= &lpc32xx_timer,
+	.init_machine	= ea3250_board_init,
+MACHINE_END
+
diff --git a/arch/arm/mach-lpc32xx/fdi3250.c b/arch/arm/mach-lpc32xx/fdi3250.c
new file mode 100644
index 0000000..2dff3c6
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/fdi3250.c
@@ -0,0 +1,602 @@
+/*
+ * arch/arm/mach-lpc32xx/fdi3250.c
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/sysdev.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/eeprom.h>
+#include <linux/leds.h>
+#include <linux/gpio.h>
+#include <linux/input.h>
+#include <linux/amba/bus.h>
+#include <linux/amba/clcd.h>
+#include <linux/amba/pl022.h>
+#include <linux/amba/mmci.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/mach/arch.h>
+
+#include <mach/hardware.h>
+#include <mach/platform.h>
+#include <mach/board.h>
+#include "common.h"
+
+/*
+ * Mapped GPIOLIB GPIOs
+ */
+#define	LED_GPIO		LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 3)
+#define	SPI_CS_GPIO		LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 5)
+#define	NAND_WP_GPIO		LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 19)
+
+/*
+ * Tick LED
+ */
+static struct gpio_led phy_leds[] = {
+	{
+		.name			= "led0",
+		.gpio			= LED_GPIO,
+		.active_low		= 1,
+		.default_trigger	= "heartbeat",
+	},
+};
+
+static struct gpio_led_platform_data led_data = {
+	.leds = phy_leds,
+	.num_leds = ARRAY_SIZE(phy_leds),
+};
+
+static struct platform_device lpc32xx_gpio_led_device = {
+	.name			= "leds-gpio",
+	.id			= -1,
+	.dev.platform_data	= &led_data,
+};
+
+/*
+ * AMBA SSP (SPI)
+ */
+static struct pl022_ssp_controller lpc32xx_ssp0_data = {
+	.bus_id			= 0,
+	.num_chipselect		= 2,
+	.enable_dma		= 0,
+};
+
+static struct amba_device lpc32xx_ssp0_device = {
+	.dev	= {
+		.coherent_dma_mask	= ~0,
+		.init_name		= "dev:ssp0",
+		.platform_data		= &lpc32xx_ssp0_data,
+	},
+	.res				= {
+		.start			= LPC32XX_SSP0_BASE,
+		.end			= (LPC32XX_SSP0_BASE + SZ_4K - 1),
+		.flags			= IORESOURCE_MEM,
+	},
+	.dma_mask			= ~0,
+	.irq				= {IRQ_LPC32XX_SSP0, NO_IRQ},
+};
+
+/* SPIDEV chip select function */
+static void fdi3250_spi_cs_set(u32 control)
+{
+	gpio_set_value(SPI_CS_GPIO, (int) control);
+}
+
+/* SPIDEV parameters */
+static struct pl022_config_chip spi0_chip_info = {
+	.com_mode		= INTERRUPT_TRANSFER,
+	.iface			= SSP_INTERFACE_MOTOROLA_SPI,
+	.hierarchy		= SSP_MASTER,
+	.slave_tx_disable	= 0,
+	.rx_lev_trig		= SSP_RX_4_OR_MORE_ELEM,
+	.tx_lev_trig		= SSP_TX_4_OR_MORE_EMPTY_LOC,
+	.ctrl_len		= SSP_BITS_8,
+	.wait_state		= SSP_MWIRE_WAIT_ZERO,
+	.duplex			= SSP_MICROWIRE_CHANNEL_FULL_DUPLEX,
+	.cs_control		= fdi3250_spi_cs_set,
+};
+
+/* SPI devices registration */
+static int __init fdi3250_spi_devices_register(void)
+{
+	static struct spi_board_info info[] = {
+		{
+			.modalias = "spidev",
+			.max_speed_hz = 2500000,
+			.bus_num = 0,
+			.chip_select = 0,
+			.controller_data = &spi0_chip_info,
+		},
+	};
+
+	return spi_register_board_info(info, ARRAY_SIZE(info));
+}
+arch_initcall(fdi3250_spi_devices_register);
+
+#if defined (CONFIG_FB_ARMCLCD)
+/*
+ * Board specific LCD setup and functions
+ */
+#if defined (CONFIG_SOM9DIMM3250_LCD_PANEL)
+/*
+ * Support for QVGA portrait panel
+ */
+#if defined (CONFIG_SOM9DIMM3250_LCD_TOSHIBA_QVGA_35)
+static struct clcd_panel conn_lcd_panel = {
+	.mode		= {
+		.name		= "QVGA portrait",
+		.refresh	= 30,
+		.xres		= 320,
+		.yres		= 240,
+		.pixclock	= 158730,
+		.left_margin	= 11,
+		.right_margin	= 3,
+		.upper_margin	= 7,
+		.lower_margin	= 7,
+		.hsync_len	= 69,
+		.vsync_len	= 45,
+		.sync		= FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+	.width		= -1,
+	.height		= -1,
+	.tim2		= 0,
+	.cntl		= (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) |
+				CNTL_LCDBPP16_565),
+	.bpp		= 16,
+};
+#define PANEL_SIZE (3 * SZ_64K)
+#endif
+#if defined (CONFIG_SOM9DIMM3250_LCD_OKAYA_VGA_35)
+static struct clcd_panel conn_lcd_panel = {
+	.mode		= {
+		.name		= "VGA portrait",
+		.refresh	= 30,
+		.xres		= 640,
+		.yres		= 480,
+		.pixclock	= 41666,
+		.left_margin	= 10,
+		.right_margin	= 120,
+		.upper_margin	= 7,
+		.lower_margin	= 35,
+		.hsync_len	= 30,
+		.vsync_len	= 3,
+		.sync		= FB_SYNC_HOR_HIGH_ACT|FB_SYNC_VERT_HIGH_ACT,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+	.width		= -1,
+	.height		= -1,
+	.tim2		= 0,
+	.cntl		= (CNTL_BGR | CNTL_LCDTFT | CNTL_LCDVCOMP(1) |
+				CNTL_LCDBPP16_565),
+	.bpp		= 16,
+};
+#define PANEL_SIZE (10 * SZ_64K)
+#endif
+
+#endif // CONFIG_SOM9DIMM3250_LCD_PANEL
+
+static int lpc32xx_clcd_setup(struct clcd_fb *fb)
+{
+	dma_addr_t dma;
+
+	fb->fb.screen_base = dma_alloc_writecombine(&fb->dev->dev,
+			PANEL_SIZE, &dma, GFP_KERNEL);
+	if (!fb->fb.screen_base) {
+		printk(KERN_ERR "CLCD: unable to map framebuffer\n");
+		return -ENOMEM;
+	}
+
+	fb->fb.fix.smem_start = dma;
+	fb->fb.fix.smem_len = PANEL_SIZE;
+	fb->panel = &conn_lcd_panel;
+
+	return 0;
+}
+
+static int lpc32xx_clcd_mmap(struct clcd_fb *fb, struct vm_area_struct *vma)
+{
+	return dma_mmap_writecombine(&fb->dev->dev, vma,
+															fb->fb.screen_base,
+															fb->fb.fix.smem_start,
+															fb->fb.fix.smem_len);
+}
+
+static void lpc32xx_clcd_remove(struct clcd_fb *fb)
+{
+	dma_free_writecombine(&fb->dev->dev, fb->fb.fix.smem_len,
+			fb->fb.screen_base, fb->fb.fix.smem_start);
+}
+
+void clcd_disable(struct clcd_fb *fb)
+{
+#if defined (CONFIG_SOM9DIMM3250_LCD_TOSHIBA_QVGA_35)
+	__raw_writel(0x40000000, io_p2v(LPC32XX_PWM1_BASE));
+#elif defined (CONFIG_SOM9DIMM3250_LCD_OKAYA_VGA_35)
+	__raw_writel(0x00000000, io_p2v(LPC32XX_PWM1_BASE));
+#endif
+}
+
+void clcd_enable(struct clcd_fb *fb)
+{
+#if defined (CONFIG_SOM9DIMM3250_LCD_TOSHIBA_QVGA_35)
+	__raw_writel(0x00000000, io_p2v(LPC32XX_PWM1_BASE));
+#elif defined (CONFIG_SOM9DIMM3250_LCD_OKAYA_VGA_35)
+	__raw_writel(0x40000000, io_p2v(LPC32XX_PWM1_BASE));
+#endif
+}
+
+struct clcd_board lpc32xx_clcd_data = {
+#if defined (CONFIG_SOM9DIMM3250_LCD_TOSHIBA_QVGA_35)
+	.name = "Toshiba 3.5 inch LCD",
+#elif defined (CONFIG_SOM9DIMM3250_LCD_OKAYA_VGA_35)
+	.name = "Okaya 3.5 inch LCD",
+#else
+	.name = "Unknown Display",
+#endif
+	.check = clcdfb_check,
+	.decode = clcdfb_decode,
+	.disable = clcd_disable,
+	.enable = clcd_enable,
+	.setup = lpc32xx_clcd_setup,
+	.mmap = lpc32xx_clcd_mmap,
+	.remove = lpc32xx_clcd_remove,
+};
+
+struct amba_device lpc32xx_clcd_device = {
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.init_name = "dev:clcd",
+		.platform_data = &lpc32xx_clcd_data,
+	},
+	.res = {
+		.start = LPC32XX_LCD_BASE,
+		.end = (LPC32XX_LCD_BASE + SZ_4K - 1),
+		.flags = IORESOURCE_MEM,
+	},
+	.dma_mask = ~0,
+	.irq = {IRQ_LPC32XX_LCD, NO_IRQ},
+};
+#endif
+
+#if defined (CONFIG_MMC_ARMMMCI)
+static u32 mmc_translate_vdd(struct device *dev, unsigned int vdd,
+		unsigned char mode)
+{
+	return 0;
+}
+
+unsigned int fdi_mmc_status_always_on(struct device *dev)
+{
+	return 0;
+}
+/*
+ * Board specific MMC driver data
+ */
+struct mmci_platform_data lpc32xx_plat_data = {
+	.ocr_mask       = MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33|MMC_VDD_33_34,
+	.vdd_handler	= mmc_translate_vdd,
+	.capabilities   = MMC_CAP_4_BIT_DATA,
+	.gpio_wp        = ARCH_NR_GPIOS + 1,
+	.gpio_cd        = ARCH_NR_GPIOS + 1,
+	.status         = fdi_mmc_status_always_on,
+};
+
+/*
+ * SD card controller resources
+ */
+struct amba_device lpc32xx_mmc_device = {
+	.dev = {
+		.coherent_dma_mask      = ~0,
+		.init_name                 = "dev:mmc0",
+		.platform_data          = &lpc32xx_plat_data,
+	},
+	.res = {
+		.start                  = LPC32XX_SD_BASE,
+		.end                    = (LPC32XX_SD_BASE + SZ_4K - 1),
+		.flags                  = IORESOURCE_MEM,
+	},
+	.dma_mask                       = ~0,
+	.irq                            = {IRQ_LPC32XX_SD0, IRQ_LPC32XX_SD1},
+};
+#endif
+
+/* AMBA based devices list */
+static struct amba_device *amba_devs[] __initdata = {
+	&lpc32xx_ssp0_device,
+#if defined (CONFIG_FB_ARMCLCD)
+	&lpc32xx_clcd_device,
+#endif
+#if defined(CONFIG_MMC_ARMMMCI)
+	&lpc32xx_mmc_device,
+#endif
+};
+
+/*
+ * Register AMBA BUS Devices.
+ * Call AMBA device restration after SPI driver probe(),
+ * as LCD controller uses SPI driver for initialization
+ */
+static int __init fdi3250_amba_devices_register(void)
+{
+	u32 i = 0;
+
+	/* Add AMBA devices */
+	for (i = 0; i < ARRAY_SIZE(amba_devs); i++) {
+		struct amba_device *d = amba_devs[i];
+		amba_device_register(d, &iomem_resource);
+	}
+
+	return 0;
+}
+device_initcall_sync(fdi3250_amba_devices_register);
+
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+/*
+ *  * Board specific NAND setup data
+ *   */
+static int nandwp_enable(int enable)
+{
+	if (enable != 0)
+		gpio_set_value(NAND_WP_GPIO,0);
+	else
+		gpio_set_value(NAND_WP_GPIO,1);
+
+	return 1;
+}
+#define BLK_SIZE (2048 * 64)
+static struct mtd_partition fdi3250_nand_partition[] = {
+	{
+		.name = "fdi3250-boot",
+		.offset = 0,
+		.size = (BLK_SIZE * 4)
+	},
+	{
+		.name = "fdi3250-uboot",
+		.offset = MTDPART_OFS_APPEND,
+		.size = (BLK_SIZE * 6)
+	},
+	{
+		.name = "fdi3250-kernel",
+		.offset = MTDPART_OFS_APPEND,
+		.size = (BLK_SIZE * 32)
+	},
+	{
+		.name = "fdi3250-jffs2",
+		.offset = MTDPART_OFS_APPEND,
+		.size = MTDPART_SIZ_FULL
+	},
+};
+static struct mtd_partition * fdi3250_nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(fdi3250_nand_partition);
+	return fdi3250_nand_partition;
+}
+struct lpc32XX_nand_cfg lpc32xx_nandcfg = {
+	.wdr_clks = 14,
+	.wwidth = 260000000,
+	.whold = 104000000,
+	.wsetup = 200000000,
+	.rdr_clks = 14,
+	.rwidth = 34666666,
+	.rhold = 104000000,
+	.rsetup = 200000000,
+	.use_bbt = true,
+	.polled_completion = false,
+	.enable_write_prot = nandwp_enable,
+	.partition_info = fdi3250_nand_partitions,
+};
+
+/*
+ *  * SLC NAND resources
+ *   */
+static struct resource slc_nand_resources[] = {
+	[0] = {
+		.start = LPC32XX_SLC_BASE,
+		.end = LPC32XX_SLC_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_FLASH,
+		.end = IRQ_LPC32XX_FLASH,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 lpc32xx_slc_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_slc_nand_device = {
+	.name = "lpc32xx-nand",
+	.id = 0,
+	.dev = {
+		.platform_data = &lpc32xx_nandcfg,
+		.dma_mask = &lpc32xx_slc_dma_mask,
+		.coherent_dma_mask = ~0UL,
+	},
+	.num_resources = ARRAY_SIZE(slc_nand_resources),
+	.resource = slc_nand_resources,
+};
+#endif
+
+/*
+ * Network Support
+ */
+static struct lpc_net_cfg lpc32xx_netdata =
+{
+	.phy_irq = -1,
+	.phy_mask = 0xFFFFFFF0,
+};
+
+static struct resource net_resources[] = {
+	[0] = {
+		.start = LPC32XX_ETHERNET_BASE,
+		.end = LPC32XX_ETHERNET_BASE + SZ_4K - 1,
+		.flags = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start = IRQ_LPC32XX_ETHERNET,
+		.end = IRQ_LPC32XX_ETHERNET,
+		.flags = IORESOURCE_IRQ,
+	},
+};
+
+static u64 lpc32xx_mac_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_net_device = {
+	.name = "lpc-net",
+	.id = 0,
+	.dev = {
+		.dma_mask = &lpc32xx_mac_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data  = &lpc32xx_netdata,
+	},
+	.num_resources = ARRAY_SIZE(net_resources),
+	.resource = net_resources,
+};
+
+static struct platform_device* fdi3250_devs[] __initdata = {
+	&lpc32xx_i2c0_device,
+	&lpc32xx_i2c1_device,
+	&lpc32xx_i2c2_device,
+	&lpc32xx_watchdog_device,
+	&lpc32xx_gpio_led_device,
+	&lpc32xx_rtc_device,
+	&lpc32xx_tsc_device,
+	&lpc32xx_net_device,
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+	&lpc32xx_slc_nand_device,
+#endif
+#if defined(CONFIG_USB_OHCI_HCD)
+	&lpc32xx_ohci_device,
+#endif
+#if defined(CONFIG_USB_GADGET_LPC32XX)
+	&lpc32xx_usbd_device,
+#endif
+	&lpc32xx_i2s_device,
+	&lpc32xx_asoc_plat_device,
+};
+
+/*
+ * Board specific functions
+ */
+void __init fdi3250_board_init(void)
+{
+	u32 tmp;
+
+	/* Intiliase GPIO */
+	lpc32xx_gpio_init();
+
+	/* Set SPI CS GPIO to output */
+	gpio_request(SPI_CS_GPIO, "spi0 cs");
+	gpio_direction_output(SPI_CS_GPIO, 1);
+
+	gpio_request(NAND_WP_GPIO, "NAND WP GPIO");
+	gpio_direction_input(NAND_WP_GPIO);
+
+	/* Setup network interface for RMII mode */
+	tmp = __raw_readl(LPC32XX_CLKPWR_MACCLK_CTRL);
+	tmp &= ~LPC32XX_CLKPWR_MACCTRL_PINS_MSK;
+	tmp |= LPC32XX_CLKPWR_MACCTRL_USE_RMII_PINS;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MACCLK_CTRL);
+
+	/* Setup SLC NAND controller */
+	__raw_writel(LPC32XX_CLKPWR_NANDCLK_SEL_SLC,
+			LPC32XX_CLKPWR_NAND_CLK_CTRL);
+
+	/* Setup LCD muxing to RGB565 */
+	tmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL) &
+		~(LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_MSK |
+				LPC32XX_CLKPWR_LCDCTRL_PSCALE_MSK);
+	tmp |= LPC32XX_CLKPWR_LCDCTRL_LCDTYPE_TFT16;
+	__raw_writel(tmp, LPC32XX_CLKPWR_LCDCLK_CTRL);
+
+	/* Set up I2C pull levels */
+	tmp = __raw_readl(LPC32XX_CLKPWR_I2C_CLK_CTRL);
+	tmp |= LPC32XX_CLKPWR_I2CCLK_USBI2CHI_DRIVE |
+		LPC32XX_CLKPWR_I2CCLK_I2C2HI_DRIVE;
+	__raw_writel(tmp, LPC32XX_CLKPWR_I2C_CLK_CTRL);
+
+	/* Initalise Serial device */
+	lpc32xx_serial_init();
+
+	/*
+	 * AMBA peripheral clocks need to be enabled prior to AMBA device
+	 * detection or a data fault will occur, so enable the clocks
+	 * here. However, we don't want to enable them if the peripheral
+	 * isn't included in the image
+	 */
+	/* Initialise SSP clock */
+	tmp = __raw_readl(LPC32XX_CLKPWR_SSP_CLK_CTRL);
+	__raw_writel((tmp | LPC32XX_CLKPWR_SSPCTRL_SSPCLK0_EN),
+			LPC32XX_CLKPWR_SSP_CLK_CTRL);
+
+	/* Initialise LCD clock */
+	tmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL);
+	__raw_writel((tmp | LPC32XX_CLKPWR_LCDCTRL_CLK_EN),
+			LPC32XX_CLKPWR_LCDCLK_CTRL);
+
+	/* Enable SD card clock so AMBA driver will work correctly. The
+	   AMBA driver needs the clock before the SD card controller
+	   driver initializes it. The clock will turn off once the driver
+	   has been initialized. */
+	tmp = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
+	tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_EN |
+		LPC32XX_CLKPWR_MSCARD_MSDIO_PU_EN;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MS_CTRL);
+
+	/* Disable UART5->USB transparent mode or USB won't work */
+	tmp = __raw_readl(LPC32XX_UARTCTL_CTRL);
+	tmp &= ~LPC32XX_UART_U5_ROUTE_TO_USB;
+	__raw_writel(tmp, LPC32XX_UARTCTL_CTRL);
+
+	/* Add platform devcies */
+	platform_add_devices(fdi3250_devs, ARRAY_SIZE(fdi3250_devs));
+}
+
+static int __init lpc32xx_display_uid(void)
+{
+	u32 uid[4];
+
+	lpc32xx_get_uid(uid);
+
+	printk(KERN_INFO "LPC32XX unique ID: %08x%08x%08x%08x\n",
+			uid[3], uid[2], uid[1], uid[0]);
+
+	return 1;
+}
+arch_initcall(lpc32xx_display_uid);
+
+MACHINE_START (FDI3250, "Future Designs board with the LPC3250 Microcontroller")
+	.boot_params	= 0x80000100,
+	.map_io		= lpc32xx_map_io,
+	.init_irq	= lpc32xx_init_irq,
+	.timer		= &lpc32xx_timer,
+	.init_machine	= fdi3250_board_init,
+	MACHINE_END
+
+/* For backwards compatibility with older bootloaders only */
+MACHINE_START (LPC3XXX, "Future Designs board with the LPC3250 Microcontroller")
+	.boot_params	= 0x80000100,
+	.map_io		= lpc32xx_map_io,
+	.init_irq	= lpc32xx_init_irq,
+	.timer		= &lpc32xx_timer,
+	.init_machine	= fdi3250_board_init,
+	MACHINE_END
+
diff --git a/arch/arm/mach-lpc32xx/include/mach/board.h b/arch/arm/mach-lpc32xx/include/mach/board.h
new file mode 100644
index 0000000..3049eaf
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/board.h
@@ -0,0 +1,86 @@
+/*
+ * arm/arch/mach-lpc32xx/include/mach/board.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+
+#ifndef __ASM_ARCH_BOARD_H
+#define __ASM_ARCH_BOARD_H
+
+#include "platform.h"
+#include <linux/mtd/partitions.h>
+#include <linux/serial_core.h>
+
+/*
+ * NAND platform configuration structure
+*/
+typedef int (*en_wp)(int);
+struct lpc32XX_nand_cfg
+{
+        u32             wdr_clks;
+        u32             wwidth;
+        u32             whold;
+        u32             wsetup;
+        u32             rdr_clks;
+        u32             rwidth;
+        u32             rhold;
+        u32             rsetup;
+	bool		use_bbt;
+	bool		polled_completion;
+        en_wp           enable_write_prot;
+        struct mtd_partition* (*partition_info)(int, int*);
+};
+
+/*
+ * Key scanner platform configuration structure
+ */
+struct lpc32XX_kscan_cfg {
+	u32	matrix_sz;	/* Size of matrix in XxY, ie. 3 = 3x3 */
+	int	*keymap;	/* Pointer to key map for the scan matrix */
+	u32	deb_clks;	/* Debounce clocks (based on 32KHz clock) */
+	u32	scan_delay;	/* Scan delay (based on 32KHz clock) */
+};
+
+/*
+ * Network configuration structure
+ */
+struct lpc_net_cfg {
+	int	phy_irq;	/* PHY IRQ number, or -1 for polling */
+	u32	phy_mask;	/* PHY mask value */
+};
+
+/*
+ * USB device configuration structure
+ */
+typedef void (*usc_chg_event)(int);
+struct lpc32xx_usbd_cfg
+{
+        int     vbus_drv_pol;   /* 0=active low drive for VBUS via ISP1301 */
+        usc_chg_event conn_chgb; /* Connection change event callback (optional) */
+        usc_chg_event susp_chgb; /* Suspend/resume event callback (optional) */
+        usc_chg_event rmwk_chgb; /* Enable/disable remote wakeup */
+};
+
+/*
+ * High Speed UART configuration structure
+ */
+struct lpc32xx_hsuart_port {
+	struct uart_port port;
+	unsigned int fbit_sam;
+};
+
+#endif	/* __ASM_ARCH_BOARD_H */
+
diff --git a/arch/arm/mach-lpc32xx/include/mach/debug-macro.S b/arch/arm/mach-lpc32xx/include/mach/debug-macro.S
index 351bd6c..cb68a28 100644
--- a/arch/arm/mach-lpc32xx/include/mach/debug-macro.S
+++ b/arch/arm/mach-lpc32xx/include/mach/debug-macro.S
@@ -20,6 +20,33 @@
  * Debug output is hardcoded to standard UART 5
 */
 
+#if defined(CONFIG_SERIAL_HS_LPC32XX_CONSOLE)
+               .macro  addruart,rp, rv
+               ldreq   \rp, =0x40014000        @ physical
+               ldrne   \rv, =0xF4014000        @ virtual
+1003:
+               .endm
+
+               .macro  senduart,rd,rx
+               str     \rd, [\rx, #0]
+               .endm
+
+               .macro  busyuart,rd,rx
+1002:          ldr     \rd, [\rx, #0x0]
+               ldr     \rd, [\rx, #0x4]
+               cmp     \rd, #0
+               bne     1002b
+               .endm
+
+               .macro  waituart,rd,rx
+1001:          ldr     \rd, [\rx, #0x0]
+               ldr     \rd, [\rx, #0x4]
+               cmp     \rd, #0
+               bne     1001b
+               .endm
+
+#else
+
 	.macro	addruart, rp, rv, tmp
 	ldreq	\rp, =0x40090000
 	ldrne	\rv, =0xF4090000
@@ -27,3 +54,5 @@
 
 #define UART_SHIFT	2
 #include <asm/hardware/debug-8250.S>
+#endif
+
diff --git a/arch/arm/mach-lpc32xx/include/mach/dma.h b/arch/arm/mach-lpc32xx/include/mach/dma.h
new file mode 100644
index 0000000..2bdec9f
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/dma.h
@@ -0,0 +1,116 @@
+/*
+ * asm-arm/arch-lpc32xx/dma.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_DMA_H
+#define __ASM_ARCH_DMA_H
+
+#include <mach/platform.h>
+
+#define MAX_DMA_CHANNELS 8
+
+#define DMA_CH_SDCARD_TX	0
+#define DMA_CH_SDCARD_RX	1
+#define DMA_CH_I2S_TX		2
+#define DMA_CH_I2S_RX		3
+#define DMA_CH_SLCNAND		4
+
+enum {
+	DMA_NO_INT = 0,
+	DMA_ERR_INT = 1,
+	DMA_TC_INT = 2,
+};
+
+/*
+ * DMA channel control structure
+ */
+struct dma_config {
+	int ch;		/* Channel # to use */
+	int tc_inten;	/* !0 = Enable TC interrupts for this channel */
+	int err_inten;	/* !0 = Enable error interrupts for this channel */
+	int src_size;	/* Source xfer size - must be 1, 2, or 4 */
+	int src_inc;	/* !0 = Enable source address increment */
+	int src_ahb1;	/* !0 = Use AHB1 for source transfer */
+	int src_bsize;	/* Source burst size (ie, DMAC_CHAN_SRC_BURST_xxx) */
+	u32 src_prph;	/* Source peripheral (ie, DMA_PERID_xxxx) */
+	int dst_size;	/* Destination xfer size - must be 1, 2, or 4 */
+	int dst_inc;	/* !0 = Enable destination address increment */
+	int dst_ahb1;	/* !0 = Use AHB1 for destination transfer */
+	int dst_bsize;	/* Destination burst size (ie, DMAC_CHAN_DEST_BURST_xxx) */
+	u32 dst_prph;	/* Destination peripheral (ie, DMA_PERID_xxxx) */
+	u32 flowctrl;	/* Flow control (ie, DMAC_CHAN_FLOW_xxxxxx) */
+};
+
+/*
+ * Channel enable and disable functions
+ */
+extern int lpc32xx_dma_ch_enable(int ch);
+extern int lpc32xx_dma_ch_disable(int ch);
+
+/*
+ * Channel allocation and deallocation functions
+ */
+extern int lpc32xx_dma_ch_get(struct dma_config *dmachcfg,
+				char *name,
+				void *irq_handler,
+				void *data);
+extern int lpc32xx_dma_ch_put(int ch);
+extern int lpc32xx_dma_ch_pause_unpause(int ch, int pause);
+
+/*
+ * Setup or start an unbound DMA transfer
+ */
+extern int lpc32xx_dma_start_pflow_xfer(int ch,
+					void *src,
+					void *dst,
+					int enable);
+
+/*
+ * DMA channel status
+ */
+extern int lpc32xx_dma_is_active(int ch);
+
+/*
+ * DMA linked list support
+ */
+extern u32 lpc32xx_dma_alloc_llist(int ch,
+				   int entries);
+extern void lpc32xx_dma_dealloc_llist(int ch);
+extern u32 lpc32xx_dma_llist_v_to_p(int ch,
+				    u32 vlist);
+extern u32 lpc32xx_dma_llist_p_to_v(int ch,
+				    u32 plist);
+extern u32 lpc32xx_dma_get_llist_head(int ch);
+extern void lpc32xx_dma_flush_llist(int ch);
+extern u32 lpc32xx_dma_queue_llist_entry(int ch,
+					 void *src,
+					 void *dst,
+					 int size);
+extern u32 lpc32xx_get_free_llist_entry(int ch);
+extern u32 lpc32xx_dma_queue_llist(int ch,
+				   void *src,
+				   void *dst,
+				   int size,
+				   u32 ctrl);
+extern int lpc32xx_dma_start_xfer(int chan, u32 config);
+extern void lpc32xx_dma_force_burst(int ch, int src);
+
+#endif /* _ASM_ARCH_DMA_H */
diff --git a/arch/arm/mach-lpc32xx/include/mach/dmac.h b/arch/arm/mach-lpc32xx/include/mach/dmac.h
new file mode 100644
index 0000000..e7d82a7
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/dmac.h
@@ -0,0 +1,285 @@
+/*
+ * asm-arm/arch-lpc32xx/dmac.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_DMAC_H
+#define __ASM_ARCH_DMAC_H
+
+/**********************************************************************
+* DMA register offsets
+**********************************************************************/
+
+/* DMA controller register structures */
+#define DMA_INT_STAT(x)			(x + 0x00)
+#define DMA_INT_TC_STAT(x)		(x + 0x04)
+#define DMA_INT_TC_CLEAR(x)		(x + 0x08)
+#define DMA_INT_ERR_STAT(x)		(x + 0x0C)
+#define DMA_INT_ERR_CLEAR(x)		(x + 0x10)
+#define DMA_RAW_TC_STAT(x)		(x + 0x14)
+#define DMA_RAW_ERR_STAT(x)		(x + 0x18)
+#define DMA_CH_ENABLE(x)		(x + 0x1C)
+#define DMA_SW_BURST_REQ(x)		(x + 0x20)
+#define DMA_SW_SINGLE_REQ(x)		(x + 0x24)
+#define DMA_SW_LAST_BURST_REQ(x)	(x + 0x28)
+#define DMA_SW_LAST_SINGLE_REQ(x)	(x + 0x2C)
+#define DMA_CONFIG(x)			(x + 0x30)
+#define DMA_SYNC(x)			(x + 0x34)
+
+/* DMA controller channel register structure */
+#define DMA_CH_OFFS(c)			((c * 0x20) + 0x100)
+#define DMACH_SRC_ADDR(x, c)		(x + DMA_CH_OFFS(c) + 0x00)
+#define DMACH_DEST_ADDR(x, c)		(x + DMA_CH_OFFS(c) + 0x04)
+#define DMACH_LLI(x, c)			(x + DMA_CH_OFFS(c) + 0x08)
+#define DMACH_CONTROL(x, c)		(x + DMA_CH_OFFS(c) + 0x0C)
+#define DMACH_CONFIG_CH(x, c)		(x + DMA_CH_OFFS(c) + 0x10)
+
+/* DMA linked list structure */
+#define DMA_LL_SRC(x)			(x + 0x0)
+#define DMA_LL_DEST(x)			(x + 0x4)
+#define DMA_LL_NEXT_LLI(x)		(x + 0x8)
+#define DMA_LL_NEXT_CTRL(x)		(x + 0xC)
+
+#define DMA_LL_SIZE 16
+
+/**********************************************************************
+* int_stat, int_tc_stat, int_tc_clear, int_err_stat, raw_tc_stat,
+* raw_err_stat, and chan_enable register definitions
+**********************************************************************/
+/* Macro for determining a bit position for a channel */
+#define DMAC_GET_CHAN_POS(chan)     (0x1 << ((chan) & 0x7))
+
+/**********************************************************************
+* sw_burst_req, sw_single_req, sw_last_burst_req, sw_last_single_req,
+* and sync register definitions
+**********************************************************************/
+/* Peripheral DMA bit position for I2S0 DMA0 */
+#define DMA_PER_I2S0_DMA0           _BIT(0)
+
+/* Peripheral DMA bit position for NAND FLASH (same as 12) */
+#define DMA_PER_NAND1               _BIT(1)
+
+/* Peripheral DMA bit position for I2S1 DMA0 */
+#define DMA_PER_I2S1_DMA0           _BIT(2)
+
+/* Peripheral DMA bit position for SPI2 (RX and TX) */
+#define DMA_PER_SPI2_TXRX           _BIT(3)
+
+/* Peripheral DMA bit position for SSP1 (RX) */
+#define DMA_PER_SSP1_RX             _BIT(3)
+
+/* Peripheral DMA bit position for SD card */
+#define DMA_PER_SDCARD              _BIT(4)
+
+/* Peripheral DMA bit position for HSUART1 TX */
+#define DMA_PER_HSUART1_TX          _BIT(5)
+
+/* Peripheral DMA bit position for HSUART1 RX */
+#define DMA_PER_HSUART1_RX          _BIT(6)
+
+/* Peripheral DMA bit position for HSUART2 TX */
+#define DMA_PER_HSUART2_TX          _BIT(7)
+
+/* Peripheral DMA bit position for HSUART2 RX */
+#define DMA_PER_HSUART2_RX          _BIT(8)
+
+/* Peripheral DMA bit position for HSUART7 TX */
+#define DMA_PER_HSUART7_TX          _BIT(9)
+
+/* Peripheral DMA bit position for HSUART7 RX */
+#define DMA_PER_HSUART7_RX          _BIT(10)
+
+/* Peripheral DMA bit position for I2S1 DMA1 */
+#define DMA_PER_I2S1_DMA1           _BIT(10)
+
+/* Peripheral DMA bit position for SPI1 (RX and TX) */
+#define DMA_PER_SPI1_TXRX           _BIT(11)
+
+/* Peripheral DMA bit position for SSP1 (TX) */
+#define DMA_PER_SSP1_TX             _BIT(11)
+
+/* Peripheral DMA bit position for NAND FLASH (same as 1) */
+#define DMA_PER_NAND2               _BIT(12)
+
+/* Peripheral DMA bit position for I2S0 DMA1 */
+#define DMA_PER_I2S0_DMA1           _BIT(13)
+
+/* Peripheral DMA bit position for SSP0 (RX) */
+#define DMA_PER_SSP0_RX             _BIT(14)
+
+/* Peripheral DMA bit position for SSP0 (TX) */
+#define DMA_PER_SSP0_TX             _BIT(15)
+
+/**********************************************************************
+* config register definitions
+**********************************************************************/
+/* Bit for enabling big endian mode on AHB 1 */
+#define DMAC_BIG_ENDIAN_AHB1        _BIT(2)
+
+/* Bit for enabling big endian mode on AHB 0 */
+#define DMAC_BIG_ENDIAN_AHB0        _BIT(1)
+
+/* Bit for enabling the DMA controller */
+#define DMAC_CTRL_ENABLE            _BIT(0)
+
+/**********************************************************************
+* lli register definitions
+**********************************************************************/
+/* Bit for selecting AHB0 (0) or AHB1 (1) */
+#define DMAC_CHAN_LLI_SEL_AHB1      _BIT(0)
+
+/**********************************************************************
+* control register definitions
+**********************************************************************/
+/* Bit for enabling a channel terminal count interrupt */
+#define DMAC_CHAN_INT_TC_EN         _BIT(31)
+
+/* Bit for indicating address is cacheable */
+#define DMAC_CHAN_PROT3             _BIT(30)
+
+/* Bit for indicating address is bufferable */
+#define DMAC_CHAN_PROT2             _BIT(29)
+
+/* Bit for indicating address is privelaged mode (1) or user
+   mode (0) */
+#define DMAC_CHAN_PROT1             _BIT(28)
+
+/* Bit for enabling automatic destination increment */
+#define DMAC_CHAN_DEST_AUTOINC      _BIT(27)
+
+/* Bit for enabling automatic source increment */
+#define DMAC_CHAN_SRC_AUTOINC       _BIT(26)
+
+/* Bit for using AHB1 master for destination transfer */
+#define DMAC_CHAN_DEST_AHB1         _BIT(25)
+
+/* Bit for using AHB1 master for source transfer */
+#define DMAC_CHAN_SRC_AHB1          _BIT(24)
+
+/* Destination data width selection defines */
+#define DMAC_CHAN_DEST_WIDTH_8      0x0
+#define DMAC_CHAN_DEST_WIDTH_16     _BIT(21)
+#define DMAC_CHAN_DEST_WIDTH_32     _BIT(22)
+
+/* Source data width selection defines */
+#define DMAC_CHAN_SRC_WIDTH_8       0x0
+#define DMAC_CHAN_SRC_WIDTH_16      _BIT(18)
+#define DMAC_CHAN_SRC_WIDTH_32      _BIT(19)
+
+/* Destination data burst size defines (in transfer width) */
+#define DMAC_CHAN_DEST_BURST_1      0
+#define DMAC_CHAN_DEST_BURST_4      _BIT(15)
+#define DMAC_CHAN_DEST_BURST_8      _BIT(16)
+#define DMAC_CHAN_DEST_BURST_16     (_BIT(16) | _BIT(15))
+#define DMAC_CHAN_DEST_BURST_32     _BIT(17)
+#define DMAC_CHAN_DEST_BURST_64     (_BIT(17) | _BIT(15))
+#define DMAC_CHAN_DEST_BURST_128    (_BIT(17) | _BIT(16))
+#define DMAC_CHAN_DEST_BURST_256    (_BIT(17) | _BIT(16) | _BIT(15))
+
+/* Macro for direct loading of destination burst size field */
+#define DMAC_CHAN_DEST_BURST_LOAD(n) (((n) & 0x7) << 15)
+
+/* Source data burst size defines (in transfer width) */
+#define DMAC_CHAN_SRC_BURST_1       0
+#define DMAC_CHAN_SRC_BURST_4       _BIT(12)
+#define DMAC_CHAN_SRC_BURST_8       _BIT(13)
+#define DMAC_CHAN_SRC_BURST_16      (_BIT(13) | _BIT(12))
+#define DMAC_CHAN_SRC_BURST_32      _BIT(14)
+#define DMAC_CHAN_SRC_BURST_64      (_BIT(14) | _BIT(12))
+#define DMAC_CHAN_SRC_BURST_128     (_BIT(14) | _BIT(13))
+#define DMAC_CHAN_SRC_BURST_256     (_BIT(14) | _BIT(13) | _BIT(12))
+
+/* Macro for direct loading of source burst size field */
+#define DMAC_CHAN_SRC_BURST_LOAD(n) (((n) & 0x7) << 12)
+
+/* Macro for loading transfer size */
+#define DMAC_CHAN_TRANSFER_SIZE(n)  ((n) & 0xFFF)
+
+/**********************************************************************
+* config_ch register definitions
+**********************************************************************/
+/* Bit for halting a DMA transfer */
+#define DMAC_CHAN_HALT              _BIT(18)
+
+/* Bit for checking active status of the DMA channel */
+#define DMAC_CHAN_ACTIVE            _BIT(17)
+
+/* Bit for enabling locked transfers */
+#define DMAC_CHAN_LOCK              _BIT(16)
+
+/* Terminal count interrupt mask bit */
+#define DMAC_CHAN_ITC               _BIT(15)
+
+/* Interrupt error mask bit */
+#define DMAC_CHAN_IE                _BIT(14)
+
+/* Defines for flow control with DMA as the controller */
+#define DMAC_CHAN_FLOW_D_M2M        (0x0 << 11)
+#define DMAC_CHAN_FLOW_D_M2P        (0x1 << 11)
+#define DMAC_CHAN_FLOW_D_P2M        (0x2 << 11)
+#define DMAC_CHAN_FLOW_D_SP2DP      (0x3 << 11)
+
+/* Defines for flow control with destination peripheral as the
+   controller */
+#define DMAC_CHAN_FLOW_DP_SP2DP     (0x4 << 11)
+
+/* Defines for flow control with peripheral as the controller */
+#define DMAC_CHAN_FLOW_P_M2P        (0x5 << 11)
+#define DMAC_CHAN_FLOW_P_P2M        (0x6 << 11)
+
+/* Defines for flow control with source peripheral as the
+   controller */
+#define DMAC_CHAN_FLOW_SP_SP2DP     (0x7 << 11)
+
+/* Macro for loading destination peripheral */
+#define DMAC_DEST_PERIP(n)          (((n) & 0x1F) << 6)
+
+/* Macro for loading source peripheral */
+#define DMAC_SRC_PERIP(n)           (((n) & 0x1F) << 1)
+
+/* Channel enable bit */
+#define DMAC_CHAN_ENABLE            _BIT(0)
+
+/**********************************************************************
+* config_ch register definitions (source and destination
+* peripheral ID numbers). These can be used with the DMAC_DEST_PERIP
+* and DMAC_SRC_PERIP macros.
+**********************************************************************/
+#define DMA_PERID_I2S0_DMA0         0
+#define DMA_PERID_NAND1             1
+#define DMA_PERID_I2S1_DMA0         2
+#define DMA_PERID_SPI2_TXRX         3
+#define DMA_PERID_SSP1_RX           3
+#define DMA_PERID_SDCARD            4
+#define DMA_PERID_HSUART1_TX        5
+#define DMA_PERID_HSUART1_RX        6
+#define DMA_PERID_HSUART2_TX        7
+#define DMA_PERID_HSUART2_RX        8
+#define DMA_PERID_HSUART7_TX        9
+#define DMA_PERID_HSUART7_RX        10
+#define DMA_PERID_I2S1_DMA1         10
+#define DMA_PERID_SPI1_TXRX         11
+#define DMA_PERID_SSP1_TX           11
+#define DMA_PERID_NAND2             12
+#define DMA_PERID_I2S0_DMA1         13
+#define DMA_PERID_SSP0_RX           14
+#define DMA_PERID_SSP0_TX           15
+
+#endif /* __ASM_ARCH_DMAC_H */
diff --git a/arch/arm/mach-lpc32xx/include/mach/gpio.h b/arch/arm/mach-lpc32xx/include/mach/gpio.h
index 40a8c17..0c18c51 100644
--- a/arch/arm/mach-lpc32xx/include/mach/gpio.h
+++ b/arch/arm/mach-lpc32xx/include/mach/gpio.h
@@ -1 +1,74 @@
-/* empty */
+/*
+ * arch/arm/mach-lpc32xx/include/mach/gpio.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ASM_ARCH_GPIO_H
+#define __ASM_ARCH_GPIO_H
+
+#include <asm-generic/gpio.h>
+
+/*
+ * Note!
+ * Muxed GP pins need to be setup to the GP state in the board level
+ * code prior to using this driver.
+ * GPI pins : 28xP3 group
+ * GPO pins : 24xP3 group
+ * GPIO pins: 8xP0 group, 24xP1 group, 13xP2 group, 6xP3 group
+ */
+
+#define LPC32XX_GPIO_P0_MAX 8
+#define LPC32XX_GPIO_P1_MAX 24
+#define LPC32XX_GPIO_P2_MAX 13
+#define LPC32XX_GPIO_P3_MAX 6
+#define LPC32XX_GPI_P3_MAX 28
+#define LPC32XX_GPO_P3_MAX 24
+
+#define LPC32XX_GPIO_P0_GRP 0
+#define LPC32XX_GPIO_P1_GRP (LPC32XX_GPIO_P0_GRP + LPC32XX_GPIO_P0_MAX)
+#define LPC32XX_GPIO_P2_GRP (LPC32XX_GPIO_P1_GRP + LPC32XX_GPIO_P1_MAX)
+#define LPC32XX_GPIO_P3_GRP (LPC32XX_GPIO_P2_GRP + LPC32XX_GPIO_P2_MAX)
+#define LPC32XX_GPI_P3_GRP (LPC32XX_GPIO_P3_GRP + LPC32XX_GPIO_P3_MAX)
+#define LPC32XX_GPO_P3_GRP (LPC32XX_GPI_P3_GRP + LPC32XX_GPI_P3_MAX)
+
+/*
+ * A specific GPIO can be selected with this macro
+ * ie, GPIO_05 can be selected with LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 5)
+ * See the LPC32x0 User's guide for GPIO group numbers
+ */
+#define LPC32XX_GPIO(x, y) ((x) + (y))
+
+static inline int gpio_get_value(unsigned gpio)
+{
+	return __gpio_get_value(gpio);
+}
+
+static inline void gpio_set_value(unsigned gpio, int value)
+{
+	__gpio_set_value(gpio, value);
+}
+
+static inline int gpio_cansleep(unsigned gpio)
+{
+	return __gpio_cansleep(gpio);
+}
+
+static inline int gpio_to_irq(unsigned gpio)
+{
+	return __gpio_to_irq(gpio);
+}
+
+#endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/i2s.h b/arch/arm/mach-lpc32xx/include/mach/i2s.h
new file mode 100644
index 0000000..63ec790
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/i2s.h
@@ -0,0 +1,156 @@
+/*
+ * asm-arm/arch-lpc32xx/i2c.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef  __ASM_ARCH_I2S_H
+#define  __ASM_ARCH_I2S_H
+
+/**********************************************************************
+* I2S controller register offsets
+**********************************************************************/
+
+#define I2S_DAO(x)			(x + 0x00)
+#define I2S_DAI(x)			(x + 0x04)
+#define I2S_TX_FIFO(x)			(x + 0x08)
+#define I2S_RX_FIFO(x)			(x + 0x0C)
+#define I2S_STAT(x)			(x + 0x10)
+#define I2S_DMA0(x)			(x + 0x14)
+#define I2S_DMA1(x)			(x + 0x18)
+#define I2S_IRQ(x)			(x + 0x1C)
+#define I2S_TX_RATE(x)			(x + 0x20)
+#define I2S_RX_RATE(x)			(x + 0x24)
+
+/**********************************************************************
+* i2s_daO i2s_dai register definitions
+**********************************************************************/
+#define I2S_WW8      _SBF(0,0) /* Word width is 8bit*/
+#define I2S_WW16     _SBF(0,1) /* Word width is 16bit*/
+#define I2S_WW32     _SBF(0,3) /* Word width is 32bit*/
+#define I2S_MONO     _BIT(2)   /* Mono */
+#define I2S_STOP     _BIT(3)   /* Stop, diables the access to FIFO, 
+                                  mutes the channel */
+#define I2S_RESET    _BIT(4)   /* Reset the channel */
+#define I2S_WS_SEL   _BIT(5)   /* Channel Master(0) or slave(1) 
+                                  mode select*/
+#define I2S_WS_HP(s) _SBF(6,s) /* Word select half period - 1 */
+
+#define I2S_MUTE     _BIT(15)  /* Mute the channel, 
+                                  Transmit channel only */
+
+#define I2S_WW32_HP  0x1f /* Word select half period for 32bit 
+                             word width */
+#define I2S_WW16_HP  0x0f /* Word select half period for 16bit 
+                             word width */
+#define I2S_WW8_HP   0x7  /* Word select half period for 8bit
+                             word width */
+
+#define WSMASK_HP	  0X7FC /* Mask for WS half period bits */
+
+/**********************************************************************
+* i2s_tx_fifo register definitions
+**********************************************************************/
+#define I2S_FIFO_TX_WRITE(d)              (d)
+
+/**********************************************************************
+* i2s_rx_fifo register definitions
+**********************************************************************/
+#define I2S_FIFO_RX_WRITE(d)              (d)
+
+/**********************************************************************
+* i2s_stat register definitions
+**********************************************************************/
+#define I2S_IRQ_STAT     _BIT(0)
+#define I2S_DMA0_REQ     _BIT(1)
+#define I2S_DMA1_REQ     _BIT(2)
+
+#define I2S_RX_STATE_MASK	0x0000ff00
+#define I2S_TX_STATE_MASK	0x00ff0000
+
+/**********************************************************************
+* i2s_dma0 Configuration register definitions
+**********************************************************************/
+#define I2S_DMA0_RX_EN     _BIT(0)       /* Enable RX DMA1*/
+#define I2S_DMA0_TX_EN     _BIT(1)       /* Enable TX DMA1*/
+#define I2S_DMA0_RX_DEPTH(s)  _SBF(8,s)  /* Set the level for DMA1 
+                                            RX Request */
+#define I2S_DMA0_TX_DEPTH(s)  _SBF(16,s) /* Set the level for DMA1 
+                                            TX Request */
+
+/**********************************************************************
+* i2s_dma1 Configuration register definitions
+**********************************************************************/
+#define I2S_DMA1_RX_EN     _BIT(0)       /* Enable RX DMA1*/
+#define I2S_DMA1_TX_EN     _BIT(1)       /* Enable TX DMA1*/
+#define I2S_DMA1_RX_DEPTH(s)  _SBF(8,s)	 /* Set the level for DMA1 
+                                            RX Request */
+#define I2S_DMA1_TX_DEPTH(s)  _SBF(16,s) /* Set the level for DMA1 
+                                            TX Request */
+
+/**********************************************************************
+* i2s_irq register definitions
+**********************************************************************/
+#define I2S_RX_IRQ_EN     _BIT(0)       /* Enable RX IRQ*/
+#define I2S_TX_IRQ_EN     _BIT(1)       /* Enable TX IRQ*/
+#define I2S_IRQ_RX_DEPTH(s)  _SBF(8,s)  /* valid values ar 0 to 7 */
+#define I2S_IRQ_TX_DEPTH(s)  _SBF(16,s) /* valid values ar 0 to 7 */
+
+/**********************************************************************
+* define audio rates for i2s_tx_rate/i2s_rx_rate register definitions
+**********************************************************************/
+
+#define A96KHZ104MHZ8BIT 0x7ed  // 7, 237
+#define A48KHZ104MHZ8BIT 0x3cb  // 3, 203
+#define A44KHZ104MHZ8BIT 0x14a  // 1, 74
+#define A32KHZ104MHZ8BIT 0x5fe	// 5, 254
+#define A22KHZ104MHZ8BIT 0x194  // 1, 148
+#define A16KHZ104MHZ8BIT 0x1cb	// 1, 203
+
+#define A96KHZ104MHZ16BIT 0xeed	//  14, 237
+#define A48KHZ104MHZ16BIT 0x7ED //  7, 237
+#define A44KHZ104MHZ16BIT 0x6dd //  6, 221	
+#define A32KHZ104MHZ16BIT 0x5fe //  5, 254
+#define A22KHZ104MHZ16BIT 0x14a //  1, 74
+#define A16KHZ104MHZ16BIT 0x2cb //  2, 203
+
+#define A96KHZ104MHZ32BIT 0x1ced// 28, 237
+#define A48KHZ104MHZ32BIT 0xeed // 14, 237 
+#define A44KHZ104MHZ32BIT 0xdf0 // 13, 240 
+#define A32KHZ104MHZ32BIT 0x57f	// 5, 127
+#define A22KHZ104MHZ32BIT 0x125 // 1, 37 
+#define A16KHZ104MHZ32BIT 0x5fe // 5, 254 
+
+/**********************************************************************
+* i2s_tx_rate register definitions
+**********************************************************************/
+#define I2S_SET_TX_RATE(d)          (d)
+
+/**********************************************************************
+* i2s_rx_rate register definitions
+**********************************************************************/
+#define I2S_SET_RX_RATE(d)          (d)
+
+/**********************************************************************
+* i2s channel select
+**********************************************************************/
+#define I2S_CH0	0
+#define I2S_CH1	1
+
+#endif /*  __ASM_ARCH_I2S_H */
diff --git a/arch/arm/mach-lpc32xx/include/mach/irqs.h b/arch/arm/mach-lpc32xx/include/mach/irqs.h
index 9e3b90d..19fec8d 100644
--- a/arch/arm/mach-lpc32xx/include/mach/irqs.h
+++ b/arch/arm/mach-lpc32xx/include/mach/irqs.h
@@ -23,6 +23,22 @@
 #define LPC32XX_SIC2_IRQ(n)		(64 + (n))
 
 /*
+ * Default value representing the Activation polarity of all internal
+ * interrupt sources
+ */
+#define MIC_APR_DEFAULT		0x3FF0EFE0
+#define SIC1_APR_DEFAULT	0xFBD27186
+#define SIC2_APR_DEFAULT	0x801810C0
+
+/*
+ * Default value representing the Activation Type of all internal
+ * interrupt sources. All are level sensitive.
+ */
+#define MIC_ATR_DEFAULT		0x00000000
+#define SIC1_ATR_DEFAULT	0x00026000
+#define SIC2_ATR_DEFAULT	0x00000000
+
+/*
  * MIC interrupts
  */
 #define IRQ_LPC32XX_SUB1IRQ		0
@@ -113,5 +129,6 @@
 #define IRQ_LPC32XX_SYSCLK		LPC32XX_SIC2_IRQ(31)
 
 #define NR_IRQS				96
+#define NR_IRQ_CTRLS	3
 
 #endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/platform.h b/arch/arm/mach-lpc32xx/include/mach/platform.h
index 14ea8d1..a2bff7b 100644
--- a/arch/arm/mach-lpc32xx/include/mach/platform.h
+++ b/arch/arm/mach-lpc32xx/include/mach/platform.h
@@ -253,6 +253,8 @@
 #define LPC32XX_CLKPWR_INTSRC_GPIO_02_BIT	_BIT(2)
 #define LPC32XX_CLKPWR_INTSRC_GPIO_01_BIT	_BIT(1)
 #define LPC32XX_CLKPWR_INTSRC_GPIO_00_BIT	_BIT(0)
+/* Reserved bits */
+#define LPC32XX_CLKPWR_INTSRC_MASK		~(0x1806FF00)
 
 /*
  * clkpwr_start_pin, clkpwr_start_raw_sts_pin, clkpwr_start_sts_pin,
@@ -281,8 +283,11 @@
 #define LPC32XX_CLKPWR_EXTSRC_GPI_07_BIT	_BIT(7)
 #define LPC32XX_CLKPWR_EXTSRC_SPI2_DATIN_BIT	_BIT(6)
 #define LPC32XX_CLKPWR_EXTSRC_GPI_19_BIT	_BIT(5)
+#define LPC32XX_CLKPWR_EXTSRC_U4_RX_BIT		 _BIT(5)
 #define LPC32XX_CLKPWR_EXTSRC_GPI_09_BIT	_BIT(4)
 #define LPC32XX_CLKPWR_EXTSRC_GPI_08_BIT	_BIT(3)
+/* Reserved bits */
+#define LPC32XX_CLKPWR_EXTSRC_MASK		~(0x28180007)
 
 /*
  * clkpwr_hclk_div register definitions
@@ -591,42 +596,42 @@
 /*
  * Timer/counter register offsets
  */
-#define LCP32XX_TIMER_IR(x)			io_p2v((x) + 0x00)
-#define LCP32XX_TIMER_TCR(x)			io_p2v((x) + 0x04)
-#define LCP32XX_TIMER_TC(x)			io_p2v((x) + 0x08)
-#define LCP32XX_TIMER_PR(x)			io_p2v((x) + 0x0C)
-#define LCP32XX_TIMER_PC(x)			io_p2v((x) + 0x10)
-#define LCP32XX_TIMER_MCR(x)			io_p2v((x) + 0x14)
-#define LCP32XX_TIMER_MR0(x)			io_p2v((x) + 0x18)
-#define LCP32XX_TIMER_MR1(x)			io_p2v((x) + 0x1C)
-#define LCP32XX_TIMER_MR2(x)			io_p2v((x) + 0x20)
-#define LCP32XX_TIMER_MR3(x)			io_p2v((x) + 0x24)
-#define LCP32XX_TIMER_CCR(x)			io_p2v((x) + 0x28)
-#define LCP32XX_TIMER_CR0(x)			io_p2v((x) + 0x2C)
-#define LCP32XX_TIMER_CR1(x)			io_p2v((x) + 0x30)
-#define LCP32XX_TIMER_CR2(x)			io_p2v((x) + 0x34)
-#define LCP32XX_TIMER_CR3(x)			io_p2v((x) + 0x38)
-#define LCP32XX_TIMER_EMR(x)			io_p2v((x) + 0x3C)
-#define LCP32XX_TIMER_CTCR(x)			io_p2v((x) + 0x70)
+#define LPC32XX_TIMER_IR(x)			io_p2v((x) + 0x00)
+#define LPC32XX_TIMER_TCR(x)			io_p2v((x) + 0x04)
+#define LPC32XX_TIMER_TC(x)			io_p2v((x) + 0x08)
+#define LPC32XX_TIMER_PR(x)			io_p2v((x) + 0x0C)
+#define LPC32XX_TIMER_PC(x)			io_p2v((x) + 0x10)
+#define LPC32XX_TIMER_MCR(x)			io_p2v((x) + 0x14)
+#define LPC32XX_TIMER_MR0(x)			io_p2v((x) + 0x18)
+#define LPC32XX_TIMER_MR1(x)			io_p2v((x) + 0x1C)
+#define LPC32XX_TIMER_MR2(x)			io_p2v((x) + 0x20)
+#define LPC32XX_TIMER_MR3(x)			io_p2v((x) + 0x24)
+#define LPC32XX_TIMER_CCR(x)			io_p2v((x) + 0x28)
+#define LPC32XX_TIMER_CR0(x)			io_p2v((x) + 0x2C)
+#define LPC32XX_TIMER_CR1(x)			io_p2v((x) + 0x30)
+#define LPC32XX_TIMER_CR2(x)			io_p2v((x) + 0x34)
+#define LPC32XX_TIMER_CR3(x)			io_p2v((x) + 0x38)
+#define LPC32XX_TIMER_EMR(x)			io_p2v((x) + 0x3C)
+#define LPC32XX_TIMER_CTCR(x)			io_p2v((x) + 0x70)
 
 /*
  * ir register definitions
  */
-#define LCP32XX_TIMER_CNTR_MTCH_BIT(n)		(1 << ((n) & 0x3))
-#define LCP32XX_TIMER_CNTR_CAPT_BIT(n)		(1 << (4 + ((n) & 0x3)))
+#define LPC32XX_TIMER_CNTR_MTCH_BIT(n)		(1 << ((n) & 0x3))
+#define LPC32XX_TIMER_CNTR_CAPT_BIT(n)		(1 << (4 + ((n) & 0x3)))
 
 /*
  * tcr register definitions
  */
-#define LCP32XX_TIMER_CNTR_TCR_EN		0x1
-#define LCP32XX_TIMER_CNTR_TCR_RESET		0x2
+#define LPC32XX_TIMER_CNTR_TCR_EN		0x1
+#define LPC32XX_TIMER_CNTR_TCR_RESET		0x2
 
 /*
  * mcr register definitions
  */
-#define LCP32XX_TIMER_CNTR_MCR_MTCH(n)		(0x1 << ((n) * 3))
-#define LCP32XX_TIMER_CNTR_MCR_RESET(n)		(0x1 << (((n) * 3) + 1))
-#define LCP32XX_TIMER_CNTR_MCR_STOP(n)		(0x1 << (((n) * 3) + 2))
+#define LPC32XX_TIMER_CNTR_MCR_MTCH(n)		(0x1 << ((n) * 3))
+#define LPC32XX_TIMER_CNTR_MCR_RESET(n)		(0x1 << (((n) * 3) + 1))
+#define LPC32XX_TIMER_CNTR_MCR_STOP(n)		(0x1 << (((n) * 3) + 2))
 
 /*
  * Standard UART register offsets
@@ -690,5 +695,8 @@
 #define LPC32XX_GPIO_P1_MUX_SET			_GPREG(0x130)
 #define LPC32XX_GPIO_P1_MUX_CLR			_GPREG(0x134)
 #define LPC32XX_GPIO_P1_MUX_STATE		_GPREG(0x138)
+#define LPC32XX_GPIO_P2_MUX_SET			_GPREG(0x028)
+#define LPC32XX_GPIO_P2_MUX_CLR			_GPREG(0x02C)
+#define LPC32XX_GPIO_P2_MUX_STATE		_GPREG(0x030)
 
 #endif
diff --git a/arch/arm/mach-lpc32xx/include/mach/sdcard.h b/arch/arm/mach-lpc32xx/include/mach/sdcard.h
new file mode 100644
index 0000000..cc4a6af
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/sdcard.h
@@ -0,0 +1,177 @@
+/*
+ * asm-arm/arch-lpc32xx/sdcard.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SDCARD_H
+#define __ASM_ARCH_SDCARD_H
+
+/**********************************************************************
+* SD Card controller register offsets
+**********************************************************************/
+
+#define SD_POWER(x)			(x + 0x00)
+#define SD_CLOCK(x)			(x + 0x04)
+#define SD_ARG(x)			(x + 0x08)
+#define SD_CMD(x)			(x + 0x10)
+#define SD_RESPCMD(x)			(x + 0x14)
+#define SD_RESP(x)			(x + 0x18)
+#define SD_DTIMER(x)			(x + 0x28)
+#define SD_DLEN(x)			(x + 0x2C)
+#define SD_DCTRL(x)			(x + 0x30)
+#define SD_DCNT(x)			(x + 0x34)
+#define SD_STATUS(x)			(x + 0x38)
+#define SD_CLEAR(x)			(x + 0x3C)
+#define SD_MASK0(x)			(x + 0x40)
+#define SD_MASK1(x)			(x + 0x44)
+#define SD_FIFOCNT(x)			(x + 0x4C)
+#define SD_FIFO(x)			(x + 0x80)
+
+/**********************************************************************
+* sd_power register definitions
+**********************************************************************/
+/* SD bit for enabling open drain mode (1) or pushpull mode (0) */
+#define SD_OPENDRAIN_EN            _BIT(6)
+/* SD power control mode: power off */
+#define SD_POWER_OFF_MODE          0x0
+/* SD power control mode: power up */
+#define SD_POWER_UP_MODE           0x2
+/* SD power control mode: power on */
+#define SD_POWER_ON_MODE           0x3
+/* SD power control mode mask */
+#define SD_POWER_MODE_MASK         0x3
+
+/**********************************************************************
+* sd_clock register definitions
+**********************************************************************/
+/* SD bit for enabling side bus mode */
+#define SD_WIDEBUSMODE_EN          _BIT(11)
+/* SD bit for enabling SDCLK clock bypass */
+#define SD_SDCLK_BYPASS            _BIT(10)
+/* SD bit for enabling clock throttling during idle states */
+#define SD_SDCLK_PWRSAVE           _BIT(9)
+/* SD bit for enabling the SD clock */
+#define SD_SDCLK_EN                _BIT(8)
+/* SD clock divider bit mask */
+#define SD_CLKDIV_MASK             0xFF
+
+/**********************************************************************
+* sd_cmd register definitions
+**********************************************************************/
+/* SD bit for enabling command path state machine */
+#define SD_CPST_EN                 _BIT(10)
+/* SD bit for wait for CMDPEND prior to sending command */
+#define SD_CMDPEND_WAIT            _BIT(9)
+/* SD bit for enabling card interrupt request (without timeout) */
+#define SD_INTERRUPT_EN            _BIT(8)
+/* SD bit for enabling 136-bit response support */
+#define SD_LONGRESP_EN             _BIT(7)
+/* SD bit for enabling response support */
+#define SD_RESPONSE                _BIT(6)
+/* SD command mask */
+#define SD_CMD_MASK                0x3F
+
+/**********************************************************************
+* sd_dctrl register definitions
+**********************************************************************/
+/* SD data transfer blocksize of 1 byte */
+#define SD_BLKSIZE_1BYTE           0x00
+/* SD data transfer blocksize of 2 bytes */
+#define SD_BLKSIZE_2BYTES          0x10
+/* SD data transfer blocksize of 4 bytes */
+#define SD_BLKSIZE_4BYTES          0x20
+/* SD data transfer blocksize of 8 bytes */
+#define SD_BLKSIZE_8BYTES          0x30
+/* SD data transfer blocksize of 16 bytes */
+#define SD_BLKSIZE_16BYTES         0x40
+/* SD data transfer blocksize of 32 bytes */
+#define SD_BLKSIZE_32BYTES         0x50
+/* SD data transfer blocksize of 64 bytes */
+#define SD_BLKSIZE_64BYTES         0x60
+/* SD data transfer blocksize of 128 bytes */
+#define SD_BLKSIZE_128BYTES        0x70
+/* SD data transfer blocksize of 256 bytes */
+#define SD_BLKSIZE_256BYTES        0x80
+/* SD data transfer blocksize of 512 bytes */
+#define SD_BLKSIZE_512BYTES        0x90
+/* SD data transfer blocksize of 1024 bytes */
+#define SD_BLKSIZE_1024BYTES       0xA0
+/* SD data transfer blocksize of 2048 bytes */
+#define SD_BLKSIZE_2048BYTES       0xB0
+/* SD bit for enabling DMA */
+#define SD_DMA_EN                  _BIT(3)
+/* SD bit for enabling a stream transfer */
+#define SD_STREAM_EN               _BIT(2)
+/* SD direction bit (1 = receive, 0 = transmit) */
+#define SD_DIR_FROMCARD            _BIT(1)
+/* SD data transfer enable bit */
+#define SD_DATATRANSFER_EN         _BIT(0)
+
+/**********************************************************************
+* sd_status register definitions
+* sd_clear register definitions (bits 0..10 only)
+* sd_mask0, sd_mask1 register definitions
+**********************************************************************/
+/* SD bit for data receive FIFO NOT empty status */
+#define SD_FIFO_RXDATA_AVAIL       _BIT(21)
+/* SD bit for data transmit FIFO NOT empty status */
+#define SD_FIFO_TXDATA_AVAIL       _BIT(20)
+/* SD bit for data receive FIFO empty status */
+#define SD_FIFO_RXDATA_EMPTY       _BIT(19)
+/* SD bit for data transmit FIFO empty status */
+#define SD_FIFO_TXDATA_EMPTY       _BIT(18)
+/* SD bit for data receive FIFO full status */
+#define SD_FIFO_RXDATA_FULL        _BIT(17)
+/* SD bit for data transmit FIFO full status */
+#define SD_FIFO_TXDATA_FULL        _BIT(16)
+/* SD bit for data receive FIFO half-full status */
+#define SD_FIFO_RXDATA_HFULL       _BIT(15)
+/* SD bit for data transmit FIFO half-empty status */
+#define SD_FIFO_TXDATA_HEMPTY      _BIT(14)
+/* SD bit for data receive in progress status */
+#define SD_RX_INPROGRESS           _BIT(13)
+/* SD bit for data transmit in progress status */
+#define SD_TX_INPROGRESS           _BIT(12)
+/* SD bit for command transfer in progress status */
+#define SD_CMD_INPROGRESS          _BIT(11)
+/* SD bit for data block send/received complete (CRC good) status */
+#define SD_DATABLK_END             _BIT(10)
+/* SD bit for start bit detection error status */
+#define SD_STARTBIT_ERR            _BIT(9)
+/* SD bit for data end (data counter is 0) status */
+#define SD_DATA_END                _BIT(8)
+/* SD bit for command sent status */
+#define SD_CMD_SENT                _BIT(7)
+/* SD bit for command response received (CRC good) status */
+#define SD_CMD_RESP_RECEIVED       _BIT(6)
+/* SD bit for data receive FIFO overflow status */
+#define SD_FIFO_RXDATA_OFLOW       _BIT(5)
+/* SD bit for data transmit FIFO underflow status */
+#define SD_FIFO_TXDATA_UFLOW       _BIT(4)
+/* SD bit for data timeout status */
+#define SD_DATA_TIMEOUT            _BIT(3)
+/* SD bit for command timeout status */
+#define SD_CMD_TIMEOUT             _BIT(2)
+/* SD bit for data CRC failure status */
+#define SD_DATA_CRC_FAIL           _BIT(1)
+/* SD bit for command CRC failure status */
+#define SD_CMD_CRC_FAIL            _BIT(0)
+
+#endif /* __ASM_ARCH_SDCARD_H */
diff --git a/arch/arm/mach-lpc32xx/include/mach/slcnand.h b/arch/arm/mach-lpc32xx/include/mach/slcnand.h
new file mode 100644
index 0000000..6d9c896
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/slcnand.h
@@ -0,0 +1,103 @@
+/*
+ * asm-arm/arch-lpc32xx/slcnand.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_SLCNAND_H
+#define __ASM_ARCH_SLCNAND_H
+
+/**********************************************************************
+* SLC NAND controller register offsets
+**********************************************************************/
+
+#define SLC_DATA(x)			(x + 0x000)
+#define SLC_ADDR(x)			(x + 0x004)
+#define SLC_CMD(x)			(x + 0x008)
+#define SLC_STOP(x)			(x + 0x00C)
+#define SLC_CTRL(x)			(x + 0x010)
+#define SLC_CFG(x)			(x + 0x014)
+#define SLC_STAT(x)			(x + 0x018)
+#define SLC_INT_STAT(x)			(x + 0x01C)
+#define SLC_IEN(x)			(x + 0x020)
+#define SLC_ISR(x)			(x + 0x024)
+#define SLC_ICR(x)			(x + 0x028)
+#define SLC_TAC(x)			(x + 0x02C)
+#define SLC_TC(x)			(x + 0x030)
+#define SLC_ECC(x)			(x + 0x034)
+#define SLC_DMA_DATA(x)			(x + 0x038)
+
+/**********************************************************************
+* slc_ctrl register definitions
+**********************************************************************/
+#define SLCCTRL_SW_RESET    _BIT(2) /* Reset the NAND controller bit */
+#define SLCCTRL_ECC_CLEAR   _BIT(1) /* Reset ECC bit */
+#define SLCCTRL_DMA_START   _BIT(0) /* Start DMA channel bit */
+
+/**********************************************************************
+* slc_cfg register definitions
+**********************************************************************/
+#define SLCCFG_CE_LOW       _BIT(5) /* Force CE low bit */
+#define SLCCFG_DMA_ECC      _BIT(4) /* Enable DMA ECC bit */
+#define SLCCFG_ECC_EN       _BIT(3) /* ECC enable bit */
+#define SLCCFG_DMA_BURST    _BIT(2) /* DMA burst bit */
+#define SLCCFG_DMA_DIR      _BIT(1) /* DMA write(0)/read(1) bit */
+#define SLCCFG_WIDTH        _BIT(0) /* External device width, 0=8bit */
+
+/**********************************************************************
+* slc_stat register definitions
+**********************************************************************/
+#define SLCSTAT_DMA_FIFO    _BIT(2) /* DMA FIFO has data bit */
+#define SLCSTAT_SLC_FIFO    _BIT(1) /* SLC FIFO has data bit */
+#define SLCSTAT_NAND_READY  _BIT(0) /* NAND device is ready bit */
+
+/**********************************************************************
+* slc_int_stat, slc_ien, slc_isr, and slc_icr register definitions
+**********************************************************************/
+#define SLCSTAT_INT_TC      _BIT(1) /* Transfer count bit */
+#define SLCSTAT_INT_RDY_EN  _BIT(0) /* Ready interrupt bit */
+
+/**********************************************************************
+* slc_tac register definitions
+**********************************************************************/
+/* Clock setting for RDY write sample wait time in 2*n clocks */
+#define SLCTAC_WDR(n)       (((n) & 0xF) << 28)
+/* Write pulse width in clocks cycles, 1 to 16 clocks */
+#define SLCTAC_WWIDTH(n)    (((n) & 0xF) << 24)
+/* Write hold time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_WHOLD(n)     (((n) & 0xF) << 20)
+/* Write setup time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_WSETUP(n)    (((n) & 0xF) << 16)
+/* Clock setting for RDY read sample wait time in 2*n clocks */
+#define SLCTAC_RDR(n)       (((n) & 0xF) << 12)
+/* Read pulse width in clocks cycles, 1 to 16 clocks */
+#define SLCTAC_RWIDTH(n)    (((n) & 0xF) << 8)
+/* Read hold time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_RHOLD(n)     (((n) & 0xF) << 4)
+/* Read setup time of control and data signals, 1 to 16 clocks */
+#define SLCTAC_RSETUP(n)    (((n) & 0xF) << 0)
+
+/**********************************************************************
+* slc_ecc register definitions
+**********************************************************************/
+/* ECC line party fetch macro */
+#define SLCECC_TO_LINEPAR(n) (((n) >> 6) & 0x7FFF)
+#define SLCECC_TO_COLPAR(n)  ((n) & 0x3F)
+
+#endif /* __ASM_ARCH_SLCNAND_H */
diff --git a/arch/arm/mach-lpc32xx/include/mach/uncompress.h b/arch/arm/mach-lpc32xx/include/mach/uncompress.h
index c142487..c4ffa37 100644
--- a/arch/arm/mach-lpc32xx/include/mach/uncompress.h
+++ b/arch/arm/mach-lpc32xx/include/mach/uncompress.h
@@ -24,6 +24,28 @@
 #include <mach/hardware.h>
 #include <mach/platform.h>
 
+#if defined(CONFIG_SERIAL_HS_LPC32XX_CONSOLE)
+
+#define HSUART_FIFO     (*(volatile unsigned char *)(LPC32XX_HS_UART1_BASE + 0x00))
+#define HSUART_LEVEL    (*(volatile unsigned short *)(LPC32XX_HS_UART1_BASE + 0x04))
+
+static inline void putc(int ch)
+{
+    /* Wait for transmit FIFO to empty */
+    while ((HSUART_LEVEL & 0xFF00) != 0);
+    HSUART_FIFO = ch;
+}
+
+static inline void flush(void)
+{
+
+    /* Don't see a reset? */
+
+    /* Then just wait for transmition to complete */
+    while ((HSUART_LEVEL & 0xFF00) != 0);
+}
+
+#else
 /*
  * Uncompress output is hardcoded to standard UART 5
  */
@@ -52,6 +74,7 @@ static inline void flush(void)
 	__raw_writel(__raw_readl(_UARTREG(LPC32XX_UART_IIRFCR_O)) |
 		UART_FIFO_CTL_TX_RESET, _UARTREG(LPC32XX_UART_IIRFCR_O));
 }
+#endif
 
 /* NULL functions; we don't presently need them */
 #define arch_decomp_setup()
diff --git a/arch/arm/mach-lpc32xx/include/mach/usbd.h b/arch/arm/mach-lpc32xx/include/mach/usbd.h
new file mode 100644
index 0000000..f10efae
--- /dev/null
+++ b/arch/arm/mach-lpc32xx/include/mach/usbd.h
@@ -0,0 +1,291 @@
+/*
+ * asm-arm/arch-lpc32xx/usbd.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __ASM_ARCH_USBD_H
+#define __ASM_ARCH_USBD_H
+
+/**********************************************************************
+* USE device controller register offsets
+**********************************************************************/
+
+#define USBD_DEVINTST(x)	(x + 0x200)
+#define USBD_DEVINTEN(x)	(x + 0x204)
+#define USBD_DEVINTCLR(x)	(x + 0x208)
+#define USBD_DEVINTSET(x)	(x + 0x20C)
+#define USBD_CMDCODE(x)		(x + 0x210)
+#define USBD_CMDDATA(x)		(x + 0x214)
+#define USBD_RXDATA(x)		(x + 0x218)
+#define USBD_TXDATA(x)		(x + 0x21C)
+#define USBD_RXPLEN(x)		(x + 0x220)
+#define USBD_TXPLEN(x)		(x + 0x224)
+#define USBD_CTRL(x)		(x + 0x228)
+#define USBD_DEVINTPRI(x)	(x + 0x22C)
+#define USBD_EPINTST(x)		(x + 0x230)
+#define USBD_EPINTEN(x)		(x + 0x234)
+#define USBD_EPINTCLR(x)	(x + 0x238)
+#define USBD_EPINTSET(x)	(x + 0x23C)
+#define USBD_EPINTPRI(x)	(x + 0x240)
+#define USBD_REEP(x)		(x + 0x244)
+#define USBD_EPIND(x)		(x + 0x248)
+#define USBD_EPMAXPSIZE(x)	(x + 0x24C)
+/* DMA support registers only below */
+/* Set, clear, or get enabled state of the DMA request status. If
+   enabled, an IN or OUT token will start a DMA transfer for the EP */
+#define USBD_DMARST(x)		(x + 0x250)
+#define USBD_DMARCLR(x)		(x + 0x254)
+#define USBD_DMARSET(x)		(x + 0x258)
+/* DMA UDCA head pointer */
+#define USBD_UDCAH(x)		(x + 0x280)
+/* EP DMA status, enable, and disable. This is used to specifically
+   enabled or disable DMA for a specific EP */
+#define USBD_EPDMAST(x)		(x + 0x284)
+#define USBD_EPDMAEN(x)		(x + 0x288)
+#define USBD_EPDMADIS(x)	(x + 0x28C)
+/* DMA master interrupts enable and pending interrupts */
+#define USBD_DMAINTST(x)	(x + 0x290)
+#define USBD_DMAINTEN(x)	(x + 0x294)
+/* DMA end of transfer interrupt enable, disable, status */
+#define USBD_EOTINTST(x)	(x + 0x2A0)
+#define USBD_EOTINTCLR(x)	(x + 0x2A4)
+#define USBD_EOTINTSET(x)	(x + 0x2A8)
+/* New DD request interrupt enable, disable, status */
+#define USBD_NDDRTINTST(x)	(x + 0x2AC)
+#define USBD_NDDRTINTCLR(x)	(x + 0x2B0)
+#define USBD_NDDRTINTSET(x)	(x + 0x2B4)
+/* DMA error interrupt enable, disable, status */
+#define USBD_SYSERRTINTST(x)	(x + 0x2B8)
+#define USBD_SYSERRTINTCLR(x)	(x + 0x2BC)
+#define USBD_SYSERRTINTSET(x)	(x + 0x2C0)
+
+/**********************************************************************
+* USBD_DEVINTST/USBD_DEVINTEN/USBD_DEVINTCLR/USBD_DEVINTSET/
+* USBD_DEVINTPRI register definitions
+**********************************************************************/
+#define USBD_ERR_INT               (1 << 9)
+#define USBD_EP_RLZED              (1 << 8)
+#define USBD_TXENDPKT              (1 << 7)
+#define USBD_RXENDPKT              (1 << 6)
+#define USBD_CDFULL                (1 << 5)
+#define USBD_CCEMPTY               (1 << 4)
+#define USBD_DEV_STAT              (1 << 3)
+#define USBD_EP_SLOW               (1 << 2)
+#define USBD_EP_FAST               (1 << 1)
+#define USBD_FRAME                 (1 << 0)
+
+/**********************************************************************
+* USBD_EPINTST/USBD_EPINTEN/USBD_EPINTCLR/USBD_EPINTSET/
+* USBD_EPINTPRI register definitions
+**********************************************************************/
+/* End point selection macro (RX) */
+#define USBD_RX_EP_SEL(e)          (1 << ((e) << 1))
+
+/* End point selection macro (TX) */
+#define USBD_TX_EP_SEL(e)          (1 << (((e) << 1) + 1))
+
+/**********************************************************************
+* USBD_REEP/USBD_DMARST/USBD_DMARCLR/USBD_DMARSET/USBD_EPDMAST/
+* USBD_EPDMAEN/USBD_EPDMADIS/
+* USBD_NDDRTINTST/USBD_NDDRTINTCLR/USBD_NDDRTINTSET/
+* USBD_EOTINTST/USBD_EOTINTCLR/USBD_EOTINTSET/
+* USBD_SYSERRTINTST/USBD_SYSERRTINTCLR/USBD_SYSERRTINTSET
+* register definitions
+**********************************************************************/
+/* Endpoint selection macro */
+#define USBD_EP_SEL(e)              (1 << (e))
+
+/**********************************************************************
+SBD_DMAINTST/USBD_DMAINTEN
+**********************************************************************/
+#define USBD_SYS_ERR_INT            (1 << 2)
+#define USBD_NEW_DD_INT             (1 << 1)
+#define USBD_EOT_INT                (1 << 0)
+
+/**********************************************************************
+* USBD_RXPLEN register definitions
+**********************************************************************/
+#define USBD_PKT_RDY               (1 << 11)
+#define USBD_DV                    (1 << 10)
+#define USBD_PK_LEN_MASK           0x3FF
+
+/**********************************************************************
+* USBD_CTRL register definitions
+**********************************************************************/
+#define USBD_LOG_ENDPOINT(e)      ((e) << 2)
+#define USBD_WR_EN                (1 << 1)
+#define USBD_RD_EN                (1 << 0)
+
+/**********************************************************************
+* USBD_CMDCODE register definitions
+**********************************************************************/
+#define USBD_CMD_CODE(c)          ((c) << 16)
+#define USBD_CMD_PHASE(p)         ((p) << 8)
+
+/**********************************************************************
+* USBD_DMARST/USBD_DMARCLR/USBD_DMARSET register definitions
+**********************************************************************/
+#define USBD_DMAEP(e)             (1 << (e))
+
+/* DD (DMA Descriptor) structure, requires word alignment */
+struct lpc32xx_usbd_dd
+{
+	u32 *dd_next;
+	u32 dd_setup;
+	u32 dd_buffer_addr;
+	u32 dd_status;
+	u32 dd_iso_ps_mem_addr;
+};
+
+/* dd_setup bit defines */
+#define DD_SETUP_ATLE_DMA_MODE 0x01
+#define DD_SETUP_NEXT_DD_VALID 0x04
+#define DD_SETUP_ISO_EP        0x10
+#define DD_SETUP_PACKETLEN(n)  (((n) & 0x7FF) << 5)
+#define DD_SETUP_DMALENBYTES(n)(((n) & 0xFFFF) << 16)
+
+/* dd_status bit defines */
+#define DD_STATUS_DD_RETIRED   0x01
+#define DD_STATUS_STS_MASK     0x1E
+#define DD_STATUS_STS_NS       0x00 /* Not serviced */
+#define DD_STATUS_STS_BS       0x02 /* Being serviced */
+#define DD_STATUS_STS_NC       0x04 /* Normal completion */
+#define DD_STATUS_STS_DUR      0x06 /* Data underrun (short packet) */
+#define DD_STATUS_STS_DOR      0x08 /* Data overrun */
+#define DD_STATUS_STS_SE       0x12 /* System error */
+#define DD_STATUS_PKT_VAL      0x20 /* Packet valid */
+#define DD_STATUS_LSB_EX       0x40 /* LS byte extracted (ATLE) */
+#define DD_STATUS_MSB_EX       0x80 /* MS byte extracted (ATLE) */
+#define DD_STATUS_MLEN(n)      (((n) >> 8) & 0x3F)
+#define DD_STATUS_CURDMACNT(n) (((n) >> 16) & 0xFFFF)
+
+/*
+ *
+ * Protocol engine bits below
+ *
+ */
+/* Device Interrupt Bit Definitions */
+#define FRAME_INT           0x00000001
+#define EP_FAST_INT         0x00000002
+#define EP_SLOW_INT         0x00000004
+#define DEV_STAT_INT        0x00000008
+#define CCEMTY_INT          0x00000010
+#define CDFULL_INT          0x00000020
+#define RxENDPKT_INT        0x00000040
+#define TxENDPKT_INT        0x00000080
+#define EP_RLZED_INT        0x00000100
+#define ERR_INT             0x00000200
+
+/* Rx & Tx Packet Length Definitions */
+#define PKT_LNGTH_MASK      0x000003FF
+#define PKT_DV              0x00000400
+#define PKT_RDY             0x00000800
+
+/* USB Control Definitions */
+#define CTRL_RD_EN          0x00000001
+#define CTRL_WR_EN          0x00000002
+
+/* Command Codes */
+#define CMD_SET_ADDR        0x00D00500
+#define CMD_CFG_DEV         0x00D80500
+#define CMD_SET_MODE        0x00F30500
+#define CMD_RD_FRAME        0x00F50500
+#define DAT_RD_FRAME        0x00F50200
+#define CMD_RD_TEST         0x00FD0500
+#define DAT_RD_TEST         0x00FD0200
+#define CMD_SET_DEV_STAT    0x00FE0500
+#define CMD_GET_DEV_STAT    0x00FE0500
+#define DAT_GET_DEV_STAT    0x00FE0200
+#define CMD_GET_ERR_CODE    0x00FF0500
+#define DAT_GET_ERR_CODE    0x00FF0200
+#define CMD_RD_ERR_STAT     0x00FB0500
+#define DAT_RD_ERR_STAT     0x00FB0200
+#define DAT_WR_BYTE(x)     (0x00000100 | ((x) << 16))
+#define CMD_SEL_EP(x)      (0x00000500 | ((x) << 16))
+#define DAT_SEL_EP(x)      (0x00000200 | ((x) << 16))
+#define CMD_SEL_EP_CLRI(x) (0x00400500 | ((x) << 16))
+#define DAT_SEL_EP_CLRI(x) (0x00400200 | ((x) << 16))
+#define CMD_SET_EP_STAT(x) (0x00400500 | ((x) << 16))
+#define CMD_CLR_BUF         0x00F20500
+#define DAT_CLR_BUF         0x00F20200
+#define CMD_VALID_BUF       0x00FA0500
+
+/* Device Address Register Definitions */
+#define DEV_ADDR_MASK       0x7F
+#define DEV_EN              0x80
+
+/* Device Configure Register Definitions */
+#define CONF_DVICE          0x01
+
+/* Device Mode Register Definitions */
+#define AP_CLK              0x01
+#define INAK_CI             0x02
+#define INAK_CO             0x04
+#define INAK_II             0x08
+#define INAK_IO             0x10
+#define INAK_BI             0x20
+#define INAK_BO             0x40
+
+/* Device Status Register Definitions */
+#define DEV_CON             0x01
+#define DEV_CON_CH          0x02
+#define DEV_SUS             0x04
+#define DEV_SUS_CH          0x08
+#define DEV_RST             0x10
+
+/* Error Code Register Definitions */
+#define ERR_EC_MASK         0x0F
+#define ERR_EA              0x10
+
+/* Error Status Register Definitions */
+#define ERR_PID             0x01
+#define ERR_UEPKT           0x02
+#define ERR_DCRC            0x04
+#define ERR_TIMOUT          0x08
+#define ERR_EOP             0x10
+#define ERR_B_OVRN          0x20
+#define ERR_BTSTF           0x40
+#define ERR_TGL             0x80
+
+/* Endpoint Select Register Definitions */
+#define EP_SEL_F            0x01
+#define EP_SEL_ST           0x02
+#define EP_SEL_STP          0x04
+#define EP_SEL_PO           0x08
+#define EP_SEL_EPN          0x10
+#define EP_SEL_B_1_FULL     0x20
+#define EP_SEL_B_2_FULL     0x40
+
+/* Endpoint Status Register Definitions */
+#define EP_STAT_ST          0x01
+#define EP_STAT_DA          0x20
+#define EP_STAT_RF_MO       0x40
+#define EP_STAT_CND_ST      0x80
+
+/* Clear Buffer Register Definitions */
+#define CLR_BUF_PO          0x01
+
+/* DMA Interrupt Bit Definitions */
+#define EOT_INT             0x01
+#define NDD_REQ_INT         0x02
+#define SYS_ERR_INT         0x04
+
+
+#endif /* __ASM_ARCH_USBD_H */
diff --git a/arch/arm/mach-lpc32xx/irq.c b/arch/arm/mach-lpc32xx/irq.c
index c74de01..d4648bc 100644
--- a/arch/arm/mach-lpc32xx/irq.c
+++ b/arch/arm/mach-lpc32xx/irq.c
@@ -16,33 +16,26 @@
  * GNU General Public License for more details.
  */
 
+#ifdef CONFIG_PM_DEBUG
+#define DEBUG
+#endif
+
+#include <linux/pm.h>
+#include <linux/suspend.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/err.h>
 #include <linux/io.h>
+#include <linux/kobject.h>
 
 #include <mach/irqs.h>
 #include <mach/hardware.h>
 #include <mach/platform.h>
 #include "common.h"
 
-/*
- * Default value representing the Activation polarity of all internal
- * interrupt sources
- */
-#define MIC_APR_DEFAULT		0x3FF0EFE0
-#define SIC1_APR_DEFAULT	0xFBD27186
-#define SIC2_APR_DEFAULT	0x801810C0
-
-/*
- * Default value representing the Activation Type of all internal
- * interrupt sources. All are level sensitive.
- */
-#define MIC_ATR_DEFAULT		0x00000000
-#define SIC1_ATR_DEFAULT	0x00026000
-#define SIC2_ATR_DEFAULT	0x00000000
+unsigned int wakeupirq = -1;
 
 struct lpc32xx_event_group_regs {
 	void __iomem *enab_reg;
@@ -70,8 +63,47 @@ struct lpc32xx_event_info {
 	u32 mask;
 };
 
+static const char *lpc32xx_irqname[NR_IRQS] = {
+	[IRQ_LPC32XX_GPI_08] = "GPI_08",
+	[IRQ_LPC32XX_GPI_09] = "GPI_09",
+	[IRQ_LPC32XX_GPI_19] = "GPI_19",
+	[IRQ_LPC32XX_GPI_07] = "GPI_07",
+	[IRQ_LPC32XX_GPI_00] = "GPI_00",
+	[IRQ_LPC32XX_GPI_01] = "GPI_01",
+	[IRQ_LPC32XX_GPI_02] = "GPI_02",
+	[IRQ_LPC32XX_GPI_03] = "GPI_03",
+	[IRQ_LPC32XX_GPI_04] = "GPI_04",
+	[IRQ_LPC32XX_GPI_05] = "GPI_05",
+	[IRQ_LPC32XX_GPI_06] = "GPI_06",
+	[IRQ_LPC32XX_GPI_28] = "GPI_28",
+	[IRQ_LPC32XX_UART_IIR1] = "Uart_1",
+	[IRQ_LPC32XX_UART_IIR2] = "Uart_2",
+	[IRQ_LPC32XX_UART_IIR3] = "Uart_3",
+	[IRQ_LPC32XX_UART_IIR4] = "Uart_4",
+	[IRQ_LPC32XX_UART_IIR5] = "Uart_5",
+	[IRQ_LPC32XX_UART_IIR6] = "Uart_6",
+	[IRQ_LPC32XX_UART_IIR7] = "Uart_7",
+	[IRQ_LPC32XX_GPIO_00] = "GPIO_00",
+	[IRQ_LPC32XX_GPIO_01] = "GPIO_01",
+	[IRQ_LPC32XX_GPIO_02] = "GPIO_02",
+	[IRQ_LPC32XX_GPIO_03] = "GPIO_03",
+	[IRQ_LPC32XX_GPIO_04] = "GPIO_04",
+	[IRQ_LPC32XX_GPIO_05] = "GPIO_05",
+	[IRQ_LPC32XX_ETHERNET]    = "Ethernet",
+	[IRQ_LPC32XX_KEY]         = "Keyboard",
+	[IRQ_LPC32XX_USB_OTG_ATX] = "USB_OTG",
+	[IRQ_LPC32XX_USB_HOST]    = "USB_Host",
+	[IRQ_LPC32XX_RTC]     = "RTC",
+	[IRQ_LPC32XX_MSTIMER] = "MS_Timer",
+	[IRQ_LPC32XX_TS_AUX]  = "TS_AUX",
+	[IRQ_LPC32XX_TS_P]    = "TS_P",
+	[IRQ_LPC32XX_TS_IRQ]  = "TS_IRQ",
+};
+
 /*
  * Maps an IRQ number to and event mask and register
+ * All IRQs are event based wakeup IRQs except the UARTs. The UART RX
+ * wakeup is based on the pin state, not the UART IRQ state.
  */
 static const struct lpc32xx_event_info lpc32xx_events[NR_IRQS] = {
 	[IRQ_LPC32XX_GPI_08] = {
@@ -122,6 +154,39 @@ static const struct lpc32xx_event_info lpc32xx_events[NR_IRQS] = {
 		.event_group = &lpc32xx_event_pin_regs,
 		.mask = LPC32XX_CLKPWR_EXTSRC_GPI_28_BIT,
 	},
+	[IRQ_LPC32XX_GPI_28] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_GPI_28_BIT,
+	},
+  /* UART */
+	[IRQ_LPC32XX_UART_IIR1] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U1_RX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR2] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U2_RX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR3] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U3_RX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR4] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U4_RX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR5] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U5_RX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR6] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U6_IRRX_BIT,
+	},
+	[IRQ_LPC32XX_UART_IIR7] = {
+		.event_group = &lpc32xx_event_pin_regs,
+		.mask = LPC32XX_CLKPWR_EXTSRC_U7_RX_BIT,
+	},
 	[IRQ_LPC32XX_GPIO_00] = {
 		.event_group = &lpc32xx_event_int_regs,
 		.mask = LPC32XX_CLKPWR_INTSRC_GPIO_00_BIT,
@@ -150,6 +215,10 @@ static const struct lpc32xx_event_info lpc32xx_events[NR_IRQS] = {
 		.event_group = &lpc32xx_event_int_regs,
 		.mask = LPC32XX_CLKPWR_INTSRC_KEY_BIT,
 	},
+	[IRQ_LPC32XX_ETHERNET] = {
+		.event_group = &lpc32xx_event_int_regs,
+		.mask = LPC32XX_CLKPWR_INTSRC_MAC_BIT,
+	},
 	[IRQ_LPC32XX_USB_OTG_ATX] = {
 		.event_group = &lpc32xx_event_int_regs,
 		.mask = LPC32XX_CLKPWR_INTSRC_USBATXINT_BIT,
@@ -271,11 +340,13 @@ static int lpc32xx_set_irq_type(struct irq_data *d, unsigned int type)
 	case IRQ_TYPE_EDGE_RISING:
 		/* Rising edge sensitive */
 		__lpc32xx_set_irq_type(d->irq, 1, 1);
+		__irq_set_handler_locked(d->irq, handle_edge_irq);
 		break;
 
 	case IRQ_TYPE_EDGE_FALLING:
 		/* Falling edge sensitive */
 		__lpc32xx_set_irq_type(d->irq, 0, 1);
+		__irq_set_handler_locked(d->irq, handle_edge_irq);
 		break;
 
 	case IRQ_TYPE_LEVEL_LOW:
@@ -293,15 +364,171 @@ static int lpc32xx_set_irq_type(struct irq_data *d, unsigned int type)
 		return -EINVAL;
 	}
 
-	/* Ok to use the level handler for all types */
-	irq_set_handler(d->irq, handle_level_irq);
-
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static u32 backup_irqs[NR_IRQ_CTRLS];
+static u32 wakeup_irqs[NR_IRQ_CTRLS];
+
+static ssize_t wakeup_event_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	if(wakeupirq < 0) {
+		return 0;
+	}
+
+	return sprintf(buf, "%s\n", lpc32xx_irqname[wakeupirq]);
+}
+static struct kobj_attribute wakeup_event_attr =
+			__ATTR(wakeup_event, 0644, wakeup_event_show, NULL);
+#endif
+
+void lpc32xx_irq_suspend(suspend_state_t state)
+{
+#ifdef CONFIG_PM
+	unsigned int i, ctrl, mask;
+
+	for( i=0; i < NR_IRQ_CTRLS; i++) {
+		get_controller((i*32), &ctrl, &mask);
+
+		/* Backup programmed IRQs */
+		backup_irqs[i] = __raw_readl(LPC32XX_INTC_MASK(ctrl));
+
+		/* Disable all interrupts */
+		__raw_writel(0, LPC32XX_INTC_MASK(ctrl));
+
+		if(state == PM_SUSPEND_STANDBY) {
+			pr_debug("Wakeup_irq[%d] = 0x%08X\n", i, wakeup_irqs[i] );
+
+			/* Program interrupts only in standby because of DDR wakeup issues*/
+			__raw_writel( wakeup_irqs[i], LPC32XX_INTC_RAW_STAT(ctrl));
+			__raw_writel( wakeup_irqs[i], LPC32XX_INTC_MASK(ctrl));
+		}
+	}
+
+	if(state == PM_SUSPEND_MEM)	{
+		pr_debug("Start_enable_pin = 0x%X\n",
+				__raw_readl(lpc32xx_event_pin_regs.enab_reg));
+		pr_debug("Start_enable_internal = 0x%X\n",
+				__raw_readl(lpc32xx_event_int_regs.enab_reg));
+	}
+
+	/* Clear Raw Status registers */
+	__raw_writel(LPC32XX_CLKPWR_EXTSRC_MASK,
+			lpc32xx_event_pin_regs.rawstat_reg);
+	__raw_writel(LPC32XX_CLKPWR_INTSRC_MASK,
+			lpc32xx_event_int_regs.rawstat_reg);
+
+	sysfs_remove_file(power_kobj, &wakeup_event_attr.attr);
+#endif
+}
+
+void lpc32xx_irq_resume(suspend_state_t state)
+{
+#ifdef CONFIG_PM
+	unsigned int i, ctrl, mask;
+	unsigned int pinRegMask, intRegMask;
+	unsigned int statusReg = 0;
+
+	pinRegMask = __raw_readl(lpc32xx_event_pin_regs.maskstat_reg);
+	intRegMask = __raw_readl(lpc32xx_event_int_regs.maskstat_reg);
+	pr_debug("Pin Register wakeup mask = 0x%X\n", pinRegMask);
+	pr_debug("Int Register wakeup mask = 0x%X\n", intRegMask);
+
+	/* Scan all lpc32xx_events to find who woke up */
+	for(i=0; i< NR_IRQS; i++) {
+		/* Check IRQ can be defined as wakeup IRQ */
+		if (lpc32xx_events[i].mask != 0) {
+			pr_debug("Scan IRQ %d\n",i);
+			if((lpc32xx_events[i].event_group->enab_reg == lpc32xx_event_pin_regs.enab_reg)
+					&& pinRegMask) {
+				pr_debug("Test mask 0x%X\n",lpc32xx_events[i].mask);
+				if(lpc32xx_events[i].mask == pinRegMask) {
+					wakeupirq = i;
+					break;
+				}
+			}
+
+			if((lpc32xx_events[i].event_group->enab_reg == lpc32xx_event_int_regs.enab_reg)
+					&& intRegMask) {
+				pr_debug("Test mask 0x%X\n",lpc32xx_events[i].mask);
+				if(lpc32xx_events[i].mask == intRegMask) {
+					wakeupirq = i;
+					break;
+				}
+			}
+		}
+	}
+
+	/* Clear Raw Status registers */
+	__raw_writel(LPC32XX_CLKPWR_EXTSRC_MASK,
+			lpc32xx_event_pin_regs.rawstat_reg);
+	__raw_writel(LPC32XX_CLKPWR_INTSRC_MASK,
+			lpc32xx_event_int_regs.rawstat_reg);
+
+	for( i=0; i < NR_IRQ_CTRLS; i++) {
+		get_controller( (i*32), &ctrl, &mask);
+
+		statusReg = __raw_readl(LPC32XX_INTC_STAT(ctrl));
+
+		pr_debug("statusReg %d = 0x%08X\n",i,statusReg);
+
+		/* Disable all interrupts */
+		__raw_writel( 0, LPC32XX_INTC_MASK(ctrl));
+
+		/* Clear Wakeup pending interrupts */
+		__raw_writel(wakeup_irqs[i], LPC32XX_INTC_RAW_STAT(ctrl));
+
+		/* Restore old controller config */
+		__raw_writel(backup_irqs[i], LPC32XX_INTC_MASK(ctrl));
+	}
+
+	if(wakeupirq > 0) {
+		pr_debug("Wakeup source: %s\n", lpc32xx_irqname[wakeupirq]);
+		sysfs_create_file(power_kobj, &wakeup_event_attr.attr);
+	}
+#endif
+}
+
 static int lpc32xx_irq_wake(struct irq_data *d, unsigned int state)
 {
 	unsigned long eventreg;
+	unsigned int ctrl_nr, ctrl, mask;
+
+	if (unlikely(d->irq >= (32 * NR_IRQ_CTRLS))) {
+		return -EINVAL;
+	}
+
+	get_controller(d->irq, &ctrl, &mask);
+	ctrl_nr = d->irq / 32;
+
+#ifdef CONFIG_PM
+	if (state) {
+		pr_debug("Set irq %d as wakeup IRQ\n", d->irq);
+		wakeup_irqs[ctrl_nr] |= mask;
+		if( ctrl_nr == 1 ) {
+			wakeup_irqs[0] |= ( 1<<IRQ_LPC32XX_SUB1IRQ );
+		}
+		if( ctrl_nr == 2 ) {
+			wakeup_irqs[0] |= ( 1<<IRQ_LPC32XX_SUB2IRQ );
+		}
+	}
+	else
+	{
+		pr_debug("Disable wakeup from irq %d \n", d->irq);
+		wakeup_irqs[ctrl_nr] &= ~mask;
+		if( (ctrl_nr == 1) && (wakeup_irqs[1] == 0) )
+			wakeup_irqs[0] &= ~( 1<<IRQ_LPC32XX_SUB1IRQ );
+		if( (ctrl_nr == 2) && (wakeup_irqs[2] == 0) )
+				wakeup_irqs[0] &= ~( 1<<IRQ_LPC32XX_SUB2IRQ );
+	}
+#endif
+
+	if ( lpc32xx_events[d->irq].mask == 0 ) {
+		pr_warning("Can't configure irq %d as wakeup source\n",d->irq);
+		return 0;
+	}
 
 	if (lpc32xx_events[d->irq].mask != 0) {
 		eventreg = __raw_readl(lpc32xx_events[d->irq].
@@ -416,7 +643,9 @@ void __init lpc32xx_init_irq(void)
 	lpc32xx_set_default_mappings(SIC2_APR_DEFAULT, SIC2_ATR_DEFAULT, 64);
 
 	/* mask all interrupts except SUBIRQ */
-	__raw_writel(0, LPC32XX_INTC_MASK(LPC32XX_MIC_BASE));
+	__raw_writel((1 << IRQ_LPC32XX_SUB1IRQ) | (1 << IRQ_LPC32XX_SUB2IRQ) |
+			(1 << IRQ_LPC32XX_SUB1FIQ) | (1 << IRQ_LPC32XX_SUB2FIQ),
+			LPC32XX_INTC_MASK(LPC32XX_MIC_BASE));
 	__raw_writel(0, LPC32XX_INTC_MASK(LPC32XX_SIC1_BASE));
 	__raw_writel(0, LPC32XX_INTC_MASK(LPC32XX_SIC2_BASE));
 
@@ -429,16 +658,6 @@ void __init lpc32xx_init_irq(void)
 	__raw_writel(0, LPC32XX_CLKPWR_INT_ER);
 	__raw_writel(0, LPC32XX_CLKPWR_PIN_ER);
 
-	/*
-	 * Default wake activation polarities, all pin sources are low edge
-	 * triggered
-	 */
-	__raw_writel(LPC32XX_CLKPWR_INTSRC_TS_P_BIT |
-		LPC32XX_CLKPWR_INTSRC_MSTIMER_BIT |
-		LPC32XX_CLKPWR_INTSRC_RTC_BIT,
-		LPC32XX_CLKPWR_INT_AP);
-	__raw_writel(0, LPC32XX_CLKPWR_PIN_AP);
-
 	/* Clear latched wake event states */
 	__raw_writel(__raw_readl(LPC32XX_CLKPWR_PIN_RS),
 		LPC32XX_CLKPWR_PIN_RS);
diff --git a/arch/arm/mach-lpc32xx/phy3250.c b/arch/arm/mach-lpc32xx/phy3250.c
index bfee5b4..041c5f6 100644
--- a/arch/arm/mach-lpc32xx/phy3250.c
+++ b/arch/arm/mach-lpc32xx/phy3250.c
@@ -27,9 +27,12 @@
 #include <linux/spi/eeprom.h>
 #include <linux/leds.h>
 #include <linux/gpio.h>
+#include <linux/input.h>
 #include <linux/amba/bus.h>
 #include <linux/amba/clcd.h>
 #include <linux/amba/pl022.h>
+#include <linux/amba/mmci.h>
+#include <sound/uda1380.h>
 
 #include <asm/setup.h>
 #include <asm/mach-types.h>
@@ -47,6 +50,10 @@
 #define LCD_POWER_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 0)
 #define BKL_POWER_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 4)
 #define LED_GPIO	LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 1)
+#define NAND_WP_GPIO    LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 19)
+#define MMC_PWR_ENABLE_GPIO     LPC32XX_GPIO(LPC32XX_GPO_P3_GRP, 5)
+#define MMC_CD_GPIO     LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 1)
+#define MMC_WP_GPIO     LPC32XX_GPIO(LPC32XX_GPIO_P3_GRP, 0)
 
 /*
  * AMBA LCD controller
@@ -234,7 +241,6 @@ static int __init phy3250_spi_board_register(void)
 			.max_speed_hz = 5000000,
 			.bus_num = 0,
 			.chip_select = 0,
-			.mode = SPI_MODE_0,
 			.platform_data = &eeprom,
 			.controller_data = &spi0_chip_info,
 		},
@@ -244,10 +250,25 @@ static int __init phy3250_spi_board_register(void)
 }
 arch_initcall(phy3250_spi_board_register);
 
+/*
+ * Platform Data for UDA1380 Audiocodec.
+ * As there are no GPIOs for codec power & reset pins,
+ * dummy GPIO numbers are used.
+ */
+static struct uda1380_platform_data uda1380_info = {
+	.gpio_power = LPC32XX_GPIO(LPC32XX_GPO_P3_GRP,10),
+	.gpio_reset = LPC32XX_GPIO(LPC32XX_GPO_P3_GRP,2),
+	.dac_clk    = UDA1380_DAC_CLK_WSPLL,
+};
+
 static struct i2c_board_info __initdata phy3250_i2c_board_info[] = {
 	{
 		I2C_BOARD_INFO("pcf8563", 0x51),
 	},
+	{
+		I2C_BOARD_INFO("uda1380", 0x18),
+		.platform_data = &uda1380_info,
+	},
 };
 
 static struct gpio_led phy_leds[] = {
@@ -270,17 +291,251 @@ static struct platform_device lpc32xx_gpio_led_device = {
 	.dev.platform_data	= &led_data,
 };
 
+/*
+ * Board specific key scanner driver data
+ */
+#define PHY3250_KMATRIX_SIZE 1
+static int lpc32xx_keymaps[] = {
+	KEY_1,  /* 1, 1 */
+};
+
+static struct lpc32XX_kscan_cfg lpc32xx_kscancfg = {
+	.matrix_sz      = PHY3250_KMATRIX_SIZE,
+	.keymap         = lpc32xx_keymaps,
+	/* About a 30Hz scan rate based on a 32KHz clock */
+	.deb_clks       = 3,
+	.scan_delay     = 34,
+};
+
+static struct resource kscan_resources[] = {
+	[0] = {
+		.start  = LPC32XX_KSCAN_BASE,
+		.end    = LPC32XX_KSCAN_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_LPC32XX_KEY,
+		.end    = IRQ_LPC32XX_KEY,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device lpc32xx_kscan_device = {
+	.name           = "lpc32xx_keys",
+	.id             = 0,
+	.dev            = {
+		.platform_data  = &lpc32xx_kscancfg,
+	},
+	.num_resources  = ARRAY_SIZE(kscan_resources),
+	.resource       = kscan_resources,
+};
+
+#if defined (CONFIG_MMC_ARMMMCI)
+static u32 mmc_translate_vdd(struct device *dev, unsigned int vdd,
+		unsigned char mode)
+{
+	/* Only on and off are supported */
+	if (vdd != 0)
+		gpio_set_value(MMC_PWR_ENABLE_GPIO,1);
+	else
+		gpio_set_value(MMC_PWR_ENABLE_GPIO,0);
+
+	return 0;
+}
+
+/*
+ * Board specific MMC driver data
+ */
+struct mmci_platform_data lpc32xx_plat_data = {
+	.ocr_mask       = MMC_VDD_30_31|MMC_VDD_31_32|MMC_VDD_32_33|MMC_VDD_33_34,
+	.vdd_handler	= mmc_translate_vdd,
+	.capabilities   = MMC_CAP_4_BIT_DATA,
+	.gpio_wp        = MMC_WP_GPIO,
+	.gpio_cd        = MMC_CD_GPIO,
+	.cd_invert = true,
+};
+
+/*
+ * SD card controller resources
+ */
+struct amba_device lpc32xx_mmc_device = {
+	.dev = {
+		.coherent_dma_mask = ~0,
+		.init_name = "dev:mmc0",
+		.platform_data = &lpc32xx_plat_data,
+	},
+	.res = {
+		.start = LPC32XX_SD_BASE,
+		.end = (LPC32XX_SD_BASE + SZ_4K - 1),
+		.flags = IORESOURCE_MEM,
+	},
+	.dma_mask = ~0,
+	.irq = {IRQ_LPC32XX_SD0, IRQ_LPC32XX_SD1},
+};
+#endif
+
+
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+/*
+ * Board specific NAND setup data
+ */
+static int nandwp_enable(int enable)
+{
+	if (enable != 0)
+		gpio_set_value(NAND_WP_GPIO,0);
+	else
+		gpio_set_value(NAND_WP_GPIO,1);
+
+	return 1;
+}
+
+#define BLK_SIZE (512 * 32)
+static struct mtd_partition phy3250_nand_partition[] = {
+	{
+		.name   = "phy3250-boot",
+		.offset = 0,
+		.size   = (BLK_SIZE * 25)
+	},
+	{
+		.name   = "phy3250-uboot",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = (BLK_SIZE * 100)
+	},
+	{
+		.name   = "phy3250-ubt-prms",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = (BLK_SIZE * 4)
+	},
+	{
+		.name   = "phy3250-kernel",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = (BLK_SIZE * 256)
+	},
+	{
+		.name   = "phy3250-rootfs",
+		.offset = MTDPART_OFS_APPEND,
+		.size   = MTDPART_SIZ_FULL
+	},
+};
+
+static struct mtd_partition * phy3250_nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(phy3250_nand_partition);
+	return phy3250_nand_partition;
+}
+
+static struct lpc32XX_nand_cfg lpc32xx_nandcfg =
+{
+	.wdr_clks = 14,
+	.wwidth = 40000000,
+	.whold = 100000000,
+	.wsetup = 100000000,
+	.rdr_clks = 14,
+	.rwidth = 40000000,
+	.rhold = 66666666,
+	.rsetup = 100000000,
+	.use_bbt = true,
+	.polled_completion = false,
+	.enable_write_prot = nandwp_enable,
+	.partition_info = phy3250_nand_partitions,
+};
+
+/*
+ * SLC NAND resources
+ */
+static struct resource slc_nand_resources[] = {
+	[0] = {
+		.start  = LPC32XX_SLC_BASE,
+		.end    = LPC32XX_SLC_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+	[1] = {
+		.start  = IRQ_LPC32XX_FLASH,
+		.end    = IRQ_LPC32XX_FLASH,
+		.flags  = IORESOURCE_IRQ,
+	},
+};
+
+static u64 lpc32xx_slc_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_slc_nand_device = {
+	.name = "lpc32xx-nand",
+	.id = 0,
+	.dev = {
+		.platform_data = &lpc32xx_nandcfg,
+		.dma_mask = &lpc32xx_slc_dma_mask,
+		.coherent_dma_mask = ~0UL,
+	},
+	.num_resources  = ARRAY_SIZE(slc_nand_resources),
+	.resource = slc_nand_resources,
+};
+#endif
+
+/*
+ * Network Support
+ */
+static struct lpc_net_cfg lpc32xx_netdata =
+{
+	.phy_irq        = -1,
+	.phy_mask       = 0xFFFFFFF0,
+};
+
+static struct resource net_resources[] = {
+	[0] = {
+		.start  = LPC32XX_ETHERNET_BASE,
+		.end    = LPC32XX_ETHERNET_BASE + SZ_4K - 1,
+		.flags  = IORESOURCE_MEM,
+	},
+
+	[1] = {
+		.start  = IRQ_LPC32XX_ETHERNET,
+		.end    = IRQ_LPC32XX_ETHERNET,
+		.flags  = IORESOURCE_IRQ,
+	},
+
+};
+
+static u64 lpc32xx_mac_dma_mask = 0xffffffffUL;
+static struct platform_device lpc32xx_net_device = {
+	.name           = "lpc-net",
+	.id             = 0,
+	.dev            = {
+		.dma_mask = &lpc32xx_mac_dma_mask,
+		.coherent_dma_mask = 0xffffffffUL,
+		.platform_data  = &lpc32xx_netdata,
+	},
+	.num_resources  = ARRAY_SIZE(net_resources),
+	.resource       = net_resources,
+};
+
 static struct platform_device *phy3250_devs[] __initdata = {
 	&lpc32xx_i2c0_device,
 	&lpc32xx_i2c1_device,
 	&lpc32xx_i2c2_device,
 	&lpc32xx_watchdog_device,
 	&lpc32xx_gpio_led_device,
+	&lpc32xx_rtc_device,
+	&lpc32xx_tsc_device,
+	&lpc32xx_kscan_device,
+	&lpc32xx_net_device,
+#if defined(CONFIG_MTD_NAND_SLC_LPC32XX)
+	&lpc32xx_slc_nand_device,
+#endif
+#if defined(CONFIG_USB_OHCI_HCD)
+	&lpc32xx_ohci_device,
+#endif
+#if defined(CONFIG_USB_GADGET_LPC32XX)
+	&lpc32xx_usbd_device,
+#endif
+	&lpc32xx_i2s_device,
+	&lpc32xx_asoc_plat_device,
 };
 
 static struct amba_device *amba_devs[] __initdata = {
 	&lpc32xx_clcd_device,
 	&lpc32xx_ssp0_device,
+#if defined(CONFIG_MMC_ARMMMCI)
+	&lpc32xx_mmc_device,
+#endif
 };
 
 /*
@@ -301,6 +556,13 @@ static void __init phy3250_board_init(void)
 		printk(KERN_ERR "Error setting gpio %u to output",
 			SPI0_CS_GPIO);
 
+	if (gpio_request(MMC_PWR_ENABLE_GPIO, "mmc_power_en"))
+		printk(KERN_ERR "Error requesting gpio %u",
+				MMC_PWR_ENABLE_GPIO);
+	else if (gpio_direction_output(MMC_PWR_ENABLE_GPIO, 1))
+		printk(KERN_ERR "Error setting gpio %u to output",
+				MMC_PWR_ENABLE_GPIO);
+
 	/* Setup network interface for RMII mode */
 	tmp = __raw_readl(LPC32XX_CLKPWR_MACCLK_CTRL);
 	tmp &= ~LPC32XX_CLKPWR_MACCTRL_PINS_MSK;
@@ -342,6 +604,12 @@ static void __init phy3250_board_init(void)
 	 * here. However, we don't want to enable them if the peripheral
 	 * isn't included in the image
 	 */
+#if defined(CONFIG_MMC_ARMMMCI)
+	tmp = __raw_readl(LPC32XX_CLKPWR_MS_CTRL);
+	tmp |= LPC32XX_CLKPWR_MSCARD_SDCARD_EN | LPC32XX_CLKPWR_MSCARD_MSDIO_PU_EN;
+	__raw_writel(tmp, LPC32XX_CLKPWR_MS_CTRL);
+#endif
+
 #ifdef CONFIG_FB_ARMCLCD
 	tmp = __raw_readl(LPC32XX_CLKPWR_LCDCLK_CTRL);
 	__raw_writel((tmp | LPC32XX_CLKPWR_LCDCTRL_CLK_EN),
@@ -381,6 +649,51 @@ static int __init lpc32xx_display_uid(void)
 }
 arch_initcall(lpc32xx_display_uid);
 
+/*
+ * Example code for setting up the BTN1 button (on GPI3) for system
+ * wakeup and IRQ support. This will allow the GPI3 input to wake
+ * up the system on a low edge. Edge based interrupts won't be
+ * registered in the interrupt controller when the system is asleep,
+ * although they will be registered in the event manager. For this,
+ * reason, a level based interrupt state is recommended for GPIOs when
+ * using IRQ and wakeup from GPI edge state.
+ *
+ */
+#define BTN1_GPIO		LPC32XX_GPIO(LPC32XX_GPI_P3_GRP, 3)
+static irqreturn_t phy3250_btn1_irq(int irq, void *dev)
+{
+	printk(KERN_INFO "GPIO IRQ!\n");
+
+	return IRQ_HANDLED;
+}
+
+static int __init phy3250_button_setup(void)
+{
+	int ret;
+
+	if (gpio_request(BTN1_GPIO, "Button 1")) {
+		printk(KERN_ERR "Error requesting gpio %u", BTN1_GPIO);
+		return 0;
+	}
+
+	/*
+	 * Wakeup/irq on low edge - the wakeup state will use the same
+	 * state as the IRQ edge state.
+	 */
+	irq_set_irq_type(IRQ_LPC32XX_GPI_03, IRQ_TYPE_EDGE_FALLING);
+	ret = request_irq(IRQ_LPC32XX_GPI_03, phy3250_btn1_irq,
+		IRQF_DISABLED, "gpio_btn1_irq", NULL);
+	if (ret < 0) {
+		printk(KERN_ERR "Can't request interrupt\n");
+		return 0;
+	}
+
+	enable_irq_wake(IRQ_LPC32XX_GPI_03);
+
+	return 1;
+}
+device_initcall(phy3250_button_setup);
+
 MACHINE_START(PHY3250, "Phytec 3250 board with the LPC3250 Microcontroller")
 	/* Maintainer: Kevin Wells, NXP Semiconductors */
 	.atag_offset	= 0x100,
@@ -390,3 +703,13 @@ MACHINE_START(PHY3250, "Phytec 3250 board with the LPC3250 Microcontroller")
 	.init_machine	= phy3250_board_init,
 	.restart	= lpc23xx_restart,
 MACHINE_END
+
+/* For backwards compatibility with older bootloaders only */
+MACHINE_START(LPC3XXX, "Phytec 3250 board with the LPC3250 Microcontroller")
+	/* Maintainer: Kevin Wells, NXP Semiconductors */
+	.boot_params	= 0x80000100,
+	.map_io		= lpc32xx_map_io,
+	.init_irq	= lpc32xx_init_irq,
+	.timer		= &lpc32xx_timer,
+	.init_machine	= phy3250_board_init,
+MACHINE_END
diff --git a/arch/arm/mach-lpc32xx/pm.c b/arch/arm/mach-lpc32xx/pm.c
index b9c8059..98305d1 100644
--- a/arch/arm/mach-lpc32xx/pm.c
+++ b/arch/arm/mach-lpc32xx/pm.c
@@ -64,9 +64,11 @@
  *  Suspend mode is exited
  */
 
+#include <linux/pm.h>
 #include <linux/suspend.h>
 #include <linux/io.h>
 #include <linux/slab.h>
+#include <linux/delay.h>
 
 #include <asm/cacheflush.h>
 
@@ -76,25 +78,11 @@
 #include "clock.h"
 
 #define TEMP_IRAM_AREA  IO_ADDRESS(LPC32XX_IRAM_BASE)
+static void *iram_swap_area;
+static int (*lpc32xx_suspend_ptr) (void);
 
-/*
- * Both STANDBY and MEM suspend states are handled the same with no
- * loss of CPU or memory state
- */
-static int lpc32xx_pm_enter(suspend_state_t state)
+static inline int lpc32xx_suspend(void)
 {
-	int (*lpc32xx_suspend_ptr) (void);
-	void *iram_swap_area;
-
-	/* Allocate some space for temporary IRAM storage */
-	iram_swap_area = kmalloc(lpc32xx_sys_suspend_sz, GFP_KERNEL);
-	if (!iram_swap_area) {
-		printk(KERN_ERR
-		       "PM Suspend: cannot allocate memory to save portion "
-			"of SRAM\n");
-		return -ENOMEM;
-	}
-
 	/* Backup a small area of IRAM used for the suspend code */
 	memcpy(iram_swap_area, (void *) TEMP_IRAM_AREA,
 		lpc32xx_sys_suspend_sz);
@@ -106,25 +94,50 @@ static int lpc32xx_pm_enter(suspend_state_t state)
 	 */
 	memcpy((void *) TEMP_IRAM_AREA, &lpc32xx_sys_suspend,
 		lpc32xx_sys_suspend_sz);
+	flush_cache_all();
 	flush_icache_range((unsigned long)TEMP_IRAM_AREA,
 		(unsigned long)(TEMP_IRAM_AREA) + lpc32xx_sys_suspend_sz);
 
 	/* Transfer to suspend code in IRAM */
-	lpc32xx_suspend_ptr = (void *) TEMP_IRAM_AREA;
-	flush_cache_all();
 	(void) lpc32xx_suspend_ptr();
 
 	/* Restore original IRAM contents */
 	memcpy((void *) TEMP_IRAM_AREA, iram_swap_area,
 		lpc32xx_sys_suspend_sz);
 
-	kfree(iram_swap_area);
-
 	return 0;
 }
 
+static int lpc32xx_pm_enter(suspend_state_t state)
+{
+	int ret = 0;
+
+	lpc32xx_irq_suspend(state);
+
+	switch (state)
+	{
+		case PM_SUSPEND_STANDBY:
+			asm("mcr p15, 0, r0, c7, c0, 4");
+			break;
+		case PM_SUSPEND_MEM:
+			ret = lpc32xx_suspend();
+			break;
+	}
+
+	lpc32xx_irq_resume(state);
+
+	return ret;
+}
+
+static int lpc32xx_pm_valid(suspend_state_t state)
+{
+	return (state == PM_SUSPEND_STANDBY) ||
+	       (state == PM_SUSPEND_MEM);
+}
+
+
 static const struct platform_suspend_ops lpc32xx_pm_ops = {
-	.valid	= suspend_valid_only_mem,
+	.valid	= lpc32xx_pm_valid,
 	.enter	= lpc32xx_pm_enter,
 };
 
@@ -134,11 +147,21 @@ static const struct platform_suspend_ops lpc32xx_pm_ops = {
 static int __init lpc32xx_pm_init(void)
 {
 	/*
-	 * Setup SDRAM self-refresh clock to automatically disable o
+	 * Setup SDRAM self-refresh clock to automatically disable on
 	 * start of self-refresh. This only needs to be done once.
 	 */
 	__raw_writel(__raw_readl(EMC_CTRL_REG) | EMC_SRMMC, EMC_CTRL_REG);
 
+	/* Allocate some space for temporary IRAM storage */
+	iram_swap_area = kmalloc(lpc32xx_sys_suspend_sz, GFP_KERNEL);
+	if (!iram_swap_area) {
+		printk(KERN_ERR
+		       "PM Suspend: cannot allocate memory to save portion "
+			"of SRAM\n");
+		return -ENOMEM;
+	}
+
+	lpc32xx_suspend_ptr = (void *) TEMP_IRAM_AREA;
 	suspend_set_ops(&lpc32xx_pm_ops);
 
 	return 0;
diff --git a/arch/arm/mach-lpc32xx/serial.c b/arch/arm/mach-lpc32xx/serial.c
index f273528..7b3fc03 100644
--- a/arch/arm/mach-lpc32xx/serial.c
+++ b/arch/arm/mach-lpc32xx/serial.c
@@ -27,6 +27,7 @@
 
 #include <mach/hardware.h>
 #include <mach/platform.h>
+#include <mach/board.h>
 #include "common.h"
 
 #define LPC32XX_SUART_FIFO_SIZE	64
@@ -38,7 +39,6 @@ static struct plat_serial8250_port serial_std_platform_data[] = {
 		.membase        = io_p2v(LPC32XX_UART5_BASE),
 		.mapbase        = LPC32XX_UART5_BASE,
 		.irq		= IRQ_LPC32XX_UART_IIR5,
-		.uartclk	= LPC32XX_MAIN_OSC_FREQ,
 		.regshift	= 2,
 		.iotype		= UPIO_MEM32,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_BUGGY_UART |
@@ -50,7 +50,6 @@ static struct plat_serial8250_port serial_std_platform_data[] = {
 		.membase	= io_p2v(LPC32XX_UART3_BASE),
 		.mapbase        = LPC32XX_UART3_BASE,
 		.irq		= IRQ_LPC32XX_UART_IIR3,
-		.uartclk	= LPC32XX_MAIN_OSC_FREQ,
 		.regshift	= 2,
 		.iotype		= UPIO_MEM32,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_BUGGY_UART |
@@ -62,7 +61,6 @@ static struct plat_serial8250_port serial_std_platform_data[] = {
 		.membase	= io_p2v(LPC32XX_UART4_BASE),
 		.mapbase        = LPC32XX_UART4_BASE,
 		.irq		= IRQ_LPC32XX_UART_IIR4,
-		.uartclk	= LPC32XX_MAIN_OSC_FREQ,
 		.regshift	= 2,
 		.iotype		= UPIO_MEM32,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_BUGGY_UART |
@@ -74,7 +72,6 @@ static struct plat_serial8250_port serial_std_platform_data[] = {
 		.membase	= io_p2v(LPC32XX_UART6_BASE),
 		.mapbase        = LPC32XX_UART6_BASE,
 		.irq		= IRQ_LPC32XX_UART_IIR6,
-		.uartclk	= LPC32XX_MAIN_OSC_FREQ,
 		.regshift	= 2,
 		.iotype		= UPIO_MEM32,
 		.flags		= UPF_BOOT_AUTOCONF | UPF_BUGGY_UART |
@@ -89,45 +86,50 @@ struct uartinit {
 	u32 ck_mode_mask;
 	void __iomem *pdiv_clk_reg;
 	resource_size_t mapbase;
+	bool enabled;
 };
 
 static struct uartinit uartinit_data[] __initdata = {
-#ifdef CONFIG_ARCH_LPC32XX_UART5_SELECT
 	{
 		.uart_ck_name = "uart5_ck",
 		.ck_mode_mask =
 			LPC32XX_UART_CLKMODE_LOAD(LPC32XX_UART_CLKMODE_ON, 5),
 		.pdiv_clk_reg = LPC32XX_CLKPWR_UART5_CLK_CTRL,
 		.mapbase = LPC32XX_UART5_BASE,
-	},
+#ifdef CONFIG_ARCH_LPC32XX_UART5_SELECT
+		.enabled = true,
 #endif
-#ifdef CONFIG_ARCH_LPC32XX_UART3_SELECT
+	},
 	{
 		.uart_ck_name = "uart3_ck",
 		.ck_mode_mask =
 			LPC32XX_UART_CLKMODE_LOAD(LPC32XX_UART_CLKMODE_ON, 3),
 		.pdiv_clk_reg = LPC32XX_CLKPWR_UART3_CLK_CTRL,
 		.mapbase = LPC32XX_UART3_BASE,
-	},
+#ifdef CONFIG_ARCH_LPC32XX_UART3_SELECT
+		.enabled = true,
 #endif
-#ifdef CONFIG_ARCH_LPC32XX_UART4_SELECT
+	},
 	{
 		.uart_ck_name = "uart4_ck",
 		.ck_mode_mask =
 			LPC32XX_UART_CLKMODE_LOAD(LPC32XX_UART_CLKMODE_ON, 4),
 		.pdiv_clk_reg = LPC32XX_CLKPWR_UART4_CLK_CTRL,
 		.mapbase = LPC32XX_UART4_BASE,
-	},
+#ifdef CONFIG_ARCH_LPC32XX_UART4_SELECT
+		.enabled = true,
 #endif
-#ifdef CONFIG_ARCH_LPC32XX_UART6_SELECT
+	},
 	{
 		.uart_ck_name = "uart6_ck",
 		.ck_mode_mask =
 			LPC32XX_UART_CLKMODE_LOAD(LPC32XX_UART_CLKMODE_ON, 6),
 		.pdiv_clk_reg = LPC32XX_CLKPWR_UART6_CLK_CTRL,
 		.mapbase = LPC32XX_UART6_BASE,
-	},
+#ifdef CONFIG_ARCH_LPC32XX_UART6_SELECT
+		.enabled = true,
 #endif
+	},
 };
 
 static struct platform_device serial_std_platform_device = {
@@ -138,64 +140,147 @@ static struct platform_device serial_std_platform_device = {
 	},
 };
 
+/* High speed serial ports */
+static struct lpc32xx_hsuart_port serial_hspd_platform_data[] = {
+#ifdef CONFIG_ARCH_LPC32XX_HSUART1_SELECT
+	{
+		.port 					= {
+			.membase        = io_p2v(LPC32XX_HS_UART1_BASE),
+			.mapbase        = LPC32XX_HS_UART1_BASE,
+			.irq            = IRQ_LPC32XX_UART_IIR1,
+			.regshift       = 2,
+			.iotype         = UPIO_MEM32,
+			.flags          = UPF_BOOT_AUTOCONF,
+		},
+		.fbit_sam       = 20,
+	},
+#endif
+#ifdef CONFIG_ARCH_LPC32XX_HSUART2_SELECT
+	{
+		.port 					= {
+			.membase        = io_p2v(LPC32XX_HS_UART2_BASE),
+			.mapbase        = LPC32XX_HS_UART2_BASE,
+			.irq            = IRQ_LPC32XX_UART_IIR2,
+			.regshift       = 2,
+			.iotype         = UPIO_MEM32,
+			.flags          = UPF_BOOT_AUTOCONF,
+		},
+		.fbit_sam       = 20,
+	},
+#endif
+#ifdef CONFIG_ARCH_LPC32XX_HSUART7_SELECT
+	{
+		.port 					= {
+			.membase        = io_p2v(LPC32XX_HS_UART7_BASE),
+			.mapbase        = LPC32XX_HS_UART7_BASE,
+			.irq            = IRQ_LPC32XX_UART_IIR7,
+			.regshift       = 2,
+			.iotype         = UPIO_MEM32,
+			.flags          = UPF_BOOT_AUTOCONF,
+		},
+		.fbit_sam       = 20,
+	},
+#endif
+	{ },
+};
+
+static struct platform_device serial_hspd_platform_device = {
+	.name                   = "lpc32xx_hsuart",
+	.id                     = 0,
+	.dev                    = {
+		.platform_data  = serial_hspd_platform_data,
+	},
+};
+
 static struct platform_device *lpc32xx_serial_devs[] __initdata = {
 	&serial_std_platform_device,
+	&serial_hspd_platform_device,
 };
 
 void __init lpc32xx_serial_init(void)
 {
-	u32 tmp, clkmodes = 0;
+	u32 tmp, tmpclk, clkmodes = 0, clkmodesdone = 0;
 	struct clk *clk;
-	unsigned int puart;
-	int i, j;
-
-	/* UART clocks are off, let clock driver manage them */
-	__raw_writel(0, LPC32XX_CLKPWR_UART_CLK_CTRL);
+	resource_size_t puart;
+	int i, j, k = 0;
 
+	/*
+	 * For each standard UART, enable the UART clock, and force
+	 * FIFO flush. This works around a HW bug with the 8250 where
+	 * the FIFOs may not work correctly. This should be done even if
+	 * the standard UARTs are not used. The clocks will be disabled
+	 * when done.
+	 */
 	for (i = 0; i < ARRAY_SIZE(uartinit_data); i++) {
 		clk = clk_get(NULL, uartinit_data[i].uart_ck_name);
 		if (!IS_ERR(clk)) {
 			clk_enable(clk);
-			serial_std_platform_data[i].uartclk =
-				clk_get_rate(clk);
+			tmpclk = clk_get_rate(clk);
+
+			/*
+			 * Fall back on main osc rate if clock rate return
+			 * fails
+			 */
+			if (tmpclk == 0)
+				tmpclk = LPC32XX_MAIN_OSC_FREQ;
+
+			/* pre-UART clock divider set to 1 */
+			__raw_writel(0x0101, uartinit_data[i].pdiv_clk_reg);
+
+			/* Setup UART clock modes for all UART to always on */
+			clkmodes = uartinit_data[i].ck_mode_mask;
+			__raw_writel(clkmodes, LPC32XX_UARTCTL_CLKMODE);
+
+			/*
+			 * Force a flush of the RX FIFOs to work around a
+			 * HW bug
+			 */
+			puart = uartinit_data[i].mapbase;
+			__raw_writel(0xC1, LPC32XX_UART_IIR_FCR(puart));
+			__raw_writel(0x00, LPC32XX_UART_DLL_FIFO(puart));
+			j = LPC32XX_SUART_FIFO_SIZE;
+			while (j--)
+				tmp = __raw_readl(
+					LPC32XX_UART_DLL_FIFO(puart));
+			__raw_writel(0, LPC32XX_UART_IIR_FCR(puart));
+
+			/*
+			 * The 8250 serial drivers do not use any type of
+			 * clock management, so the clocks need to be
+			 * pre-enabled here before the 8250 driver attempts
+			 * to access the peripherals. If a UART is enabled,
+			 * just leave the clock on.
+			 */
+			if (uartinit_data[i].enabled) {
+				clkmodesdone |= clkmodes;
+				serial_std_platform_data[k++].uartclk = tmpclk;
+			} else {
+				clk_disable(clk);
+				clk_put(clk);
+			}
 		}
+	}
 
-		/* Fall back on main osc rate if clock rate return fails */
-		if (serial_std_platform_data[i].uartclk == 0)
-			serial_std_platform_data[i].uartclk =
-				LPC32XX_MAIN_OSC_FREQ;
-
-		/* Setup UART clock modes for all UARTs, disable autoclock */
-		clkmodes |= uartinit_data[i].ck_mode_mask;
-
-		/* pre-UART clock divider set to 1 */
-		__raw_writel(0x0101, uartinit_data[i].pdiv_clk_reg);
-
-		/*
-		 * Force a flush of the RX FIFOs to work around a
-		 * HW bug
-		 */
-		puart = uartinit_data[i].mapbase;
-		__raw_writel(0xC1, LPC32XX_UART_IIR_FCR(puart));
-		__raw_writel(0x00, LPC32XX_UART_DLL_FIFO(puart));
-		j = LPC32XX_SUART_FIFO_SIZE;
-		while (j--)
-			tmp = __raw_readl(
-				LPC32XX_UART_DLL_FIFO(puart));
-		__raw_writel(0, LPC32XX_UART_IIR_FCR(puart));
+	/* Enable clocks only for enabled UARTs */
+	__raw_writel(clkmodesdone, LPC32XX_UARTCTL_CLKMODE);
+
+	/*
+	 * Get current PCLK rate and use it for the base clock for all the
+	 * high speed UARTS
+	 */
+	tmpclk = 0;
+	clk = clk_get(NULL, "pclk_ck");
+	if (!IS_ERR(clk)) {
+		tmpclk = clk_get_rate(clk);
+		clk_put(clk);
 	}
+	if (!tmpclk)
+		tmpclk = LPC32XX_MAIN_OSC_FREQ;
 
-	/* This needs to be done after all UART clocks are setup */
-	__raw_writel(clkmodes, LPC32XX_UARTCTL_CLKMODE);
-	for (i = 0; i < ARRAY_SIZE(uartinit_data); i++) {
-		/* Force a flush of the RX FIFOs to work around a HW bug */
-		puart = serial_std_platform_data[i].mapbase;
-		__raw_writel(0xC1, LPC32XX_UART_IIR_FCR(puart));
-		__raw_writel(0x00, LPC32XX_UART_DLL_FIFO(puart));
-		j = LPC32XX_SUART_FIFO_SIZE;
-		while (j--)
-			tmp = __raw_readl(LPC32XX_UART_DLL_FIFO(puart));
-		__raw_writel(0, LPC32XX_UART_IIR_FCR(puart));
+        /* Setup of HSUART devices */
+        for (i = 0; i < ARRAY_SIZE(serial_hspd_platform_data) - 1; i++) {
+                serial_hspd_platform_data[i].port.line = i;
+                serial_hspd_platform_data[i].port.uartclk = tmpclk;
 	}
 
 	/* Disable UART5->USB transparent mode or USB won't work */
diff --git a/arch/arm/mach-lpc32xx/suspend.S b/arch/arm/mach-lpc32xx/suspend.S
index 374f9f0..757fd00 100644
--- a/arch/arm/mach-lpc32xx/suspend.S
+++ b/arch/arm/mach-lpc32xx/suspend.S
@@ -32,7 +32,8 @@
 #define LPC32XX_CLKPWR_HCLK_DIV_OFFS	0x40
 #define LPC32XX_CLKPWR_HCLKPLL_CTRL_OFFS 0x58
 
-#define CLKPWR_PCLK_DIV_MASK		0xFFFFFE7F
+#define CLKPWR_PCLK_DIV_MASK1		0xFFFFFF83
+#define CLKPWR_PCLK_DIV_MASK2		0xFFFFFE03
 
 	.text
 
@@ -78,15 +79,19 @@ ENTRY(lpc32xx_sys_suspend)
 	cmp	WORK2_REG, #LPC32XX_EMC_STATUS_SELF_RFSH
 	bne	3b @ Branch until self-refresh mode starts
 
+	@ Set PCLK divider to 1 prior to direct-run mode entry
+	ldr	SAVED_HCLK_DIV_REG, [CLKPWRBASE_REG,\
+		#LPC32XX_CLKPWR_HCLK_DIV_OFFS]
+	and	WORK2_REG, SAVED_HCLK_DIV_REG, #CLKPWR_PCLK_DIV_MASK1
+	str	WORK2_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_HCLK_DIV_OFFS]
+
 	@ Enter direct-run mode from run mode
 	bic	WORK1_REG, WORK1_REG, #LPC32XX_CLKPWR_SELECT_RUN_MODE
 	str	WORK1_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_PWR_CTRL_OFFS]
 
 	@ Safe disable of DRAM clock in EMC block, prevents DDR sync
 	@ issues on restart
-	ldr	SAVED_HCLK_DIV_REG, [CLKPWRBASE_REG,\
-		#LPC32XX_CLKPWR_HCLK_DIV_OFFS]
-	and	WORK2_REG, SAVED_HCLK_DIV_REG, #CLKPWR_PCLK_DIV_MASK
+	and	WORK2_REG, SAVED_HCLK_DIV_REG, #CLKPWR_PCLK_DIV_MASK2
 	str	WORK2_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_HCLK_DIV_OFFS]
 
 	@ Save HCLK PLL state and disable HCLK PLL
@@ -98,20 +103,22 @@ ENTRY(lpc32xx_sys_suspend)
 	@ Enter stop mode until an enabled event occurs
 	orr	WORK1_REG, WORK1_REG, #LPC32XX_CLKPWR_STOP_MODE_CTRL
 	str	WORK1_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_PWR_CTRL_OFFS]
+
 	.rept 9
 	nop
 	.endr
 
-	@ Clear stop status
+	@ Clear stop status now
 	bic	WORK1_REG, WORK1_REG, #LPC32XX_CLKPWR_STOP_MODE_CTRL
+	str	WORK1_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_PWR_CTRL_OFFS]
 
 	@ Restore original HCLK PLL value and wait for PLL lock
 	str	SAVED_HCLK_PLL_REG, [CLKPWRBASE_REG,\
 		#LPC32XX_CLKPWR_HCLKPLL_CTRL_OFFS]
 4:
 	ldr	WORK2_REG, [CLKPWRBASE_REG, #LPC32XX_CLKPWR_HCLKPLL_CTRL_OFFS]
-	and	WORK2_REG, WORK2_REG, #LPC32XX_CLKPWR_HCLKPLL_PLL_STS
-	bne	4b
+	ands WORK2_REG, WORK2_REG, #LPC32XX_CLKPWR_HCLKPLL_PLL_STS
+	beq 4b
 
 	@ Re-enter run mode with self-refresh flag cleared, but no DRAM
 	@ update yet. DRAM is still in self-refresh
@@ -132,8 +139,8 @@ ENTRY(lpc32xx_sys_suspend)
 	@ Wait for EMC to clear self-refresh mode
 5:
 	ldr	WORK2_REG, [EMCBASE_REG, #LPC32XX_EMC_STATUS_OFFS]
-	and	WORK2_REG, WORK2_REG, #LPC32XX_EMC_STATUS_SELF_RFSH
-	bne	5b @ Branch until self-refresh has exited
+	ands WORK2_REG, WORK2_REG, #LPC32XX_EMC_STATUS_SELF_RFSH
+	bne 5b @ Branch until self-refresh has exited
 
 	@ restore regs and return
 	adr	r0, tmp_stack
diff --git a/arch/arm/mach-lpc32xx/timer.c b/arch/arm/mach-lpc32xx/timer.c
index b42c909b..c40667c 100644
--- a/arch/arm/mach-lpc32xx/timer.c
+++ b/arch/arm/mach-lpc32xx/timer.c
@@ -34,11 +34,11 @@
 static int lpc32xx_clkevt_next_event(unsigned long delta,
     struct clock_event_device *dev)
 {
-	__raw_writel(LCP32XX_TIMER_CNTR_TCR_RESET,
-		LCP32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
-	__raw_writel(delta, LCP32XX_TIMER_PR(LPC32XX_TIMER0_BASE));
-	__raw_writel(LCP32XX_TIMER_CNTR_TCR_EN,
-		LCP32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_TCR_RESET,
+		LPC32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
+	__raw_writel(delta, LPC32XX_TIMER_PR(LPC32XX_TIMER0_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_TCR_EN,
+		LPC32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
 
 	return 0;
 }
@@ -58,7 +58,7 @@ static void lpc32xx_clkevt_mode(enum clock_event_mode mode,
 		 * disable the timer to wait for the first call to
 		 * set_next_event().
 		 */
-		__raw_writel(0, LCP32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
+		__raw_writel(0, LPC32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
 		break;
 
 	case CLOCK_EVT_MODE_UNUSED:
@@ -81,8 +81,8 @@ static irqreturn_t lpc32xx_timer_interrupt(int irq, void *dev_id)
 	struct clock_event_device *evt = &lpc32xx_clkevt;
 
 	/* Clear match */
-	__raw_writel(LCP32XX_TIMER_CNTR_MTCH_BIT(0),
-		LCP32XX_TIMER_IR(LPC32XX_TIMER0_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_MTCH_BIT(0),
+		LPC32XX_TIMER_IR(LPC32XX_TIMER0_BASE));
 
 	evt->event_handler(evt);
 
@@ -128,14 +128,14 @@ static void __init lpc32xx_timer_init(void)
 	clkrate = clkrate / clk_get_pclk_div();
 
 	/* Initial timer setup */
-	__raw_writel(0, LCP32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
-	__raw_writel(LCP32XX_TIMER_CNTR_MTCH_BIT(0),
-		LCP32XX_TIMER_IR(LPC32XX_TIMER0_BASE));
-	__raw_writel(1, LCP32XX_TIMER_MR0(LPC32XX_TIMER0_BASE));
-	__raw_writel(LCP32XX_TIMER_CNTR_MCR_MTCH(0) |
-		LCP32XX_TIMER_CNTR_MCR_STOP(0) |
-		LCP32XX_TIMER_CNTR_MCR_RESET(0),
-		LCP32XX_TIMER_MCR(LPC32XX_TIMER0_BASE));
+	__raw_writel(0, LPC32XX_TIMER_TCR(LPC32XX_TIMER0_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_MTCH_BIT(0),
+		LPC32XX_TIMER_IR(LPC32XX_TIMER0_BASE));
+	__raw_writel(1, LPC32XX_TIMER_MR0(LPC32XX_TIMER0_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_MCR_MTCH(0) |
+		LPC32XX_TIMER_CNTR_MCR_STOP(0) |
+		LPC32XX_TIMER_CNTR_MCR_RESET(0),
+		LPC32XX_TIMER_MCR(LPC32XX_TIMER0_BASE));
 
 	/* Setup tick interrupt */
 	setup_irq(IRQ_LPC32XX_TIMER0, &lpc32xx_timer_irq);
@@ -151,14 +151,14 @@ static void __init lpc32xx_timer_init(void)
 	clockevents_register_device(&lpc32xx_clkevt);
 
 	/* Use timer1 as clock source. */
-	__raw_writel(LCP32XX_TIMER_CNTR_TCR_RESET,
-		LCP32XX_TIMER_TCR(LPC32XX_TIMER1_BASE));
-	__raw_writel(0, LCP32XX_TIMER_PR(LPC32XX_TIMER1_BASE));
-	__raw_writel(0, LCP32XX_TIMER_MCR(LPC32XX_TIMER1_BASE));
-	__raw_writel(LCP32XX_TIMER_CNTR_TCR_EN,
-		LCP32XX_TIMER_TCR(LPC32XX_TIMER1_BASE));
-
-	clocksource_mmio_init(LCP32XX_TIMER_TC(LPC32XX_TIMER1_BASE),
+	__raw_writel(LPC32XX_TIMER_CNTR_TCR_RESET,
+		LPC32XX_TIMER_TCR(LPC32XX_TIMER1_BASE));
+	__raw_writel(0, LPC32XX_TIMER_PR(LPC32XX_TIMER1_BASE));
+	__raw_writel(0, LPC32XX_TIMER_MCR(LPC32XX_TIMER1_BASE));
+	__raw_writel(LPC32XX_TIMER_CNTR_TCR_EN,
+		LPC32XX_TIMER_TCR(LPC32XX_TIMER1_BASE));
+
+	clocksource_mmio_init(LPC32XX_TIMER_TC(LPC32XX_TIMER1_BASE),
 		"lpc32xx_clksrc", clkrate, 300, 32, clocksource_mmio_readl_up);
 }
 
diff --git a/arch/arm/vfp/vfpmodule.c b/arch/arm/vfp/vfpmodule.c
index 8ea07e4..6ad9258 100644
--- a/arch/arm/vfp/vfpmodule.c
+++ b/arch/arm/vfp/vfpmodule.c
@@ -463,8 +463,12 @@ static int vfp_pm_suspend(void)
 
 static void vfp_pm_resume(void)
 {
+	unsigned int cpu_arch = cpu_architecture();
+
 	/* ensure we have access to the vfp */
-	vfp_enable(NULL);
+	if (cpu_arch >= CPU_ARCH_ARMv6) {
+		vfp_enable(NULL);
+	}
 
 	/* and disable it to ensure the next usage restores the state */
 	fmxr(FPEXC, fmrx(FPEXC) & ~FPEXC_EN);
diff --git a/drivers/i2c/busses/i2c-pnx.c b/drivers/i2c/busses/i2c-pnx.c
index eb8ad53..156008a 100644
--- a/drivers/i2c/busses/i2c-pnx.c
+++ b/drivers/i2c/busses/i2c-pnx.c
@@ -27,7 +27,7 @@
 #include <mach/hardware.h>
 #include <mach/i2c.h>
 
-#define I2C_PNX_TIMEOUT		10 /* msec */
+#define I2C_PNX_TIMEOUT		100 /* msec */
 #define I2C_PNX_SPEED_KHZ	100
 #define I2C_PNX_REGION_SIZE	0x100
 
@@ -305,11 +305,152 @@ static int i2c_pnx_master_rcv(struct i2c_pnx_algo_data *alg_data)
 	return 0;
 }
 
+/* SMBus receive handler, called from ISR */
+static int i2c_pnx_smbus_rx(struct i2c_pnx_algo_data *smbus)
+{
+	struct i2c_pnx_smbus *smb = &smbus->smb;
+	while (!(ioread32(I2C_REG_STS(smbus)) & mstatus_rfe)) {
+		smb->rx_buf[smb->rx_cnt++] =
+			(u8) ioread32(I2C_REG_RX(smbus));
+		dev_dbg(&smbus->adapter.dev, "Rx Char: %02x\n",
+				smb->rx_buf[smb->rx_cnt - 1]);
+
+		/* If Rx char is not length then continue receiving */
+		if ((smb->rx_cnt != 1) ||
+			!(smb->flags & I2C_PNX_SMBUS_BLOCK_RX))
+			continue;
+
+		/* If Received char is length, check for validity */
+		if (unlikely(smb->rx_buf[0] <= 0 &&
+			smb->rx_buf[0] > smb->max_rx_len)) {
+			dev_dbg(&smbus->adapter.dev, "ERR: SMBus received "
+					"invalid transfer length %d from slave"
+					" %#02x during a block transfer.\n",
+					smb->rx_buf[0],
+					smb->slave_addr);
+			smb->ret = -EIO;
+			complete(&smb->complete);
+			smb->flags |= I2C_PNX_SMBUS_NEED_RESET;
+			return 1;
+		}
+
+		/* There is a hardware BUG, that makes receiving
+		 * only length not possible, so we receive length
+		 * and a byte of data, if that is the only byte to
+		 * be received the the transfer must stop right away
+		 **/
+		if (smb->rx_buf[0] == 1) {
+			/* Stop xfer right away */
+			iowrite32(stop_bit, I2C_REG_TX(smbus));
+			iowrite32(ioread32(I2C_REG_CTL(smbus)) &
+					~(mcntrl_drmie | mcntrl_tffie),
+					I2C_REG_CTL(smbus));
+			return 1;
+		}
+
+		dev_dbg(&smbus->adapter.dev, "Set Len:%d\n",
+				smb->rx_buf[0]);
+		smb->len += smb->rx_buf[0] - 1;
+		smb->tx_buf[smb->len - 1] |= stop_bit;
+		iowrite32(ioread32(I2C_REG_CTL(smbus)) |
+				  mcntrl_tffie, I2C_REG_CTL(smbus));
+	}
+	return 0;
+}
+
+/* SMBUs interrupt handler */
+static irqreturn_t i2c_pnx_smbus_isr(int irq, void *dev_id)
+{
+	struct i2c_pnx_algo_data *smbus = dev_id;
+	struct i2c_pnx_smbus *smb = &smbus->smb;
+	u32 stat, ctl;
+	stat = ioread32(I2C_REG_STS(smbus));
+	ctl = ioread32(I2C_REG_CTL(smbus));
+
+	dev_dbg(&smbus->adapter.dev, "ISR: stat = %#08x, "
+			"ctrl = %#08x\r\n", stat, ctl);
+
+	/* Handle Rx data */
+	if (((stat & mstatus_rff) && (ctl & mcntrl_rffie)) ||
+	    (!(stat & mstatus_rfe) && (ctl & mcntrl_daie))) {
+		if (i2c_pnx_smbus_rx(smbus))
+			return IRQ_HANDLED;
+		stat = ioread32(I2C_REG_STS(smbus));
+		ctl = ioread32(I2C_REG_CTL(smbus));
+	}
+
+	/* Handle Transmit */
+	if (((stat & mstatus_drmi) && (ctl & mcntrl_drmie)) ||
+	    (!(stat & mstatus_rff) && (ctl & mcntrl_tffie))) {
+
+		/* Push data into FIFO until we run out of data
+		 * or TX/RX fifo is full
+		 **/
+		for (; (smb->index < smb->len) &&
+		     !(ioread32(I2C_REG_STS(smbus)) &
+				 (mstatus_tff | mstatus_rff));
+		     smb->index++) {
+			iowrite32(smb->tx_buf[smb->index], I2C_REG_TX(smbus));
+			dev_dbg(&smbus->adapter.dev, "Tx Char: %03x\n",
+					smb->tx_buf[smb->index]);
+		}
+
+		/* Stop further transmit if we run out of data */
+		if (smb->index >= smb->len) {
+			iowrite32(ctl & ~(mcntrl_drmie | mcntrl_tffie),
+					I2C_REG_CTL(smbus));
+		}
+		return IRQ_HANDLED;
+	}
+
+	/* Handle Arbitration loss */
+	if (unlikely((stat & mstatus_afi) && (ctl & mcntrl_afie))) {
+		dev_dbg(&smbus->adapter.dev, "Aribitration lost during"
+				" transfer to/from slave addr %02x\r\n",
+				smb->slave_addr);
+		smb->ret = -EAGAIN;
+		complete(&smb->complete);
+		smb->flags |= I2C_PNX_SMBUS_NEED_RESET;
+		/* We are done! */
+		iowrite32(0, I2C_REG_CTL(smbus));
+		return IRQ_HANDLED;
+	}
+
+	/* Handle NACK reception */
+	if (unlikely((stat & mstatus_nai) && (ctl & mcntrl_naie))) {
+		dev_dbg(&smbus->adapter.dev, "Nack received!\n");
+		smb->ret = -EIO;
+		complete(&smb->complete);
+		smb->flags |= I2C_PNX_SMBUS_NEED_RESET;
+		/* We are done! */
+		iowrite32(0, I2C_REG_CTL(smbus));
+		return IRQ_HANDLED;
+	}
+
+	/* Handle Xfer Done */
+	if ((stat & mstatus_tdi) &&
+	    (mcntrl_tdie & ctl)) {
+		dev_dbg(&smbus->adapter.dev, "SMBus Xfer Done!\r\n");
+		/* Transmission is done */
+		smb->ret = 0;
+		complete(&smb->complete);
+		iowrite32(mstatus_tdi, I2C_REG_STS(smbus));
+		iowrite32(0, I2C_REG_CTL(smbus));
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_HANDLED;
+}
+
 static irqreturn_t i2c_pnx_interrupt(int irq, void *dev_id)
 {
 	struct i2c_pnx_algo_data *alg_data = dev_id;
 	u32 stat, ctl;
 
+	/* If it is an SMBUS xfer let another handler do the task */
+	if (alg_data->smb.flags & I2C_PNX_SMBUS_ACTIVE)
+		return i2c_pnx_smbus_isr(irq, dev_id);
+
 	dev_dbg(&alg_data->adapter.dev,
 		"%s(): mstat = %x mctrl = %x, mode = %d\n",
 		__func__,
@@ -430,7 +571,7 @@ static inline void bus_reset_if_active(struct i2c_pnx_algo_data *alg_data)
 }
 
 /**
- * i2c_pnx_xfer - generic transfer entry point
+ * i2c_pnx_xfer - I2C Protocol Transfer routine
  * @adap:		pointer to I2C adapter structure
  * @msgs:		array of messages
  * @num:		number of messages
@@ -443,11 +584,15 @@ i2c_pnx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	struct i2c_msg *pmsg;
 	int rc = 0, completed = 0, i;
 	struct i2c_pnx_algo_data *alg_data = adap->algo_data;
-	u32 stat = ioread32(I2C_REG_STS(alg_data));
+	u32 stat;
+
+	clk_enable(alg_data->clk);
+
+	stat = ioread32(I2C_REG_STS(alg_data));
 
 	dev_dbg(&alg_data->adapter.dev,
 		"%s(): entering: %d messages, stat = %04x.\n",
-		__func__, num, ioread32(I2C_REG_STS(alg_data)));
+		__func__, num, stat);
 
 	bus_reset_if_active(alg_data);
 
@@ -463,6 +608,7 @@ i2c_pnx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 				"%s: 10 bits addr not supported!\n",
 				alg_data->adapter.name);
 			rc = -EINVAL;
+			clk_disable(alg_data->clk);
 			break;
 		}
 
@@ -523,6 +669,8 @@ i2c_pnx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 
 	dev_dbg(&alg_data->adapter.dev, "%s(): exiting, stat = %x\n",
 		__func__, ioread32(I2C_REG_STS(alg_data)));
+	
+	clk_disable(alg_data->clk);
 
 	if (completed != num)
 		return ((rc < 0) ? rc : -EREMOTEIO);
@@ -530,16 +678,270 @@ i2c_pnx_xfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
 	return num;
 }
 
-static u32 i2c_pnx_func(struct i2c_adapter *adapter)
+/* Checks for the state of I2C BUS */
+static int i2c_pnx_smbus_check(struct i2c_pnx_algo_data *smbus)
+{
+        u32 stat;
+        int need_reset;
+
+        stat = ioread32(I2C_REG_STS(smbus));
+
+        /* Reset if bus is still active or a NACK from prev xfer pending */
+        need_reset = stat & (mstatus_active | mstatus_nai);
+
+        /* Reset if TXFIFO or RXFIFO is not empty */
+        need_reset |= ~stat & (mstatus_rfe | mstatus_tfe);
+
+        if (unlikely(need_reset)) {
+                dev_dbg(&smbus->adapter.dev, "SMBus is not in idle state"
+                                " before transfer, resetting it...\r\n");
+                iowrite32(ioread32(I2C_REG_CTL(smbus)) | mcntrl_reset,
+                          I2C_REG_CTL(smbus));
+                wait_reset(I2C_PNX_TIMEOUT, smbus);
+        }
+
+        stat = ioread32(I2C_REG_STS(smbus));
+
+        /* if the bus is still busy ask i2c-core to retry after sometime */
+        if (stat & mstatus_active) {
+                dev_dbg(&smbus->adapter.dev, "SMBus is still active!\r\n");
+                return -EAGAIN;
+        }
+
+        return 0;
+}
+
+/* Initialize SMBus structure */
+static void i2c_pnx_smbus_init(struct i2c_pnx_algo_data *smbus)
+{
+        struct i2c_pnx_smbus *smb = &smbus->smb;
+        smb->index = 0;
+        smb->ret = 0;
+        smb->flags = I2C_PNX_SMBUS_ACTIVE;
+        smb->len = 0;
+        smb->rx_cnt = 0;
+        iowrite32(mstatus_tdi, I2C_REG_STS(smbus));
+        init_completion(&smb->complete);
+}
+
+static void i2c_pnx_fill_buffer(u16 *to, u8 *from, int cnt)
 {
-	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+        int i;
+        for (i = 0; i < cnt; i++)
+                to[i] = from ? from[i] : 0;
 }
 
-static struct i2c_algorithm pnx_algorithm = {
-	.master_xfer = i2c_pnx_xfer,
-	.functionality = i2c_pnx_func,
+/**
+ * i2c_pnx_smbus_xfer - SMBUS protocol transfer routine
+ * @adapter:    pointer to I2C adapter structure
+ * @msgs:               array of messages
+ * @num:                number of messages
+ *
+ * Initiates the transfer
+ */
+static int i2c_pnx_smbus_xfer(struct i2c_adapter *adapter,
+                u16 addr, unsigned short flags, char read_write, u8 command,
+                int size, union i2c_smbus_data *data)
+{
+        struct i2c_pnx_algo_data *smbus = adapter->algo_data;
+        struct i2c_pnx_smbus *smb = &smbus->smb;
+        u16 *tx_buf = smb->tx_buf;
+        int read_flag, err;
+        int len = 0, i = 0;
+
+        dev_dbg(&adapter->dev, "SMBus xfer request: Slave addr %#02x,"
+                        "command=%d, operation=%d\r\n", addr, command, size);
+
+        smb->slave_addr = addr;
+        /* All our ops take 8-bit shifted addresses */
+        addr <<= 1;
+        read_flag = read_write == I2C_SMBUS_READ;
+
+        clk_enable(smbus->clk);
+
+        err = i2c_pnx_smbus_check(smbus);
+        if (unlikely(err)) {
+                clk_disable(smbus->clk);
+                return err;
+        }
+
+        i2c_pnx_smbus_init(smbus);
+
+        smb->rx_buf = data->block;
+        switch (size) {
+        case I2C_SMBUS_QUICK:
+                tx_buf[0] = addr | start_bit | stop_bit | read_flag;
+                read_flag = 0;
+                smb->len = 1;
+                break;
+
+        case I2C_SMBUS_BYTE:
+                tx_buf[0] = addr | start_bit | read_flag;
+                tx_buf[1] = command | stop_bit;
+                smb->len = 2;
+                break;
+
+        case I2C_SMBUS_BYTE_DATA:
+                i = 0;
+                tx_buf[i++] = addr | start_bit;
+                tx_buf[i++] = command;
+                if (read_flag)
+                        tx_buf[i++] = addr | start_bit | 1;
+                tx_buf[i++] = data->byte | stop_bit;
+                smb->len = i;
+                break;
+
+        case I2C_SMBUS_WORD_DATA:
+                i = 0;
+                tx_buf[i++] = addr | start_bit;
+                tx_buf[i++] = command;
+                if (read_flag)
+                        tx_buf[i++] = addr | start_bit | 1;
+                tx_buf[i++] = (data->word & 0xFF); /* Low Word */
+		tx_buf[i++] = ((data->word >> 8) & 0xFF) | stop_bit;
+                smb->len = i;
+                smb->flags |= I2C_PNX_SMBUS_WORD_RX;
+                break;
+
+        case I2C_SMBUS_BLOCK_DATA:
+                len = data->block[0];
+                tx_buf[i++] = addr | start_bit;
+                tx_buf[i++] = command;
+                if (read_flag) {
+                        tx_buf[i++] = addr | start_bit | 1;
+                        i2c_pnx_fill_buffer(&tx_buf[i],
+                                        (u8 *)NULL, I2C_SMBUS_BLOCK_MAX + 1);
+                        tx_buf[I2C_SMBUS_BLOCK_MAX + i] |= stop_bit;
+                        smb->rx_buf = data->block;
+                        smb->flags |= I2C_PNX_SMBUS_BLOCK_RX;
+                        smb->len = i + 2;
+                        smb->max_rx_len = I2C_SMBUS_BLOCK_MAX;
+                } else {
+                        if (!len) {
+                                clk_disable(smbus->clk);
+                                return -EIO;
+                        }
+                        i2c_pnx_fill_buffer(&tx_buf[i],
+                            data->block, len + 1);
+                        tx_buf[len + i] |= stop_bit;
+                        smb->len = len + i + 1;
+                }
+                break;
+
+        case I2C_SMBUS_PROC_CALL:
+                tx_buf[0] = addr | start_bit;
+                tx_buf[1] = command;
+                tx_buf[2] = data->word & 0xFF;
+                tx_buf[3] = (data->word >> 8) & 0xFF;
+                tx_buf[4] = addr | start_bit | 1;
+                tx_buf[5] = 0;
+                tx_buf[6] = 0 | stop_bit;
+                smb->len = 7;
+                smb->max_rx_len = 2;
+                smb->flags |= I2C_PNX_SMBUS_WORD_RX;
+                read_flag = 1;
+                break;
+
+        case I2C_SMBUS_BLOCK_PROC_CALL:
+                len = data->block[0];
+                if (!len) {
+                        clk_disable(smbus->clk);
+                        return -EINVAL;
+                }
+                tx_buf[0] = addr | start_bit;
+                tx_buf[1] = command;
+                i2c_pnx_fill_buffer(&tx_buf[2],
+                        data->block, len + 1);
+                i = 3 + len;
+                tx_buf[i++] = addr | start_bit | 1;
+                len = I2C_SMBUS_BLOCK_MAX - len;
+                i2c_pnx_fill_buffer(&tx_buf[i],
+                    NULL, len + 1);
+                tx_buf[i+len] = stop_bit;
+                smb->flags |= I2C_PNX_SMBUS_BLOCK_RX;
+                smb->max_rx_len = len;
+                smb->len = 2 + i;
+                read_flag = 1;
+                break;
+
+	default:
+                dev_warn(&adapter->dev, "Unsupported transaction %d\n", size);
+                clk_disable(smbus->clk);
+                return -EINVAL;
+        }
+        /* Enable interrupts and wait for completion of xfer */
+        iowrite32(ioread32(I2C_REG_CTL(smbus)) | 0xEF, I2C_REG_CTL(smbus));
+
+        err = wait_for_completion_interruptible_timeout(&smb->complete, HZ);
+
+        /* Disable interrupts */
+        iowrite32(ioread32(I2C_REG_CTL(smbus)) & ~0xEF, I2C_REG_CTL(smbus));
+        smb->flags &= ~I2C_PNX_SMBUS_ACTIVE;
+
+        if (err == 0) { /* Xfer timedout */
+                dev_dbg(&adapter->dev, "SMBus Xfer timedout"
+                                "[Slave Addr: %02x]\n", addr >> 1);
+                err = -ETIMEDOUT;
+                smb->flags |= I2C_PNX_SMBUS_NEED_RESET;
+        } else if (err > 0) { /* No error */
+                err = smb->ret;
+        } else { /* < 0 Possibly interrupted */
+                smb->flags |= I2C_PNX_SMBUS_NEED_RESET;
+        }
+
+        /* Handle post processing for a Rx xfer */
+        if (!err && read_flag) {
+                len = (smb->flags & I2C_PNX_SMBUS_BLOCK_RX) ?
+                        data->block[0] + 1 : 1;
+
+                if (smb->flags & I2C_PNX_SMBUS_WORD_RX) {
+                        len = 2;
+                        /* Return endian independent data */
+                        data->word = (data->block[0] & 0xFF) |
+                                ((data->block[1] & 0xFF) << 8);
+                }
+                if (unlikely(len > smb->rx_cnt)) {
+                        dev_err(&adapter->dev, "SMBus: Rx count error "
+                                        "[Expected:%d, Got:%d] slave: %#02x\n",
+                                        len, smb->rx_cnt, addr >> 1);
+                        err = -EIO;
+                }
+        }
+
+        if (unlikely(smb->flags & I2C_PNX_SMBUS_NEED_RESET)) {
+                iowrite32(ioread32(I2C_REG_CTL(smbus)) | mcntrl_reset,
+                          I2C_REG_CTL(smbus));
+        }
+
+        clk_disable(smbus->clk);
+
+        return err;
+}
+
+/**
+ * i2c_pnx_func - SMBUS protocol transfer routine
+ * @adapt:      pointer to I2C adapter structure
+ *
+ * Provides the list of functionality provided by pnx-i2c
+ *
+ * I2C_FUNC_10BIT_ADDR - is supported by hardware but
+ * this driver does not implement it!
+ */
+static u32 i2c_pnx_func(struct i2c_adapter *adap)
+{
+        return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE |
+               I2C_FUNC_SMBUS_BYTE_DATA | I2C_FUNC_SMBUS_WORD_DATA |
+               I2C_FUNC_SMBUS_BLOCK_DATA | I2C_FUNC_SMBUS_PROC_CALL |
+               I2C_FUNC_SMBUS_BLOCK_PROC_CALL | I2C_FUNC_I2C;
+}
+
+static const struct i2c_algorithm pnx_algorithm = {
+        .master_xfer = i2c_pnx_xfer,
+        .smbus_xfer  = i2c_pnx_smbus_xfer,
+        .functionality = i2c_pnx_func,
 };
 
+
 #ifdef CONFIG_PM
 static int i2c_pnx_controller_suspend(struct platform_device *pdev,
 				      pm_message_t state)
@@ -665,6 +1067,9 @@ static int __devinit i2c_pnx_probe(struct platform_device *pdev)
 	dev_dbg(&pdev->dev, "%s: Master at %#8x, irq %d.\n",
 	       alg_data->adapter.name, i2c_pnx->base, i2c_pnx->irq);
 
+	/* Disable clock until needed */
+	clk_disable(alg_data->clk);
+
 	return 0;
 
 out_irq:
@@ -690,6 +1095,7 @@ static int __devexit i2c_pnx_remove(struct platform_device *pdev)
 	struct i2c_pnx_algo_data *alg_data = platform_get_drvdata(pdev);
 	struct i2c_pnx_data *i2c_pnx = alg_data->i2c_pnx;
 
+	clk_enable(alg_data->clk);
 	free_irq(i2c_pnx->irq, alg_data);
 	i2c_del_adapter(&alg_data->adapter);
 	clk_disable(alg_data->clk);
@@ -709,8 +1115,6 @@ static struct platform_driver i2c_pnx_driver = {
 	},
 	.probe = i2c_pnx_probe,
 	.remove = __devexit_p(i2c_pnx_remove),
-	.suspend = i2c_pnx_controller_suspend,
-	.resume = i2c_pnx_controller_resume,
 };
 
 static int __init i2c_adap_pnx_init(void)
diff --git a/drivers/input/keyboard/Kconfig b/drivers/input/keyboard/Kconfig
index cdc385b..4150ee2 100644
--- a/drivers/input/keyboard/Kconfig
+++ b/drivers/input/keyboard/Kconfig
@@ -318,6 +318,15 @@ config KEYBOARD_LOCOMO
 	  To compile this driver as a module, choose M here: the
 	  module will be called locomokbd.
 
+config KEYBOARD_LPC32XX
+        tristate "LPC32XX matrix key scanner support"
+        depends on ARCH_LPC32XX
+        help
+          Say Y here if you want to use the LPC32XX keyscanner interface.
+
+          To compile this driver as a module, choose M here: the
+          module will be called lpc32xx_keys.
+
 config KEYBOARD_MAPLE
 	tristate "Maple bus keyboard"
 	depends on SH_DREAMCAST && MAPLE
diff --git a/drivers/input/keyboard/Makefile b/drivers/input/keyboard/Makefile
index df7061f..cd216d0 100644
--- a/drivers/input/keyboard/Makefile
+++ b/drivers/input/keyboard/Makefile
@@ -25,6 +25,7 @@ obj-$(CONFIG_KEYBOARD_HP7XX)		+= jornada720_kbd.o
 obj-$(CONFIG_KEYBOARD_LKKBD)		+= lkkbd.o
 obj-$(CONFIG_KEYBOARD_LM8323)		+= lm8323.o
 obj-$(CONFIG_KEYBOARD_LOCOMO)		+= locomokbd.o
+obj-$(CONFIG_KEYBOARD_LPC32XX)  += lpc32xx_keys.o
 obj-$(CONFIG_KEYBOARD_MAPLE)		+= maple_keyb.o
 obj-$(CONFIG_KEYBOARD_MATRIX)		+= matrix_keypad.o
 obj-$(CONFIG_KEYBOARD_MAX7359)		+= max7359_keypad.o
diff --git a/drivers/input/keyboard/lpc32xx_keys.c b/drivers/input/keyboard/lpc32xx_keys.c
new file mode 100644
index 0000000..3eb37ac
--- /dev/null
+++ b/drivers/input/keyboard/lpc32xx_keys.c
@@ -0,0 +1,293 @@
+/*
+ * linux/drivers/input/keyboard/lpc32xx-keys.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/input.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <mach/board.h>
+
+/*
+ * Key scanner register offsets
+ */
+#define LPC32XX_KS_DEB(x)			((x) + 0x00)
+#define LPC32XX_KS_STATE_COND(x)		((x) + 0x04)
+#define LPC32XX_KS_IRQ(x)			((x) + 0x08)
+#define LPC32XX_KS_SCAN_CTL(x)			((x) + 0x0C)
+#define LPC32XX_KS_FAST_TST(x)			((x) + 0x10)
+#define LPC32XX_KS_MATRIX_DIM(x)		((x) + 0x14)
+#define LPC32XX_KS_DATA(x, y)			((x) + 0x40 + (y  << 2))
+
+#define LPC32XX_KSCAN_DEB_NUM_DEB_PASS(n)	((n) & 0xFF)
+
+#define LPC32XX_KSCAN_SCOND_IN_IDLE		0x0
+#define LPC32XX_KSCAN_SCOND_IN_SCANONCE		0x1
+#define LPC32XX_KSCAN_SCOND_IN_IRQGEN		0x2
+#define LPC32XX_KSCAN_SCOND_IN_SCAN_MATRIX	0x3
+
+#define LPC32XX_KSCAN_IRQ_PENDING_CLR		0x1
+
+#define LPC32XX_KSCAN_SCTRL_SCAN_DELAY(n)	((n) & 0xFF)
+
+#define LPC32XX_KSCAN_FTST_FORCESCANONCE	0x1
+#define LPC32XX_KSCAN_FTST_USE32K_CLK		0x2
+
+#define LPC32XX_KSCAN_MSEL_SELECT(n)		((n) & 0xF)
+
+struct lpc32xx_kscan_drv {
+	struct input_dev *input;
+	struct lpc32XX_kscan_cfg *kscancfg;
+	struct clk *clk;
+	void __iomem *kscan_base;
+	int irq;
+	u8 lastkeystates[8];
+};
+
+static void lpc32xx_mod_states(struct lpc32xx_kscan_drv *kscandat, int off)
+{
+	u8 st, key;
+	int j, scancode, keycode;
+
+	key = (u8) __raw_readl(LPC32XX_KS_DATA(kscandat->kscan_base, off));
+	if (key != kscandat->lastkeystates[off]) {
+		for (j = 0; j < kscandat->kscancfg->matrix_sz; j++) {
+			st = key & (1 << j);
+			if (st != (kscandat->lastkeystates[off] & (1 << j))) {
+				/* Key state changed, signal an event */
+				scancode = (int) (j *
+					kscandat->kscancfg->matrix_sz) + off;
+				keycode =
+					kscandat->kscancfg->keymap[scancode];
+				input_report_key(kscandat->input, keycode,
+					(st != 0));
+			}
+		}
+
+		kscandat->lastkeystates[off] = key;
+	}
+}
+
+static irqreturn_t lpc32xx_kscan_irq(int irq, void *dev_id)
+{
+	int i;
+	struct lpc32xx_kscan_drv *kscandat =
+		(struct lpc32xx_kscan_drv *) dev_id;
+
+	for (i = 0; i < kscandat->kscancfg->matrix_sz; i++)
+		lpc32xx_mod_states(kscandat, i);
+
+	__raw_writel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));
+
+	input_sync(kscandat->input);
+
+	return IRQ_HANDLED;
+}
+
+static int __devinit lpc32xx_kscan_probe(struct platform_device *pdev)
+{
+	struct lpc32xx_kscan_drv *kscandat;
+	struct resource *res;
+	int retval, i;
+
+	kscandat = kzalloc(sizeof(struct lpc32xx_kscan_drv), GFP_KERNEL);
+	if (unlikely(!kscandat)) {
+		dev_err(&pdev->dev, "failed to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to get platform I/O memory\n");
+		retval = -EBUSY;
+		goto err_nores;
+	}
+
+	res = request_mem_region(res->start, resource_size(res), pdev->name);
+	if (res == NULL) {
+		dev_err(&pdev->dev, "failed to request I/O memory\n");
+		retval = -EBUSY;
+		goto err_nores;
+	}
+
+	kscandat->kscan_base = ioremap(res->start, res->end - res->start + 1);
+	if (kscandat->kscan_base == NULL) {
+		dev_err(&pdev->dev, "failed to remap I/O memory\n");
+		retval = -EBUSY;
+		goto err_noremap;
+	}
+
+	/* Get the key scanner clock */
+	kscandat->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(kscandat->clk)) {
+		dev_err(&pdev->dev, "failed to get clock\n");
+		retval = -ENODEV;
+		goto err_noclk;
+	}
+	clk_enable(kscandat->clk);
+
+	kscandat->irq = platform_get_irq(pdev, 0);
+	if ((kscandat->irq < 0) || (kscandat->irq >= NR_IRQS)) {
+		dev_err(&pdev->dev, "failed to get platform irq\n");
+		retval = -EINVAL;
+		goto err_noirq;
+	}
+	retval = request_irq(kscandat->irq, lpc32xx_kscan_irq,
+		0, pdev->name, kscandat);
+	if (retval) {
+		dev_err(&pdev->dev, "failed to request irq\n");
+		goto err_noirq;
+	}
+
+	kscandat->input = input_allocate_device();
+	if (kscandat->input == NULL) {
+		dev_err(&pdev->dev, "failed to allocate device\n");
+		retval = -ENOMEM;
+		goto err_noalloc;
+	}
+
+	kscandat->kscancfg = (struct lpc32XX_kscan_cfg *)
+		pdev->dev.platform_data;
+	platform_set_drvdata(pdev, kscandat);
+
+	/* Setup key input */
+	kscandat->input->evbit[0]	= BIT_MASK(EV_KEY);
+	kscandat->input->name		= pdev->name;
+	kscandat->input->phys		= "matrix-keys/input0";
+	kscandat->input->dev.parent	=  &pdev->dev;
+	kscandat->input->id.vendor	= 0x0001;
+	kscandat->input->id.product	= 0x0001;
+	kscandat->input->id.version	= 0x0100;
+	for (i = 0; i < kscandat->kscancfg->matrix_sz; i++)
+		__set_bit(kscandat->kscancfg->keymap[i],
+			kscandat->input->keybit);
+
+	input_set_capability(kscandat->input, EV_MSC, MSC_SCAN);
+
+	retval = input_register_device(kscandat->input);
+	if (retval) {
+		dev_err(&pdev->dev, "failed to register input device\n");
+		goto err_notregistered;
+	}
+
+	/* Configure the key scanner */
+	__raw_writel(kscandat->kscancfg->deb_clks,
+		LPC32XX_KS_DEB(kscandat->kscan_base));
+	__raw_writel(kscandat->kscancfg->scan_delay,
+		LPC32XX_KS_SCAN_CTL(kscandat->kscan_base));
+	__raw_writel(LPC32XX_KSCAN_FTST_USE32K_CLK,
+		LPC32XX_KS_FAST_TST(kscandat->kscan_base));
+	__raw_writel(kscandat->kscancfg->matrix_sz,
+		LPC32XX_KS_MATRIX_DIM(kscandat->kscan_base));
+	__raw_writel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));
+
+	return 0;
+
+err_notregistered:
+	input_free_device(kscandat->input);
+err_noalloc:
+	free_irq(kscandat->irq, pdev);
+err_noirq:
+	clk_put(kscandat->clk);
+err_noclk:
+	iounmap(kscandat->kscan_base);
+err_noremap:
+	release_mem_region(res->start, resource_size(res));
+err_nores:
+	kfree(kscandat);
+
+	return retval;
+}
+
+static int __devexit lpc32xx_kscan_remove(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);
+
+	free_irq(kscandat->irq, pdev);
+	input_unregister_device(kscandat->input);
+	clk_put(kscandat->clk);
+	iounmap(kscandat->kscan_base);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	release_mem_region(res->start, resource_size(res));
+
+	kfree(kscandat);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lpc32xx_kscan_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	struct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);
+
+	/* Clear IRQ and disable clock */
+	__raw_writel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));
+	clk_disable(kscandat->clk);
+
+	return 0;
+}
+
+static int lpc32xx_kscan_resume(struct platform_device *pdev)
+{
+	struct lpc32xx_kscan_drv *kscandat = platform_get_drvdata(pdev);
+
+	/* Enable clock and clear IRQ */
+	clk_enable(kscandat->clk);
+	__raw_writel(1, LPC32XX_KS_IRQ(kscandat->kscan_base));
+
+	return 0;
+}
+#else
+#define lpc32xx_kscan_suspend	NULL
+#define lpc32xx_kscan_resume	NULL
+#endif
+
+static struct platform_driver lpc32xx_kscan_driver = {
+	.probe		= lpc32xx_kscan_probe,
+	.remove		= __devexit_p(lpc32xx_kscan_remove),
+	.suspend	= lpc32xx_kscan_suspend,
+	.resume		= lpc32xx_kscan_resume,
+	.driver		= {
+		.name	= "lpc32xx_keys",
+	}
+};
+
+static int __init lpc32xx_kscan_init(void)
+{
+	return platform_driver_register(&lpc32xx_kscan_driver);
+}
+
+static void __exit lpc32xx_kscan_exit(void)
+{
+	platform_driver_unregister(&lpc32xx_kscan_driver);
+}
+
+module_init(lpc32xx_kscan_init);
+module_exit(lpc32xx_kscan_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("Key scanner driver for LPC32XX devices");
diff --git a/drivers/input/touchscreen/lpc32xx_ts.c b/drivers/input/touchscreen/lpc32xx_ts.c
index afcd069..2213835 100644
--- a/drivers/input/touchscreen/lpc32xx_ts.c
+++ b/drivers/input/touchscreen/lpc32xx_ts.c
@@ -1,5 +1,7 @@
 /*
- * LPC32xx built-in touchscreen driver
+ * drivers/input/touchscreen/lpc32xx_tsc.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
  *
  * Copyright (C) 2010 NXP Semiconductors
  *
@@ -26,31 +28,29 @@
 /*
  * Touchscreen controller register offsets
  */
-#define LPC32XX_TSC_STAT			0x00
-#define LPC32XX_TSC_SEL				0x04
-#define LPC32XX_TSC_CON				0x08
-#define LPC32XX_TSC_FIFO			0x0C
-#define LPC32XX_TSC_DTR				0x10
-#define LPC32XX_TSC_RTR				0x14
-#define LPC32XX_TSC_UTR				0x18
-#define LPC32XX_TSC_TTR				0x1C
-#define LPC32XX_TSC_DXP				0x20
-#define LPC32XX_TSC_MIN_X			0x24
-#define LPC32XX_TSC_MAX_X			0x28
-#define LPC32XX_TSC_MIN_Y			0x2C
-#define LPC32XX_TSC_MAX_Y			0x30
-#define LPC32XX_TSC_AUX_UTR			0x34
-#define LPC32XX_TSC_AUX_MIN			0x38
-#define LPC32XX_TSC_AUX_MAX			0x3C
+#define LPC32XX_TSC_STAT(x)			((x) + 0x00)
+#define LPC32XX_TSC_SEL(x)			((x) + 0x04)
+#define LPC32XX_TSC_CON(x)			((x) + 0x08)
+#define LPC32XX_TSC_FIFO(x)			((x) + 0x0C)
+#define LPC32XX_TSC_DTR(x)			((x) + 0x10)
+#define LPC32XX_TSC_RTR(x)			((x) + 0x14)
+#define LPC32XX_TSC_UTR(x)			((x) + 0x18)
+#define LPC32XX_TSC_TTR(x)			((x) + 0x1C)
+#define LPC32XX_TSC_DXP(x)			((x) + 0x20)
+#define LPC32XX_TSC_MIN_X(x)			((x) + 0x24)
+#define LPC32XX_TSC_MAX_X(x)			((x) + 0x28)
+#define LPC32XX_TSC_MIN_Y(x)			((x) + 0x2C)
+#define LPC32XX_TSC_MAX_Y(x)			((x) + 0x30)
+#define LPC32XX_TSC_AUX_UTR(x)			((x) + 0x34)
+#define LPC32XX_TSC_AUX_MIN(x)			((x) + 0x38)
+#define LPC32XX_TSC_AUX_MAX(x)			((x) + 0x3C)
 
 #define LPC32XX_TSC_STAT_FIFO_OVRRN		(1 << 8)
 #define LPC32XX_TSC_STAT_FIFO_EMPTY		(1 << 7)
 
-#define LPC32XX_TSC_SEL_DEFVAL			0x0284
-
 #define LPC32XX_TSC_ADCCON_IRQ_TO_FIFO_4	(0x1 << 11)
-#define LPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(s)	((10 - (s)) << 7)
-#define LPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(s)	((10 - (s)) << 4)
+#define LPC32XX_TSC_ADCCON_X_SAMPLE_SIZE(s)	((10 - s) << 7)
+#define LPC32XX_TSC_ADCCON_Y_SAMPLE_SIZE(s)	((10 - s) << 4)
 #define LPC32XX_TSC_ADCCON_POWER_UP		(1 << 2)
 #define LPC32XX_TSC_ADCCON_AUTO_EN		(1 << 0)
 
@@ -60,55 +60,44 @@
 
 #define LPC32XX_TSC_ADCDAT_VALUE_MASK		0x000003FF
 
-#define LPC32XX_TSC_MIN_XY_VAL			0x0
-#define LPC32XX_TSC_MAX_XY_VAL			0x3FF
-
-#define MOD_NAME "ts-lpc32xx"
-
-#define tsc_readl(dev, reg) \
-	__raw_readl((dev)->tsc_base + (reg))
-#define tsc_writel(dev, reg, val) \
-	__raw_writel((val), (dev)->tsc_base + (reg))
+#define MOD_NAME "lpc32xx-ts"
 
-struct lpc32xx_tsc {
+struct lpc32xx_tsc_t {
 	struct input_dev *dev;
 	void __iomem *tsc_base;
 	int irq;
 	struct clk *clk;
+	int suspended;
 };
 
-static void lpc32xx_fifo_clear(struct lpc32xx_tsc *tsc)
+static void lpc32xx_fifo_clear(struct lpc32xx_tsc_t *lpc32xx_tsc_dat)
 {
-	while (!(tsc_readl(tsc, LPC32XX_TSC_STAT) &
-			LPC32XX_TSC_STAT_FIFO_EMPTY))
-		tsc_readl(tsc, LPC32XX_TSC_FIFO);
+	while (!(__raw_readl(LPC32XX_TSC_STAT(lpc32xx_tsc_dat->tsc_base)) &
+		LPC32XX_TSC_STAT_FIFO_EMPTY))
+		__raw_readl(LPC32XX_TSC_FIFO(lpc32xx_tsc_dat->tsc_base));
 }
 
 static irqreturn_t lpc32xx_ts_interrupt(int irq, void *dev_id)
 {
 	u32 tmp, rv[4], xs[4], ys[4];
 	int idx;
-	struct lpc32xx_tsc *tsc = dev_id;
-	struct input_dev *input = tsc->dev;
+	struct lpc32xx_tsc_t *lpc32xx_tsc_dat =
+		(struct lpc32xx_tsc_t *) dev_id;
+	struct input_dev *input = lpc32xx_tsc_dat->dev;
 
-	tmp = tsc_readl(tsc, LPC32XX_TSC_STAT);
+	tmp = __raw_readl(LPC32XX_TSC_STAT(lpc32xx_tsc_dat->tsc_base));
 
 	if (tmp & LPC32XX_TSC_STAT_FIFO_OVRRN) {
 		/* FIFO overflow - throw away samples */
-		lpc32xx_fifo_clear(tsc);
+		lpc32xx_fifo_clear(lpc32xx_tsc_dat);
 		return IRQ_HANDLED;
 	}
 
-	/*
-	 * Gather and normalize 4 samples. Pen-up events may have less
-	 * than 4 samples, but its ok to pop 4 and let the last sample
-	 * pen status check drop the samples.
-	 */
 	idx = 0;
-	while (idx < 4 &&
-	       !(tsc_readl(tsc, LPC32XX_TSC_STAT) &
-			LPC32XX_TSC_STAT_FIFO_EMPTY)) {
-		tmp = tsc_readl(tsc, LPC32XX_TSC_FIFO);
+	while ((idx < 4) &&
+		(!(__raw_readl(LPC32XX_TSC_STAT(lpc32xx_tsc_dat->tsc_base)) &
+		LPC32XX_TSC_STAT_FIFO_EMPTY))) {
+		tmp = __raw_readl(LPC32XX_TSC_FIFO(lpc32xx_tsc_dat->tsc_base));
 		xs[idx] = LPC32XX_TSC_ADCDAT_VALUE_MASK -
 			LPC32XX_TSC_FIFO_NORMALIZE_X_VAL(tmp);
 		ys[idx] = LPC32XX_TSC_ADCDAT_VALUE_MASK -
@@ -117,13 +106,14 @@ static irqreturn_t lpc32xx_ts_interrupt(int irq, void *dev_id)
 		idx++;
 	}
 
-	/* Data is only valid if pen is still down in last sample */
-	if (!(rv[3] & LPC32XX_TSC_FIFO_TS_P_LEVEL) && idx == 4) {
-		/* Use average of 2nd and 3rd sample for position */
-		input_report_abs(input, ABS_X, (xs[1] + xs[2]) / 2);
-		input_report_abs(input, ABS_Y, (ys[1] + ys[2]) / 2);
+	/* Data is only valid if pen is still down */
+	if ((!(rv[3] & LPC32XX_TSC_FIFO_TS_P_LEVEL)) && (idx == 4)) {
+		input_report_abs(input, ABS_X, ((xs[1] + xs[2]) / 2));
+		input_report_abs(input, ABS_Y, ((ys[1] + ys[2]) / 2));
+		input_report_abs(input, ABS_PRESSURE, 1);
 		input_report_key(input, BTN_TOUCH, 1);
 	} else {
+		input_report_abs(input, ABS_PRESSURE, 0);
 		input_report_key(input, BTN_TOUCH, 0);
 	}
 
diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c
index 11e589c..f44f803 100644
--- a/drivers/mmc/host/mmci.c
+++ b/drivers/mmc/host/mmci.c
@@ -35,11 +35,257 @@
 #include <asm/io.h>
 #include <asm/sizes.h>
 
+#ifdef CONFIG_ARCH_LPC32XX
+#include <mach/clkdev.h>
+#include <mach/dmac.h>
+#include <mach/sdcard.h>
+#include <mach/dma.h>
+#include <mach/hardware.h>
+#endif
+
 #include "mmci.h"
 
 #define DRIVER_NAME "mmci-pl18x"
 
+#ifdef CONFIG_ARCH_LPC32XX
+static unsigned int fmax = 26000000;
+#else
 static unsigned int fmax = 515633;
+#endif
+
+#ifdef CONFIG_ARCH_LPC32XX
+#define DMA_BUFF_SIZE SZ_64K
+
+struct LPC32XX_SDDRV_DATA {
+	struct dma_config dmacfgtx;
+	struct dma_config dmacfgrx;
+	struct device *dev;
+	int lastch;
+	dma_addr_t dma_handle_tx;
+	void *dma_v_base;
+	int mapped;
+};
+static struct LPC32XX_SDDRV_DATA lpc32xx_drvdat;
+
+#define MCI_WIDEBUS (1 << 11)
+#undef MCI_IRQENABLE
+#define MCI_IRQENABLE   \
+        (MCI_CMDCRCFAILMASK|MCI_DATACRCFAILMASK|MCI_CMDTIMEOUTMASK|     \
+        MCI_DATATIMEOUTMASK|MCI_TXUNDERRUNMASK|MCI_RXOVERRUNMASK|       \
+        MCI_CMDRESPENDMASK|MCI_CMDSENTMASK)
+
+static int mmc_dma_setup(void)
+{
+	u32 llptrrx, llptrtx;
+	int ret = 0;
+
+	/*
+	 * There is a quirk with the LPC32XX and SD burst DMA. DMA sg
+	 * transfers where DMA is the flow controller will not transfer
+	 * the last few bytes to or from the SD card controller and
+	 * memory. For RX, the last few bytes in the SD transfer can be
+	 * forced out with a software DMA burst request. For TX, this
+	 * can't be done, so TX sg support cannot be supported. For TX,
+	 * a temporary bouncing buffer is used if more than 1 sg segment
+	 * is passed in the data request. The bouncing buffer will get a
+	 * contiguous copy of the TX data and it will be used instead.
+	 */
+
+	/* Allocate a chunk of memory for the DMA TX buffers */
+	lpc32xx_drvdat.dma_v_base = dma_alloc_coherent(lpc32xx_drvdat.dev,
+			DMA_BUFF_SIZE, &lpc32xx_drvdat.dma_handle_tx, GFP_KERNEL);
+	if (lpc32xx_drvdat.dma_v_base == NULL) {
+		dev_err(lpc32xx_drvdat.dev, "error getting DMA region\n");
+		ret = -ENOMEM;
+		goto dma_no_tx_buff;
+	}
+	dev_info(lpc32xx_drvdat.dev, "DMA buffer: phy:%p, virt:%p\n",
+			(void *) lpc32xx_drvdat.dma_handle_tx, lpc32xx_drvdat.dma_v_base);
+
+	/* Setup TX DMA channel */
+	lpc32xx_drvdat.dmacfgtx.ch = DMA_CH_SDCARD_TX;
+	lpc32xx_drvdat.dmacfgtx.tc_inten = 0;
+	lpc32xx_drvdat.dmacfgtx.err_inten = 0;
+	lpc32xx_drvdat.dmacfgtx.src_size = 4;
+	lpc32xx_drvdat.dmacfgtx.src_inc = 1;
+	lpc32xx_drvdat.dmacfgtx.src_ahb1 = 0;
+	lpc32xx_drvdat.dmacfgtx.src_bsize = DMAC_CHAN_SRC_BURST_8;
+	lpc32xx_drvdat.dmacfgtx.src_prph = DMAC_SRC_PERIP(DMA_PERID_SDCARD);
+	lpc32xx_drvdat.dmacfgtx.dst_size = 4;
+	lpc32xx_drvdat.dmacfgtx.dst_inc = 0;
+	lpc32xx_drvdat.dmacfgtx.dst_ahb1 = 0;
+	lpc32xx_drvdat.dmacfgtx.dst_bsize = DMAC_CHAN_DEST_BURST_8;
+	lpc32xx_drvdat.dmacfgtx.dst_prph = DMAC_DEST_PERIP(DMA_PERID_SDCARD);
+	lpc32xx_drvdat.dmacfgtx.flowctrl = DMAC_CHAN_FLOW_P_M2P;
+	if (lpc32xx_dma_ch_get(&lpc32xx_drvdat.dmacfgtx, "dma_sd_tx",
+				NULL, NULL) < 0) {
+		dev_err(lpc32xx_drvdat.dev, "Error setting up SD card TX DMA channel\n");
+		ret = -ENODEV;
+		goto dma_no_txch;
+	}
+
+	/* Allocate a linked list for DMA support */
+	llptrtx = lpc32xx_dma_alloc_llist(lpc32xx_drvdat.dmacfgtx.ch, NR_SG * 2);
+	if (llptrtx == 0) {
+		dev_err(lpc32xx_drvdat.dev, "Error allocating list buffer (MMC TX)\n");
+		ret = -ENOMEM;
+		goto dma_no_txlist;
+	}
+
+	/* Setup RX DMA channel */
+	lpc32xx_drvdat.dmacfgrx.ch = DMA_CH_SDCARD_RX;
+	lpc32xx_drvdat.dmacfgrx.tc_inten = 0;
+	lpc32xx_drvdat.dmacfgrx.err_inten = 0;
+	lpc32xx_drvdat.dmacfgrx.src_size = 4;
+	lpc32xx_drvdat.dmacfgrx.src_inc = 0;
+	lpc32xx_drvdat.dmacfgrx.src_ahb1 = 0;
+	lpc32xx_drvdat.dmacfgrx.src_bsize = DMAC_CHAN_SRC_BURST_8;
+	lpc32xx_drvdat.dmacfgrx.src_prph = DMAC_SRC_PERIP(DMA_PERID_SDCARD);
+	lpc32xx_drvdat.dmacfgrx.dst_size = 4;
+	lpc32xx_drvdat.dmacfgrx.dst_inc = 1;
+	lpc32xx_drvdat.dmacfgrx.dst_ahb1 = 0;
+	lpc32xx_drvdat.dmacfgrx.dst_bsize = DMAC_CHAN_DEST_BURST_8;
+	lpc32xx_drvdat.dmacfgrx.dst_prph = DMAC_DEST_PERIP(DMA_PERID_SDCARD);
+	lpc32xx_drvdat.dmacfgrx.flowctrl = DMAC_CHAN_FLOW_D_P2M;
+	if (lpc32xx_dma_ch_get(&lpc32xx_drvdat.dmacfgrx, "dma_sd_rx", NULL,
+				NULL) < 0) {
+		dev_err(lpc32xx_drvdat.dev, "Error setting up SD card RX DMA channel\n");
+		ret = -ENODEV;
+		goto dma_no_rxch;
+	}
+
+	/* Allocate a linked list for DMA support */
+	llptrrx = lpc32xx_dma_alloc_llist(lpc32xx_drvdat.dmacfgrx.ch, NR_SG * 2);
+	if (llptrrx == 0) {
+		dev_err(lpc32xx_drvdat.dev, "Error allocating list buffer (MMC RX)\n");
+		ret = -ENOMEM;
+		goto dma_no_rxlist;
+	}
+
+	return 0;
+
+dma_no_rxlist:
+	lpc32xx_dma_ch_put(lpc32xx_drvdat.dmacfgrx.ch);
+	lpc32xx_drvdat.dmacfgrx.ch = -1;
+dma_no_rxch:
+	lpc32xx_dma_dealloc_llist(lpc32xx_drvdat.dmacfgtx.ch);
+dma_no_txlist:
+	lpc32xx_dma_ch_put(lpc32xx_drvdat.dmacfgtx.ch);
+	lpc32xx_drvdat.dmacfgtx.ch = -1;
+dma_no_txch:
+	dma_free_coherent(lpc32xx_drvdat.dev, DMA_BUFF_SIZE,
+			lpc32xx_drvdat.dma_v_base, lpc32xx_drvdat.dma_handle_tx);
+dma_no_tx_buff:
+	return ret;
+}
+
+static void mmc_dma_dealloc(void)
+{
+	lpc32xx_dma_dealloc_llist(lpc32xx_drvdat.dmacfgrx.ch);
+	lpc32xx_dma_ch_put(lpc32xx_drvdat.dmacfgrx.ch);
+	lpc32xx_drvdat.dmacfgrx.ch = -1;
+	lpc32xx_dma_dealloc_llist(lpc32xx_drvdat.dmacfgtx.ch);
+	lpc32xx_dma_ch_put(lpc32xx_drvdat.dmacfgtx.ch);
+	lpc32xx_drvdat.dmacfgtx.ch = -1;
+	dma_free_coherent(lpc32xx_drvdat.dev, DMA_BUFF_SIZE,
+			lpc32xx_drvdat.dma_v_base, lpc32xx_drvdat.dma_handle_tx);
+}
+
+/* Supports scatter/gather */
+static void mmc_dma_rx_start(struct mmci_host *host)
+{
+	unsigned int len;
+	int i, dma_len;
+	struct scatterlist *sg;
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_data *reqdata = mrq->data;
+	void *dmaaddr;
+	u32 dmalen, dmaxferlen;
+
+	sg = reqdata->sg;
+	len = reqdata->sg_len;
+
+	dma_len = dma_map_sg(mmc_dev(host->mmc), reqdata->sg, reqdata->sg_len,
+			DMA_FROM_DEVICE);
+	if (dma_len == 0)
+		return;
+
+	/* Setup transfer */
+	for (i = 0; i < len; i++) {
+		dmalen = (u32) sg_dma_len(&sg[i]);
+		dmaaddr = (void *) sg_dma_address(&sg[i]);
+
+		/* Build a list with a max size if 15872 bytes per seg */
+		while (dmalen > 0) {
+			dmaxferlen = dmalen;
+			if (dmaxferlen > 15872)
+				dmaxferlen = 15872;
+
+			lpc32xx_dma_queue_llist_entry(lpc32xx_drvdat.lastch,
+				(void *) SD_FIFO(LPC32XX_SD_BASE),
+				dmaaddr, dmaxferlen);
+
+				dmaaddr += dmaxferlen;
+				dmalen -= dmaxferlen;
+		}
+	}
+
+//printk("DMARX %d\n", len);
+}
+
+/* May need to reorganize buffer for scatter/gather */
+static void mmc_dma_tx_start(struct mmci_host *host)
+{
+	unsigned int len;
+	int dma_len;
+	struct scatterlist *sg;
+	struct mmc_request *mrq = host->mrq;
+	struct mmc_data *reqdata = mrq->data;
+	struct sg_mapping_iter *sg_miter = &host->sg_miter;
+	void *dmaaddr;
+	char *src_buffer, *dst_buffer;
+	unsigned long flags;
+
+	sg = reqdata->sg;
+	len = reqdata->sg_len;
+
+	/* Only 1 segment? */
+	if (len == 1) {
+		dma_len = dma_map_sg(mmc_dev(host->mmc), reqdata->sg,
+			reqdata->sg_len, DMA_TO_DEVICE);
+		if (dma_len == 0)
+			return;
+
+		dmaaddr = (void *) sg_dma_address(&sg[0]);
+		lpc32xx_drvdat.mapped = 1;
+	}
+	else {
+		/* Move data to contiguous buffer first, then transfer it */
+		dst_buffer = (char *) lpc32xx_drvdat.dma_v_base;
+		local_irq_save(flags);
+		do
+		{
+			/*
+			 * Map the current scatter buffer, copy data, and unmap
+			 */
+			if (!sg_miter_next(sg_miter))
+				break;
+
+			src_buffer = sg_miter->addr;
+			memcpy(dst_buffer, src_buffer, sg_miter->length);
+			dst_buffer += sg_miter->length;
+		} while (1);
+
+		sg_miter_stop(sg_miter);
+		local_irq_restore(flags);
+		lpc32xx_drvdat.mapped = 0;
+		dmaaddr = (void *) lpc32xx_drvdat.dma_handle_tx;
+	}
+
+	lpc32xx_dma_start_pflow_xfer(DMA_CH_SDCARD_TX, dmaaddr,
+		(void *) SD_FIFO(LPC32XX_SD_BASE), 1);
+}
+#endif
 
 /**
  * struct variant_data - MMCI variant-specific quirks
@@ -145,7 +391,7 @@ static void mmci_set_clkreg(struct mmci_host *host, unsigned int desired)
 		clk |= variant->clkreg_enable;
 		clk |= MCI_CLK_ENABLE;
 		/* This hasn't proven to be worthwhile */
-		/* clk |= MCI_CLK_PWRSAVE; */
+		clk |= MCI_CLK_PWRSAVE;
 	}
 
 	if (host->mmc->ios.bus_width == MMC_BUS_WIDTH_4)
@@ -575,7 +821,7 @@ static inline int mmci_dma_start_data(struct mmci_host *host, unsigned int datac
 static void mmci_start_data(struct mmci_host *host, struct mmc_data *data)
 {
 	struct variant_data *variant = host->variant;
-	unsigned int datactrl, timeout, irqmask;
+	unsigned int datactrl, timeout, irqmask = 0;
 	unsigned long long clks;
 	void __iomem *base;
 	int blksz_bits;
@@ -599,6 +845,28 @@ static void mmci_start_data(struct mmci_host *host, struct mmc_data *data)
 	blksz_bits = ffs(data->blksz) - 1;
 	BUG_ON(1 << blksz_bits != data->blksz);
 
+#ifdef CONFIG_ARCH_LPC32XX
+       datactrl = MCI_DPSM_ENABLE | MCI_DPSM_DMAENABLE | blksz_bits << 4;
+
+       /* IRQ mode, map the SG list for CPU reading/writing */
+       mmci_init_sg(host, data);
+
+       if (data->flags & MMC_DATA_READ) {
+               datactrl |= MCI_DPSM_DIRECTION;
+               lpc32xx_drvdat.lastch = DMA_CH_SDCARD_RX;
+               mmc_dma_rx_start(host);
+       }
+       else {
+               lpc32xx_drvdat.lastch = DMA_CH_SDCARD_TX;
+               mmc_dma_tx_start(host);
+       }
+
+       writel(datactrl, base + MMCIDATACTRL);
+       datactrl = readl(base + MMCIMASK0) & ~MCI_DATABLOCKENDMASK;
+       writel(datactrl | MCI_DATAENDMASK, base + MMCIMASK0);
+       mmci_set_mask1(host, irqmask);
+
+#else
 	if (variant->blksz_datactrl16)
 		datactrl = MCI_DPSM_ENABLE | (data->blksz << 16);
 	else
@@ -643,6 +911,7 @@ static void mmci_start_data(struct mmci_host *host, struct mmc_data *data)
 	writel(datactrl, base + MMCIDATACTRL);
 	writel(readl(base + MMCIMASK0) & ~MCI_DATAENDMASK, base + MMCIMASK0);
 	mmci_set_mask1(host, irqmask);
+#endif
 }
 
 static void
@@ -682,9 +951,11 @@ mmci_data_irq(struct mmci_host *host, struct mmc_data *data,
 		      MCI_TXUNDERRUN|MCI_RXOVERRUN)) {
 		u32 remain, success;
 
+#ifndef CONFIG_ARCH_LPC32XX
 		/* Terminate the DMA transfer */
 		if (dma_inprogress(host))
 			mmci_dma_data_error(host);
+#endif
 
 		/*
 		 * Calculate how far we are into the transfer.  Note that
@@ -722,8 +993,22 @@ mmci_data_irq(struct mmci_host *host, struct mmc_data *data,
 		dev_err(mmc_dev(host->mmc), "stray MCI_DATABLOCKEND interrupt\n");
 
 	if (status & MCI_DATAEND || data->error) {
+#ifdef CONFIG_ARCH_LPC32XX
+		if (data->flags & MMC_DATA_READ) {
+			lpc32xx_dma_force_burst(lpc32xx_drvdat.lastch, DMA_PERID_SDCARD);
+			lpc32xx_dma_flush_llist(lpc32xx_drvdat.lastch);
+			dma_unmap_sg(mmc_dev(host->mmc), data->sg, data->sg_len, DMA_FROM_DEVICE);
+		}
+		else {
+			lpc32xx_dma_ch_disable(lpc32xx_drvdat.lastch);
+			if (lpc32xx_drvdat.mapped)
+				dma_unmap_sg(mmc_dev(host->mmc), data->sg,
+					data->sg_len, DMA_TO_DEVICE);
+		}
+#else
 		if (dma_inprogress(host))
 			mmci_dma_unmap(host, data);
+#endif
 		mmci_stop_data(host);
 
 		if (!data->error)
@@ -1255,12 +1540,21 @@ static int __devinit mmci_probe(struct amba_device *dev,
 	 */
 	mmc->max_segs = NR_SG;
 
+#ifdef CONFIG_ARCH_LPC32XX
+	/*
+	 * The LPC32x0 DMA controller can handle up to a 65535 byte DMA
+	 * transfer. We'll rely on the mmc core to make sure the passed
+	 * size for a request is block aligned.
+	 */
+	mmc->max_seg_size = 65535;
+#else
 	/*
 	 * Since only a certain number of bits are valid in the data length
 	 * register, we must ensure that we don't exceed 2^num-1 bytes in a
 	 * single request.
 	 */
 	mmc->max_req_size = (1 << variant->datalength_bits) - 1;
+#endif
 
 	/*
 	 * Set the maximum segment size.  Since we aren't doing DMA
@@ -1279,6 +1573,17 @@ static int __devinit mmci_probe(struct amba_device *dev,
 	 */
 	mmc->max_blk_count = mmc->max_req_size >> 11;
 
+#ifdef CONFIG_ARCH_LPC32XX
+	/*
+	 * Setup DMA for the interface
+	 */
+	lpc32xx_drvdat.dev = &dev->dev;
+	if (mmc_dma_setup()) {
+		dev_err(&dev->dev, "error in setting up DMA \n");
+		goto irq0_free;
+	}
+#endif
+
 	spin_lock_init(&host->lock);
 
 	writel(0, host->base + MMCIMASK0);
@@ -1344,7 +1649,9 @@ static int __devinit mmci_probe(struct amba_device *dev,
 		 amba_rev(dev), (unsigned long long)dev->res.start,
 		 dev->irq[0], dev->irq[1]);
 
+#ifndef CONFIG_ARCH_LPC32XX
 	mmci_dma_setup(host);
+#endif
 
 	pm_runtime_put(&dev->dev);
 
@@ -1401,7 +1708,10 @@ static int __devexit mmci_remove(struct amba_device *dev)
 		writel(0, host->base + MMCICOMMAND);
 		writel(0, host->base + MMCIDATACTRL);
 
+#ifndef CONFIG_ARCH_LPC32XX
 		mmci_dma_release(host);
+#endif
+
 		free_irq(dev->irq[0], host);
 		if (!host->singleirq)
 			free_irq(dev->irq[1], host);
@@ -1413,6 +1723,10 @@ static int __devexit mmci_remove(struct amba_device *dev)
 		if (host->gpio_cd != -ENOSYS)
 			gpio_free(host->gpio_cd);
 
+#ifdef CONFIG_ARCH_LPC32XX
+		mmc_dma_dealloc();
+#endif
+
 		iounmap(host->base);
 		clk_disable(host->clk);
 		clk_unprepare(host->clk);
diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig
index 31b034b..281d7fb 100644
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -393,6 +393,13 @@ config MTD_NAND_PXA3xx
 	  This enables the driver for the NAND flash device found on
 	  PXA3xx processors
 
+config MTD_NAND_SLC_LPC32XX
+	bool "Support for NAND Flash on the LPC32XX"
+	depends on ARCH_LPC32XX
+	help
+		Enables support for NAND Flash using the LPC32XX SLC NAND 
+		controller.
+
 config MTD_NAND_CM_X270
 	tristate "Support for NAND Flash on CM-X270 modules"
 	depends on MACH_ARMCORE
diff --git a/drivers/mtd/nand/Makefile b/drivers/mtd/nand/Makefile
index 618f4ba..739955b 100644
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -31,6 +31,7 @@ obj-$(CONFIG_MTD_NAND_GPIO)		+= gpio.o
 obj-$(CONFIG_MTD_NAND_OMAP2) 		+= omap2.o
 obj-$(CONFIG_MTD_NAND_CM_X270)		+= cmx270_nand.o
 obj-$(CONFIG_MTD_NAND_PXA3xx)		+= pxa3xx_nand.o
+obj-$(CONFIG_MTD_NAND_SLC_LPC32XX) += lpc32xx_nand.o
 obj-$(CONFIG_MTD_NAND_TMIO)		+= tmio_nand.o
 obj-$(CONFIG_MTD_NAND_PLATFORM)		+= plat_nand.o
 obj-$(CONFIG_MTD_ALAUDA)		+= alauda.o
diff --git a/drivers/mtd/nand/lpc32xx_nand.c b/drivers/mtd/nand/lpc32xx_nand.c
new file mode 100644
index 0000000..0bd6406
--- /dev/null
+++ b/drivers/mtd/nand/lpc32xx_nand.c
@@ -0,0 +1,1101 @@
+/*
+ * drivers/mtd/nand/lpc32xx_nand.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2011 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/partitions.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/delay.h>
+
+#include <linux/io.h>
+#include <linux/mm.h>
+#include <linux/dma-mapping.h>
+#include <linux/mtd/nand_ecc.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/slcnand.h>
+#include <mach/dmac.h>
+#include <mach/dma.h>
+
+/*
+ * Temporary workaround for DMA/NAND support. There seems to be an issue when
+ * using dma_map_single for NAND buffers in very rare cases. When this issue
+ * happens, the NAND data will be corrupted. This tends to happen only when
+ * under heavy NAND load. For now, keep this define enabled.
+ */
+#define USE_DMA_STATIC_BUFFERS
+
+#define LPC32XX_MODNAME			"lpc32xx-nand"
+
+/*
+ * DMA requires storage space for the DMA local buffer and the hardware ECC
+ * storage area. The DMA local buffer is only used if DMA mapping fails
+ * during runtime.
+ */
+#define LPC32XX_DMA_DATA_SIZE		4096
+#define LPC32XX_ECC_SAVE_SIZE		((4096 / 256) * 4)
+
+/* Number of bytes used for ECC stored in NAND per 256 bytes */
+#define LPC32XX_SLC_DEV_ECC_BYTES	3
+
+/*
+ * 2 DMA descriptors are needed for every 256 byte data transfer, 1 descriptor
+ * is for the data, and the other is for the saved ECC data. These are not
+ * needed for OOB data.
+ */
+#define LPC32XX_MAX_DMA_DESCRIPTORS	(((4096 / 256) * 2) + 1)
+
+/*
+ * If the NAND base clock frequency can't be fetched, this frequency will be
+ * used instead as the base. This rate is used to setup the timing registers
+ * used for NAND accesses.
+ */
+#define LPC32XX_DEF_BUS_RATE		133250000
+
+/* DMA transfer completion failure timeout */
+#define LPC32XX_DMA_WAIT_TIMEOUT_MS	20
+
+/*
+ * This timeout is used for verifying the NAND buffer has commited it's
+ * FIFO to memory or FLASH, or verifying the DMA transfer has completed.
+ * The timeout is used as a count for simple polled checks of the hardware.
+ * For most hardware, the actual timeouts are much lower than this, but
+ * very slow hardware may use most of this time.
+ */
+#define LPC32XX_DMA_SIMPLE_TIMEOUT	10000
+
+/*
+ * This is the number of reads of the ECC register after a DMA write to
+ * the NAND device. On writes, the DMA data is buffered in the NAND controller
+ * prior to ECC calculation, so the DMA transfer 'completes' prior to the
+ * NAND controller completing the transfer and ECC calculation for the write
+ * data. Because of this, the initial reads of the ECC register by the DMA
+ * controller may be incorrect as the data is still in transfer, so multiple
+ * reads are needed. With very slow NAND devices, this count may need to be
+ * increased. This doesn't apply to read operations.
+ */
+#define LPC32XX_DMA_ECC_REP_READ	10
+
+/*
+ * NAND ECC Layout for small page NAND devices
+ * Note: For large and huge page devices, the default layouts are used
+ */
+static struct nand_ecclayout lpc32xx_nand_oob_16 = {
+	.eccbytes = 6,
+	.eccpos = {10, 11, 12, 13, 14, 15},
+	.oobfree = {
+	        {.offset = 0,
+	         . length = 4},
+	        {.offset = 6,
+	         . length = 4}}
+};
+
+static uint8_t bbt_pattern[] = {'B', 'b', 't', '0' };
+static uint8_t mirror_pattern[] = {'1', 't', 'b', 'B' };
+
+/*
+ * Small page FLASH BBT descriptors, marker at offset 0, version at offset 6
+ * Note: Large page devices used the default layout
+ */
+static struct nand_bbt_descr bbt_smallpage_main_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	0,
+	.len = 4,
+	.veroffs = 6,
+	.maxblocks = 4,
+	.pattern = bbt_pattern
+};
+
+static struct nand_bbt_descr bbt_smallpage_mirror_descr = {
+	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
+		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
+	.offs =	0,
+	.len = 4,
+	.veroffs = 6,
+	.maxblocks = 4,
+	.pattern = mirror_pattern
+};
+
+struct lpc32xx_nand_host {
+	struct nand_chip	nand_chip;
+	struct clk		*clk;
+	struct mtd_info		mtd;
+	void __iomem		*io_base;
+	struct lpc32XX_nand_cfg	*ncfg;
+
+	wait_queue_head_t	dma_waitq;
+	volatile u32		dmapending;
+	struct dma_config	dmacfg;
+	int			dmach;
+	volatile uint32_t	dma_xfer_status;
+	uint32_t		llptr;
+	uint32_t		dma_buf_len;
+	/*
+	 * DMA and CPU addresses of ECC work area and data buffer
+	 */
+	dma_addr_t		ecc_buf_dma;
+	uint32_t		*ecc_buf;
+	dma_addr_t		data_buf_dma;
+	uint8_t			*data_buf;
+	dma_addr_t		io_base_dma;
+};
+
+static void lpc32xx_nand_setup(struct lpc32xx_nand_host *host)
+{
+	u32 clkrate, tmp;
+
+	/* Reset SLC controller */
+	__raw_writel(SLCCTRL_SW_RESET, SLC_CTRL(host->io_base));
+	udelay(1000);
+
+	/* Basic setup */
+	__raw_writel(0, SLC_CFG(host->io_base));
+	__raw_writel(0, SLC_IEN(host->io_base));
+	__raw_writel((SLCSTAT_INT_TC | SLCSTAT_INT_RDY_EN),
+		SLC_ICR(host->io_base));
+
+	/* Get base clock for SLC block */
+	clkrate = clk_get_rate(host->clk);
+	if (clkrate == 0)
+		clkrate = LPC32XX_DEF_BUS_RATE;
+
+	/* Compute clock setup values */
+	tmp = SLCTAC_WDR(host->ncfg->wdr_clks) |
+		SLCTAC_WWIDTH(1 + (clkrate / host->ncfg->wwidth)) |
+		SLCTAC_WHOLD(1 + (clkrate / host->ncfg->whold)) |
+		SLCTAC_WSETUP(1 + (clkrate / host->ncfg->wsetup)) |
+		SLCTAC_RDR(host->ncfg->rdr_clks) |
+		SLCTAC_RWIDTH(1 + (clkrate / host->ncfg->rwidth)) |
+		SLCTAC_RHOLD(1 + (clkrate / host->ncfg->rhold)) |
+		SLCTAC_RSETUP(1 + (clkrate / host->ncfg->rsetup));
+	__raw_writel(tmp, SLC_TAC(host->io_base));
+}
+
+/*
+ * Hardware specific access to control lines
+ */
+static void lpc32xx_nand_cmd_ctrl(struct mtd_info *mtd, int cmd,
+	unsigned int ctrl)
+{
+	u32 tmp;
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+
+	/* Does CE state need to be changed? */
+	tmp = __raw_readl(SLC_CFG(host->io_base));
+	if (ctrl & NAND_NCE)
+		tmp |= SLCCFG_CE_LOW;
+	else
+		tmp &= ~SLCCFG_CE_LOW;
+	__raw_writel(tmp, SLC_CFG(host->io_base));
+
+	if (cmd != NAND_CMD_NONE) {
+		if (ctrl & NAND_CLE)
+			__raw_writel(cmd, SLC_CMD(host->io_base));
+		else
+			__raw_writel(cmd, SLC_ADDR(host->io_base));
+	}
+}
+
+/*
+ * Read the Device Ready pin
+ */
+static int lpc32xx_nand_device_ready(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+	int rdy = 0;
+
+	if ((__raw_readl(SLC_STAT(host->io_base)) & SLCSTAT_NAND_READY) != 0)
+		rdy = 1;
+
+	return rdy;
+}
+
+/*
+ * Enable NAND write protect
+ */
+static void lpc32xx_wp_enable(struct lpc32xx_nand_host *host)
+{
+	if (host->ncfg->enable_write_prot != NULL)
+		/* Disable write protection */
+		host->ncfg->enable_write_prot(1);
+}
+
+/*
+ * Disable NAND write protect
+ */
+static void lpc32xx_wp_disable(struct lpc32xx_nand_host *host)
+{
+	if (host->ncfg->enable_write_prot != NULL)
+		/* Enable write protection */
+		host->ncfg->enable_write_prot(0);
+}
+
+/*
+ * Prepares SLC for transfers with H/W ECC enabled
+ */
+static void lpc32xx_nand_ecc_enable(struct mtd_info *mtd, int mode)
+{
+	(void)mtd;
+	(void)mode;
+
+	/* Hardware ECC is enabled automatically in hardware as needed */
+}
+
+/*
+ * Calculates the ECC for the data
+ */
+static int lpc32xx_nand_ecc_calculate(struct mtd_info *mtd,
+	const unsigned char *buf, unsigned char *code)
+{
+	(void) mtd;
+	(void) buf;
+	(void) code;
+
+	/*
+	 * ECC is calculated automatically in hardware during syndrome read
+	 * and write operations, so it doesn't need to be calculated here.
+	 */
+
+	return 0;
+}
+
+/*
+ * Read a single byte from NAND device
+ */
+static uint8_t lpc32xx_nand_read_byte(struct mtd_info *mtd)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+
+	return (uint8_t) __raw_readl(SLC_DATA(host->io_base));
+}
+
+/*
+ * Simple device read without ECC
+ */
+static void lpc32xx_nand_read_buf(struct mtd_info *mtd, u_char *buf, int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+
+	/* Direct device read with no ECC */
+	while (len-- > 0)
+		*buf++ = (uint8_t) __raw_readl(SLC_DATA(host->io_base));
+}
+
+/*
+ * Simple device write without ECC
+ */
+static void lpc32xx_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf,
+	int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+
+	/* Direct device write with no ECC */
+	while (len-- > 0)
+		__raw_writel((u32) *buf++, SLC_DATA(host->io_base));
+}
+
+/*
+ * Verify data in buffer to data on device
+ */
+static int lpc32xx_verify_buf(struct mtd_info *mtd, const uint8_t *buf,
+	int len)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+	int i;
+
+	/* DATA register must be read as 32 bits or it will fail */
+	for (i = 0; i < len; i++) {
+		if (buf[i] != (uint8_t) __raw_readl(SLC_DATA(host->io_base)))
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+/*
+ * Read the OOB data from the device without ECC using FIFO method
+ */
+static int lpc32xx_nand_read_oob_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, int page, int sndcmd)
+{
+	(void)page;
+
+	if (sndcmd) {
+		chip->cmdfunc(mtd, NAND_CMD_READOOB, 0, page);
+		sndcmd = 0;
+	}
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return sndcmd;
+}
+
+/*
+ * Write the OOB data to the device without ECC using FIFO method
+ */
+static int lpc32xx_nand_write_oob_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, int page)
+{
+	int status;
+
+	chip->cmdfunc(mtd, NAND_CMD_SEQIN, mtd->writesize, page);
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* Send command to program the OOB data */
+	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
+
+	status = chip->waitfunc(mtd, chip);
+
+	return status & NAND_STATUS_FAIL ? -EIO : 0;
+}
+
+/*
+ * Fills in the ECC fields in the OOB buffer with the hardware generated ECC
+ */
+static void lpc32xx_slc_ecc_copy(uint8_t *spare, const uint32_t *ecc,
+	int count)
+{
+	int i;
+
+	for (i = 0; i < (count * 3); i += 3) {
+		uint32_t ce = ecc[i / 3];
+		ce = ~(ce << 2) & 0xFFFFFF;
+		spare[i + 2] = (uint8_t)(ce & 0xFF);
+		ce >>= 8;
+		spare[i + 1] = (uint8_t)(ce & 0xFF);
+		ce >>= 8;
+		spare[i] = (uint8_t)(ce & 0xFF);
+	}
+}
+
+/*
+ * Configure DMA descriptors and enable DMA channel for data and ECC reads
+ */
+static void lpc32xx_nand_dma_configure(struct mtd_info *mtd,
+	dma_addr_t databuf, int eccsubpages, int read)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+	uint32_t ecc_ctrl, *ecc_buf;
+	uint32_t dataaddr, data_ctrl;
+	int i;
+
+	/* DMA buffer pointer for calculated ECC values */
+	ecc_buf = (uint32_t *)host->ecc_buf_dma;
+
+	/*
+	 * ctrl descriptor entry for reading ECC
+	 */
+	ecc_ctrl = DMAC_CHAN_SRC_BURST_1 |
+		DMAC_CHAN_DEST_BURST_1 |
+		DMAC_CHAN_SRC_WIDTH_32 |
+		DMAC_CHAN_DEST_WIDTH_32 |
+		DMAC_CHAN_DEST_AHB1;
+
+	/* data descriptor entry for reading/writing data */
+	data_ctrl = ((mtd->writesize / eccsubpages) / 4) |
+		DMAC_CHAN_SRC_BURST_4 |
+		DMAC_CHAN_DEST_BURST_4 |
+		DMAC_CHAN_SRC_WIDTH_32 |
+		DMAC_CHAN_DEST_WIDTH_32 |
+		DMAC_CHAN_DEST_AHB1;
+
+	if (read) {
+		data_ctrl |= DMAC_CHAN_DEST_AUTOINC;
+		ecc_ctrl |= DMAC_CHAN_TRANSFER_SIZE(1);
+	} else {
+		data_ctrl |= DMAC_CHAN_SRC_AUTOINC;
+		ecc_ctrl |= DMAC_CHAN_TRANSFER_SIZE(LPC32XX_DMA_ECC_REP_READ);
+	}
+
+	/*
+	 * Only transfer the data areas plus ECC from hardware. The last ECC
+	 * from hardware and OOB area will be transferred later.
+	 */
+	dataaddr = (uint32_t)databuf;
+
+	for (i = 0; i < eccsubpages; i++) {
+		if ((i == (eccsubpages - 1)) &&
+			(!host->ncfg->polled_completion))
+			data_ctrl |= DMAC_CHAN_INT_TC_EN;
+
+		if (read)
+			lpc32xx_dma_queue_llist(host->dmach,
+				(void *)SLC_DMA_DATA(host->io_base_dma),
+				(void *)dataaddr, -1, data_ctrl);
+		else
+			lpc32xx_dma_queue_llist(host->dmach, (void *)dataaddr,
+				(void *)SLC_DMA_DATA(host->io_base_dma), -1,
+				data_ctrl);
+
+		dataaddr += (uint32_t)chip->ecc.size;;
+
+		if (i != (eccsubpages - 1)) {
+			lpc32xx_dma_queue_llist(host->dmach,
+				(void *)SLC_ECC(host->io_base_dma),
+				(void *)ecc_buf, -1, ecc_ctrl);
+			ecc_buf++;;
+		}
+	}
+}
+
+/*
+ * DMA read/write transfers with ECC support
+ */
+static int lpc32xx_dma_xfer(struct mtd_info *mtd, uint8_t *buf,
+	int eccsubpages, int read)
+{
+	struct nand_chip *chip = mtd->priv;
+	struct lpc32xx_nand_host *host = chip->priv;
+	uint32_t config;
+	dma_addr_t buf_phy;
+	int i, timeout, dma_mapped = 0, status = 0;
+
+#ifndef USE_DMA_STATIC_BUFFERS
+	/* Map DMA buffer */
+	if (likely((void *) buf < high_memory)) {
+		buf_phy = dma_map_single(mtd->dev.parent, buf, mtd->writesize,
+			read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+		if (unlikely(dma_mapping_error(mtd->dev.parent, buf_phy)))
+			dev_err(mtd->dev.parent,
+				"Unable to map DMA buffer\n");
+		else
+			dma_mapped = 1;
+	}
+#endif
+
+	if (!dma_mapped) {
+		buf_phy = host->data_buf_dma;
+		if (!read)
+			memcpy(host->data_buf, buf, mtd->writesize);
+			/* Need map sync here? */
+	}
+
+	if (read) {
+		config = DMAC_CHAN_ITC | DMAC_CHAN_IE | DMAC_CHAN_FLOW_D_P2M |
+			DMAC_DEST_PERIP (0) |
+			DMAC_SRC_PERIP(DMA_PERID_NAND1) | DMAC_CHAN_ENABLE;
+
+		__raw_writel(__raw_readl(SLC_CFG(host->io_base)) |
+			SLCCFG_DMA_DIR | SLCCFG_ECC_EN | SLCCFG_DMA_ECC |
+			SLCCFG_DMA_BURST, SLC_CFG(host->io_base));
+	} else {
+		config = DMAC_CHAN_ITC | DMAC_CHAN_IE | DMAC_CHAN_FLOW_D_M2P |
+			DMAC_DEST_PERIP(DMA_PERID_NAND1) |
+			DMAC_SRC_PERIP (0) | DMAC_CHAN_ENABLE;
+
+		__raw_writel(__raw_readl(SLC_CFG(host->io_base)) |
+			SLCCFG_ECC_EN | SLCCFG_DMA_ECC |SLCCFG_DMA_BURST,
+			SLC_CFG(host->io_base));
+		__raw_writel(__raw_readl(SLC_CFG(host->io_base)) &
+			~SLCCFG_DMA_DIR, SLC_CFG(host->io_base));
+	}
+
+	/* Clear initial ECC */
+	__raw_writel(SLCCTRL_ECC_CLEAR, SLC_CTRL(host->io_base));
+
+	/* Prepare DMA descriptors */
+	lpc32xx_nand_dma_configure(mtd, buf_phy, chip->ecc.steps, read);
+
+	/* Transfer size is data area only */
+	__raw_writel(mtd->writesize, SLC_TC(host->io_base));
+
+	/* Start transfer in the NAND controller */
+	__raw_writel(__raw_readl(SLC_CTRL(host->io_base)) | SLCCTRL_DMA_START,
+		SLC_CTRL(host->io_base));
+
+	/* Start DMA to process NAND controller DMA FIFO */
+	host->dmapending = 0;
+	lpc32xx_dma_start_xfer(host->dmach, config);
+
+	/*
+	 * On some systems, the DMA transfer will be very fast, so there is no
+	 * point in waiting for the transfer to complete using the interrupt
+	 * method. It's best to just poll the transfer here to prevent several
+	 * costly context changes. This is especially true for systems that
+	 * use small page devices or NAND devices with very fast access.
+	 */
+	if (host->ncfg->polled_completion) {
+		timeout = LPC32XX_DMA_SIMPLE_TIMEOUT;
+		while ((timeout > 0) && lpc32xx_dma_is_active(host->dmach))
+			timeout--;
+		if (timeout == 0) {
+			dev_err(mtd->dev.parent,
+				"DMA transfer timeout error\n");
+			status = -EIO;
+
+			/* Switch to non-polled mode */
+			host->ncfg->polled_completion = false;
+		}
+	}
+
+	if (!host->ncfg->polled_completion) {
+		/* Wait till DMA transfer is done or timeout occurs */
+		wait_event_timeout(host->dma_waitq, host->dmapending,
+			msecs_to_jiffies(LPC32XX_DMA_WAIT_TIMEOUT_MS));
+		if (host->dma_xfer_status != 0) {
+			dev_err(mtd->dev.parent, "DMA transfer error\n");
+			status = -EIO;
+		}
+	}
+
+	/*
+	 * The DMA is finished, but the NAND controller may still have
+	 * buffered data. Wait until all the data is sent.
+	 */
+	timeout = LPC32XX_DMA_SIMPLE_TIMEOUT;
+	while ((__raw_readl(SLC_STAT(host->io_base)) & SLCSTAT_DMA_FIFO)
+		&& (timeout > 0))
+		timeout--;
+	if (timeout == 0) {
+		dev_err(mtd->dev.parent, "FIFO held data too long\n");
+		status = -EIO;
+	}
+
+	/* Read last calculated ECC value */
+	if (read)
+		host->ecc_buf[chip->ecc.steps - 1] =
+			__raw_readl(SLC_ECC(host->io_base));
+	else {
+		/* Just clears ECC */
+		for (i = 0; i < LPC32XX_DMA_ECC_REP_READ; i++)
+			host->ecc_buf[chip->ecc.steps - 1] =
+				__raw_readl(SLC_ECC(host->io_base));
+	}
+
+	/* Flush DMA link list */
+	lpc32xx_dma_flush_llist(host->dmach);
+
+	if (__raw_readl(SLC_STAT(host->io_base)) & SLCSTAT_DMA_FIFO ||
+		__raw_readl(SLC_TC(host->io_base))) {
+		/* Something is left in the FIFO, something is wrong */
+		dev_err(mtd->dev.parent, "DMA FIFO failure\n");
+		status = -EIO;
+	}
+
+	/* Stop DMA & HW ECC */
+	__raw_writel(__raw_readl(SLC_CTRL(host->io_base)) &
+		~SLCCTRL_DMA_START, SLC_CTRL(host->io_base));
+	__raw_writel(__raw_readl(SLC_CFG(host->io_base)) & ~(SLCCFG_DMA_DIR |
+		SLCCFG_ECC_EN | SLCCFG_DMA_ECC | SLCCFG_DMA_BURST),
+		SLC_CFG(host->io_base));
+
+	if (dma_mapped)
+		dma_unmap_single(mtd->dev.parent, buf_phy, mtd->writesize,
+			read ? DMA_FROM_DEVICE : DMA_TO_DEVICE);
+	else if (read)
+		memcpy(buf, host->data_buf, mtd->writesize);
+
+	return status;
+}
+
+/*
+ * Read the data and OOB data from the device, use ECC correction with the
+ * data, disable ECC for the OOB data
+ */
+static int lpc32xx_nand_read_page_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, uint8_t *buf, int page)
+{
+	struct lpc32xx_nand_host *host = chip->priv;
+	int stat, i, status;
+	uint8_t *oobecc, tmpecc[LPC32XX_ECC_SAVE_SIZE];
+
+	/* Issue read command */
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+
+	/* Read data and oob, calculate ECC */
+	status = lpc32xx_dma_xfer(mtd, buf, chip->ecc.steps, 1);
+
+	/* Get OOB data */
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	/* Convert to stored ECC format */
+	lpc32xx_slc_ecc_copy(tmpecc, (uint32_t *) host->ecc_buf,
+		chip->ecc.steps);
+
+	/* Pointer to ECC data retrieved from NAND spare area */
+	oobecc = chip->oob_poi + chip->ecc.layout->eccpos[0];
+
+	for (i = 0; i < chip->ecc.steps; i++) {
+		stat = chip->ecc.correct(mtd, buf, oobecc,
+			&tmpecc[i * chip->ecc.bytes]);
+		if (stat < 0)
+			mtd->ecc_stats.failed++;
+		else
+			mtd->ecc_stats.corrected += stat;
+
+		buf += chip->ecc.size;
+		oobecc += chip->ecc.bytes;
+	}
+
+	return status;
+}
+
+/*
+ * Read the data and OOB data from the device, no ECC correction with the
+ * data or OOB data
+ */
+static int lpc32xx_nand_read_page_raw_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, uint8_t *buf, int page)
+{
+	/* Issue read command */
+	chip->cmdfunc(mtd, NAND_CMD_READ0, 0, page);
+
+	/* Raw reads can just use the FIFO interface */
+	chip->read_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);
+	chip->read_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return 0;
+}
+
+/*
+ * Write the data and OOB data to the device, use ECC with the data,
+ * disable ECC for the OOB data
+ */
+static void lpc32xx_nand_write_page_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, const uint8_t *buf)
+{
+	struct lpc32xx_nand_host *host = chip->priv;
+	uint8_t *pb = chip->oob_poi + chip->ecc.layout->eccpos[0];
+
+	/* Write data, calculate ECC on outbound data */
+	lpc32xx_dma_xfer(mtd, (uint8_t *)buf, chip->ecc.steps, 0);
+
+	/*
+	 * The calculated ECC needs some manual work done to it before
+	 * committing it to NAND. Process the calculated ECC and place
+	 * the resultant values directly into the OOB buffer. */
+	lpc32xx_slc_ecc_copy(pb, (uint32_t *) host->ecc_buf, chip->ecc.steps);
+
+	/* Write ECC data to device */
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+}
+
+/*
+ * Write the data and OOB data to the device, no ECC correction with the
+ * data or OOB data
+ */
+static void lpc32xx_nand_write_page_raw_syndrome(struct mtd_info *mtd,
+	struct nand_chip *chip, const uint8_t *buf)
+{
+	/* Raw writes can just use the FIFO interface */
+	chip->write_buf(mtd, buf, chip->ecc.size * chip->ecc.steps);
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+}
+
+/*
+ * DMA ISR - occurs when DMA transfer complete.
+ */
+static void lpc3xxx_nand_dma_irq(int channel, int cause,
+			struct lpc32xx_nand_host *host)
+{
+	host->dma_xfer_status = (cause & DMA_TC_INT) ? 0: 1;
+	host->dmapending = 1;
+	wake_up(&host->dma_waitq);
+}
+
+/*
+ * Get DMA channel and allocate DMA descriptors memory.
+ * Prepare DMA descriptors link lists
+ */
+static int lpc32xx_nand_dma_setup(struct lpc32xx_nand_host *host,
+	int num_entries)
+{
+	int ret = 0;
+
+	host->dmach = DMA_CH_SLCNAND;
+	host->dmacfg.ch = DMA_CH_SLCNAND;
+
+	/*
+	 * All the DMA configuration parameters will
+	 * be overwritten in lpc32xx_nand_dma_configure().
+	 */
+	host->dmacfg.tc_inten = 1;
+	host->dmacfg.err_inten = 1;
+	host->dmacfg.src_size = 4;
+	host->dmacfg.src_inc = 1;
+	host->dmacfg.src_ahb1 = 1;
+	host->dmacfg.src_bsize = DMAC_CHAN_SRC_BURST_4;
+	host->dmacfg.src_prph = 0;
+	host->dmacfg.dst_size = 4;
+	host->dmacfg.dst_inc = 0;
+	host->dmacfg.dst_bsize = DMAC_CHAN_DEST_BURST_4;
+	host->dmacfg.dst_ahb1 = 0;
+	host->dmacfg.dst_prph = DMAC_DEST_PERIP(DMA_PERID_NAND1);
+	host->dmacfg.flowctrl = DMAC_CHAN_FLOW_D_M2P;
+	if (lpc32xx_dma_ch_get(&host->dmacfg, LPC32XX_MODNAME,
+		&lpc3xxx_nand_dma_irq, host) < 0) {
+		dev_err(host->mtd.dev.parent, "Error setting up SLC NAND "
+			"DMA channel\n");
+		ret = -ENODEV;
+		goto dma_ch_err;
+	}
+
+	/*
+	 * Allocate Linked list of DMA Descriptors
+	 */
+	host->llptr = lpc32xx_dma_alloc_llist(host->dmach, num_entries);
+	if (host->llptr == 0) {
+		lpc32xx_dma_ch_put(host->dmach);
+		host->dmach = -1;
+		dev_err(host->mtd.dev.parent,
+			"Error allocating list buffer for SLC NAND\n");
+		ret = -ENOMEM;
+		goto dma_alloc_err;
+	}
+
+	return ret;
+dma_alloc_err:
+	lpc32xx_dma_ch_put(host->dmach);
+dma_ch_err:
+	return ret;
+}
+
+static int __init lpc32xx_add_partitions(struct lpc32xx_nand_host *host)
+{
+	struct mtd_info *mtd = &host->mtd;
+	struct mtd_partition *partitions = NULL;
+	int num_partitions = 0;
+
+#ifdef CONFIG_MTD_CMDLINE_PARTS
+	static const char *part_probes[] = { "cmdlinepart", NULL };
+
+	mtd->name = LPC32XX_MODNAME;
+	num_partitions = parse_mtd_partitions(mtd, part_probes,
+					      &partitions, 0);
+#endif
+	if ((num_partitions <= 0) && (host->ncfg->partition_info))
+		partitions = host->ncfg->partition_info(mtd->size,
+			&num_partitions);
+
+	if ((!partitions) || (num_partitions == 0)) {
+		dev_err(mtd->dev.parent,"No parititions defined,"
+			" or unsupported device.\n");
+		return ENXIO;
+	}
+	
+    /* Register the partitions */
+	return mtd_device_parse_register(mtd, NULL, 0,
+		partitions, num_partitions);
+}
+
+/*
+ * Probe for NAND controller
+ */
+static int __devinit lpc32xx_nand_probe(struct platform_device *pdev)
+{
+	struct lpc32xx_nand_host *host;
+	struct mtd_info *mtd;
+	struct nand_chip *chip;
+	struct resource *rc;
+	int res;
+
+	rc = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (rc == NULL) {
+		dev_err(&pdev->dev,"No memory resource found for"
+			" device\n");
+		return -ENXIO;
+	}
+
+	/* Allocate memory for the device structure (and zero it) */
+	host = kzalloc(sizeof(struct lpc32xx_nand_host), GFP_KERNEL);
+	if (!host) {
+		dev_err(&pdev->dev,"failed to allocate device structure\n");
+		return -ENOMEM;
+	}
+	host->io_base_dma = (dma_addr_t) rc->start;
+
+	host->io_base = ioremap(rc->start, rc->end - rc->start + 1);
+	if (host->io_base == NULL) {
+		dev_err(&pdev->dev,"ioremap failed\n");
+		res = -EIO;
+		goto err_exit1;
+	}
+
+	host->ncfg = pdev->dev.platform_data;
+	if (!host->ncfg) {
+		dev_err(&pdev->dev,"Missing platform data\n");
+		res = -ENOENT;
+		goto err_exit1;
+	}
+
+	mtd = &host->mtd;
+	chip = &host->nand_chip;
+	chip->priv = host;
+	mtd->priv = chip;
+	mtd->owner = THIS_MODULE;
+	mtd->dev.parent = &pdev->dev;
+
+	/* Get NAND clock */
+	host->clk = clk_get(&pdev->dev, "nand_ck");
+	if (IS_ERR(host->clk)) {
+		 dev_err(&pdev->dev,"Clock failure\n");
+		res = -ENOENT;
+		goto err_exit2;
+	}
+	clk_enable(host->clk);
+
+	/* Set NAND IO addresses and command/ready functions */
+	chip->IO_ADDR_R = SLC_DATA(host->io_base);
+	chip->IO_ADDR_W = SLC_DATA(host->io_base);
+	chip->cmd_ctrl = lpc32xx_nand_cmd_ctrl;
+	chip->dev_ready = lpc32xx_nand_device_ready;
+	chip->chip_delay = 20; /* 20us command delay time */
+
+	/* Init NAND controller */
+	lpc32xx_nand_setup(host);
+	lpc32xx_wp_disable(host);
+
+	platform_set_drvdata(pdev, host);
+
+	/* NAND callbacks for LPC32xx SLC hardware */
+	chip->ecc.mode = NAND_ECC_HW_SYNDROME;
+	chip->read_byte = lpc32xx_nand_read_byte;
+	chip->read_buf = lpc32xx_nand_read_buf;
+	chip->write_buf = lpc32xx_nand_write_buf;
+	chip->ecc.read_page_raw = lpc32xx_nand_read_page_raw_syndrome;
+	chip->ecc.read_page = lpc32xx_nand_read_page_syndrome;
+	chip->ecc.write_page_raw = lpc32xx_nand_write_page_raw_syndrome;
+	chip->ecc.write_page = lpc32xx_nand_write_page_syndrome;
+	chip->ecc.write_oob = lpc32xx_nand_write_oob_syndrome;
+	chip->ecc.read_oob = lpc32xx_nand_read_oob_syndrome;
+	chip->ecc.calculate = lpc32xx_nand_ecc_calculate;
+	chip->ecc.correct   = nand_correct_data;
+	chip->ecc.hwctl = lpc32xx_nand_ecc_enable;
+	chip->verify_buf = lpc32xx_verify_buf;
+
+	/*
+	 * Allocate a large enough buffer for a single huge page plus
+	 * extra space for the spare area and ECC storage area
+	 */
+	host->dma_buf_len = LPC32XX_DMA_DATA_SIZE + LPC32XX_ECC_SAVE_SIZE;
+	host->data_buf = dma_alloc_coherent(&pdev->dev, host->dma_buf_len,
+		&host->data_buf_dma, GFP_KERNEL);
+	if (host->data_buf == NULL) {
+		dev_err(&pdev->dev, "Error allocating memory\n");
+		res = -ENOMEM;
+		goto err_exit3;
+	}
+
+	/* Get free DMA channel and alloc DMA descriptor link list */
+	res = lpc32xx_nand_dma_setup(host, LPC32XX_MAX_DMA_DESCRIPTORS);
+	if(res) {
+		res = -EIO;
+		goto err_exit4;
+	}
+
+	init_waitqueue_head(&host->dma_waitq);
+
+	/* Find NAND device */
+	if (nand_scan_ident(mtd, 1, NULL)) {
+		res = -ENXIO;
+		goto err_exit5;
+	}
+
+	/* OOB and ECC CPU and DMA work areas */
+	host->ecc_buf_dma = host->data_buf_dma + LPC32XX_DMA_DATA_SIZE;
+	host->ecc_buf = (uint32_t *) (host->data_buf + LPC32XX_DMA_DATA_SIZE);
+
+	/*
+	 * Small page FLASH has a unique OOB layout, but large and huge
+	 * page FLASH use the standard layout. Small page FLASH uses a
+	 * custom BBT marker layout.
+	 */
+	if (mtd->writesize <= 512)
+		chip->ecc.layout = &lpc32xx_nand_oob_16;
+
+	/* These sizes remain the same regardless of page size */
+	chip->ecc.size = 256;
+	chip->ecc.bytes = LPC32XX_SLC_DEV_ECC_BYTES;
+	chip->ecc.prepad = chip->ecc.postpad = 0;
+
+	/* Avoid extra scan if using BBT, setup BBT support */
+	if (host->ncfg->use_bbt) {
+		chip->options |= NAND_SKIP_BBTSCAN;
+		chip->bbt_options |= NAND_BBT_USE_FLASH;
+
+		/*
+		 * Use a custom BBT marker setup for small page FLASH that
+		 * won't interfere with the ECC layout. Large and huge page
+		 * FLASH use the standard layout.
+		 */
+		if (mtd->writesize <= 512) {
+			chip->bbt_td = &bbt_smallpage_main_descr;
+			chip->bbt_md = &bbt_smallpage_mirror_descr;
+		}
+	}
+
+	/*
+	 * Fills out all the uninitialized function pointers with the defaults
+	 */
+	if (nand_scan_tail(mtd)) {
+		res = -ENXIO;
+		goto err_exit5;
+	}
+
+	/* Standard layout in FLASH for bad block tables */
+	if (host->ncfg->use_bbt) {
+		if (nand_default_bbt(mtd) < 0)
+			dev_err(&pdev->dev, "Error initializing default bad"
+				" block tables\n");
+	}
+
+	res = lpc32xx_add_partitions(host);
+	if (!res)
+		return res;
+
+	nand_release(mtd);
+
+err_exit5:
+	/* Free the DMA channel used by us */
+	lpc32xx_dma_ch_disable(host->dmach);
+	lpc32xx_dma_dealloc_llist(host->dmach);
+	lpc32xx_dma_ch_put(host->dmach);
+	host->dmach = -1;
+err_exit4:
+	dma_free_coherent(&pdev->dev, host->dma_buf_len,
+		host->data_buf, host->data_buf_dma);
+err_exit3:
+	clk_disable(host->clk);
+	clk_put(host->clk);
+	platform_set_drvdata(pdev, NULL);
+err_exit2:
+	lpc32xx_wp_enable(host);
+	iounmap(host->io_base);
+err_exit1:
+	kfree(host);
+
+	return res;
+}
+
+/*
+ * Remove NAND device.
+ */
+static int __devexit lpc32xx_nand_remove(struct platform_device *pdev)
+{
+	u32 tmp;
+	struct lpc32xx_nand_host *host = platform_get_drvdata(pdev);
+	struct mtd_info *mtd = &host->mtd;
+
+	nand_release(mtd);
+
+	/* Free the DMA channel used by us */
+	lpc32xx_dma_ch_disable(host->dmach);
+	lpc32xx_dma_dealloc_llist(host->dmach);
+	lpc32xx_dma_ch_put(host->dmach);
+	host->dmach = -1;
+
+	dma_free_coherent(&pdev->dev, host->dma_buf_len,
+		host->data_buf, host->data_buf_dma);
+
+	/* Force CE high */
+	tmp = __raw_readl(SLC_CTRL(host->io_base));
+	tmp &= ~SLCCFG_CE_LOW;
+	__raw_writel(tmp, SLC_CTRL(host->io_base));
+
+	lpc32xx_wp_enable(host);
+	clk_disable(host->clk);
+	clk_put(host->clk);
+
+	iounmap(host->io_base);
+
+	kfree(host);
+
+	return 0;
+}
+
+#if defined (CONFIG_PM)
+static int lpc32xx_nand_resume(struct platform_device *pdev)
+{
+	struct lpc32xx_nand_host *host = platform_get_drvdata(pdev);
+
+	/* Re-enable NAND clock */
+	clk_enable(host->clk);
+
+	/* Fresh init of NAND controller */
+	lpc32xx_nand_setup(host);
+
+	/* Disable write protect */
+	lpc32xx_wp_disable(host);
+
+	return 0;
+}
+
+static int lpc32xx_nand_suspend(struct platform_device *pdev, pm_message_t pm)
+{
+	u32 tmp;
+	struct lpc32xx_nand_host *host = platform_get_drvdata(pdev);
+
+	/* Force CE high */
+	tmp = __raw_readl(SLC_CTRL(host->io_base));
+	tmp &= ~SLCCFG_CE_LOW;
+	__raw_writel(tmp, SLC_CTRL(host->io_base));
+
+	/* Enable write protect for safety */
+	lpc32xx_wp_enable(host);
+
+	/* Disable clock */
+	clk_disable(host->clk);
+
+	return 0;
+}
+
+#else
+#define lpc32xx_nand_resume NULL
+#define lpc32xx_nand_suspend NULL
+#endif
+
+static struct platform_driver lpc32xx_nand_driver = {
+	.probe		= lpc32xx_nand_probe,
+	.remove		= __devexit_p(lpc32xx_nand_remove),
+	.resume		= lpc32xx_nand_resume,
+	.suspend	= lpc32xx_nand_suspend,
+	.driver		= {
+		.name	= LPC32XX_MODNAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init lpc32xx_nand_init(void)
+{
+	return platform_driver_register(&lpc32xx_nand_driver);
+}
+
+static void __exit lpc32xx_nand_exit(void)
+{
+	platform_driver_unregister(&lpc32xx_nand_driver);
+}
+
+module_init(lpc32xx_nand_init);
+module_exit(lpc32xx_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Kevin Wells(kevin.wells@nxp.com)");
+MODULE_DESCRIPTION("NAND driver for the NXP LPC32XX SLC controller");
+
diff --git a/drivers/net/ethernet/Kconfig b/drivers/net/ethernet/Kconfig
index 3474a61..7dd432c 100644
--- a/drivers/net/ethernet/Kconfig
+++ b/drivers/net/ethernet/Kconfig
@@ -111,6 +111,7 @@ config FEALNX
 	  cards. <http://www.myson.com.tw/>
 
 source "drivers/net/ethernet/natsemi/Kconfig"
+source "drivers/net/ethernet/nxp/Kconfig"
 source "drivers/net/ethernet/8390/Kconfig"
 
 config NET_NETX
diff --git a/drivers/net/ethernet/Makefile b/drivers/net/ethernet/Makefile
index 08d5f03..a3220bb 100644
--- a/drivers/net/ethernet/Makefile
+++ b/drivers/net/ethernet/Makefile
@@ -44,6 +44,7 @@ obj-$(CONFIG_MIPS_SIM_NET) += mipsnet.o
 obj-$(CONFIG_NET_VENDOR_MYRI) += myricom/
 obj-$(CONFIG_FEALNX) += fealnx.o
 obj-$(CONFIG_NET_VENDOR_NATSEMI) += natsemi/
+obj-$(CONFIG_NET_VENDOR_NXP) += nxp/
 obj-$(CONFIG_NET_NETX) += netx-eth.o
 obj-$(CONFIG_NET_VENDOR_NUVOTON) += nuvoton/
 obj-$(CONFIG_NET_VENDOR_NVIDIA) += nvidia/
diff --git a/drivers/net/ethernet/nxp/Kconfig b/drivers/net/ethernet/nxp/Kconfig
new file mode 100644
index 0000000..e5ccccc
--- /dev/null
+++ b/drivers/net/ethernet/nxp/Kconfig
@@ -0,0 +1,25 @@
+config NET_VENDOR_NXP
+        bool "NXP devices"
+        default n
+        depends on ARCH_LPC32XX
+        ---help---
+          If you have a network (Ethernet) card belonging to this class, say Y
+          and read the Ethernet-HOWTO, available from
+          <http://www.tldp.org/docs.html#howto>.
+
+          Note that the answer to this question doesn't directly affect the
+          kernel: saying N will just cause the configurator to skip all
+          the questions about National Semi-conductor devices. If you say Y,
+          you will be asked for your specific card in the following questions.
+
+if NET_VENDOR_NXP
+
+config LPC_ENET
+       tristate "NXP ethernet MAC on LPC devices"
+       depends on ARCH_LPC32XX
+       select PHYLIB
+       help
+               Say Y here if you want to use the NXP ethernet MAC included
+               on some NXP LPC devices.
+
+endif # NET_VENDOR_NXP
diff --git a/drivers/net/ethernet/nxp/Makefile b/drivers/net/ethernet/nxp/Makefile
new file mode 100644
index 0000000..79a1ddd
--- /dev/null
+++ b/drivers/net/ethernet/nxp/Makefile
@@ -0,0 +1,5 @@
+#
+## Makefile for the NXP Ethernet devices.
+#
+
+obj-$(CONFIG_LPC_ENET) += lpc_eth.o
diff --git a/drivers/net/ethernet/nxp/lpc_eth.c b/drivers/net/ethernet/nxp/lpc_eth.c
new file mode 100644
index 0000000..ad02a76
--- /dev/null
+++ b/drivers/net/ethernet/nxp/lpc_eth.c
@@ -0,0 +1,1343 @@
+/*
+ * drivers/net/lpc-eth.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/errno.h>
+#include <linux/ioport.h>
+#include <linux/crc32.h>
+#include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <linux/ethtool.h>
+#include <linux/mii.h>
+#include <linux/clk.h>
+#include <linux/workqueue.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/phy.h>
+
+#include <asm/delay.h>
+#include <asm/io.h>
+#include <mach/board.h>
+#if defined(CONFIG_ARCH_LPC32XX_IRAM_FOR_NET)
+#include <mach/hardware.h>
+#endif
+#include "lpc_eth.h"
+
+#define MODNAME "lpc-net"
+#define DRV_VERSION "$Revision: 1.00 $"
+#define PHYDEF_ADDR 0x00
+
+#define ENET_MAXF_SIZE 1536
+#define ENET_RX_DESC 48
+#define ENET_TX_DESC 16
+
+#if defined(CONFIG_ARCH_LPC32XX_IRAM_FOR_NET)
+extern u32 lpc32xx_return_iram_size(void);
+#endif
+
+// FIXME
+// Dynamic buffer allocation as needed
+// Check/fix ethtool support
+// Better MAC address support
+// Better DMA allocation support (dma pool)
+// MII/RMII support (only supports RMII as of now)
+
+static int lpc_net_hard_start_xmit(struct sk_buff *skb,
+	struct net_device *ndev);
+
+/*
+ * Transmit timeout, default 2.5 seconds.
+ */
+static int watchdog = 2500;
+module_param(watchdog, int, 0400);
+MODULE_PARM_DESC(watchdog, "transmit timeout in milliseconds");
+
+/*
+ * Default local config if board config is not defined
+ */
+static struct lpc_net_cfg __lpc_local_net_config = {
+	.phy_irq = -1,
+	.phy_mask = 0xFFFFFFF0,
+};
+
+/*
+ * Device driver data structure
+ */
+struct netdata_local {
+	struct platform_device	*pdev;
+	struct net_device	*ndev;
+	spinlock_t		lock;
+	void __iomem		*net_base;
+	unsigned long		net_region_start;
+	unsigned long		net_region_size;
+	u32			msg_enable;
+	struct sk_buff		*skb[ENET_TX_DESC];
+	unsigned int		last_tx_idx;
+	unsigned int		num_used_tx_buffs;
+	struct mii_bus		*mii_bus;
+	struct phy_device	*phy_dev;
+	struct clk		*clk;
+	u32			dma_buff_base_p;
+	u32			dma_buff_base_v;
+	u32			dma_buff_size;
+	u32			tx_desc_v [ENET_TX_DESC];
+	u32			tx_stat_v [ENET_TX_DESC];
+	u32			tx_buff_v [ENET_TX_DESC];
+	u32			rx_desc_v [ENET_RX_DESC];
+	u32			rx_stat_v [ENET_RX_DESC];
+	u32			rx_buff_v [ENET_RX_DESC];
+	struct lpc_net_cfg	*ncfg;
+	int			link;
+	int			speed;
+	int			duplex;
+};
+
+/*
+ * MAC address is provided as a boot paramter (ethaddr) via u-boot
+ */
+static u8 mac_address[6] = {0};
+
+static int __init ethaddr(char *str)
+{
+        char *s, *e;
+        int i;
+
+        s = str;
+        for (i = 0; i < 6; ++i) {
+                mac_address[i] = s ? simple_strtoul (s, &e, 16) : 0;
+                if (s)
+                        s = (*e) ? e + 1 : e;
+        }
+        return 1;
+}
+__setup("ethaddr=", ethaddr);
+
+static int get_mac_addr(u8 *mac)
+{
+        int i;
+
+        for (i = 0; i < 6; i++) {
+                mac[i] = mac_address[i];
+        }
+        return 0;
+}
+
+/*
+ * MAC support functions
+ */
+static void __lpc_set_mac(struct netdata_local *pldat, u8 *mac)
+{
+	u32 tmp;
+
+	/* Set station address */
+	tmp = (u32) mac[0] | ((u32) mac[1] << 8);
+	writel(tmp, LPC_ENET_SA2(pldat->net_base));
+	tmp = (u32) mac[2] | ((u32) mac[3] << 8);
+	writel(tmp, LPC_ENET_SA1(pldat->net_base));
+	tmp = (u32) mac[4] | ((u32) mac[5] << 8);
+	writel(tmp, LPC_ENET_SA0(pldat->net_base));
+
+	pr_debug("Ethernet MAC address %02x:%02x:%02x:%02x:%02x:%02x\n",
+		mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
+}
+
+static void __lpc_net_clock_enable(struct netdata_local *pldat,
+	int enable)
+{
+	if (enable)
+		clk_enable(pldat->clk);
+	else
+		clk_disable(pldat->clk);
+}
+
+static void __lpc_params_setup(struct netdata_local *pldat)
+{
+	u32 tmp;
+
+	if (pldat->duplex == DUPLEX_FULL) {
+		tmp = readl(LPC_ENET_MAC2(pldat->net_base));
+		tmp |= LPC_MAC2_FULL_DUPLEX;
+		writel(tmp, LPC_ENET_MAC2(pldat->net_base));
+		tmp = readl(LPC_ENET_COMMAND(pldat->net_base));
+		tmp |= LPC_COMMAND_FULLDUPLEX;
+		writel(tmp, LPC_ENET_COMMAND(pldat->net_base));
+		writel(LPC_IPGT_LOAD(0x15), LPC_ENET_IPGT(pldat->net_base));
+	} else {
+		tmp = readl(LPC_ENET_MAC2(pldat->net_base));
+		tmp &= ~LPC_MAC2_FULL_DUPLEX;
+		writel(tmp, LPC_ENET_MAC2(pldat->net_base));
+		tmp = readl(LPC_ENET_COMMAND(pldat->net_base));
+		tmp &= ~LPC_COMMAND_FULLDUPLEX;
+		writel(tmp, LPC_ENET_COMMAND(pldat->net_base));
+		writel(LPC_IPGT_LOAD(0x12), LPC_ENET_IPGT(pldat->net_base));
+	}
+
+	if (pldat->speed == SPEED_100)
+		writel(LPC_SUPP_SPEED, LPC_ENET_SUPP(pldat->net_base));
+	else
+		writel(0, LPC_ENET_SUPP(pldat->net_base));
+}
+
+static void __lpc_eth_reset(struct netdata_local *pldat)
+{
+	/* Reset all MAC logic */
+	writel((LPC_MAC1_RESET_TX | LPC_MAC1_RESET_MCS_TX | LPC_MAC1_RESET_RX |
+		LPC_MAC1_RESET_MCS_RX | LPC_MAC1_SIMULATION_RESET |
+		LPC_MAC1_SOFT_RESET), LPC_ENET_MAC1(pldat->net_base));
+	writel((LPC_COMMAND_REG_RESET | LPC_COMMAND_TXRESET |
+		LPC_COMMAND_RXRESET), LPC_ENET_COMMAND(pldat->net_base));
+}
+
+static int __lpc_mii_mngt_reset(struct netdata_local *pldat)
+{
+	/* Reset MII management hardware */
+	writel(LPC_MCFG_RESET_MII_MGMT, LPC_ENET_MCFG(pldat->net_base));
+
+	/* Setup MII clock to slowest rate with a /28 divider */
+	writel(LPC_MCFG_CLOCK_SELECT(LPC_MCFG_CLOCK_HOST_DIV_28),
+		LPC_ENET_MCFG(pldat->net_base));
+
+	return 0;
+}
+
+static u32 __ptr_align(u32 pbuff)
+{
+	pbuff &= 0xFFFFFFF0;
+	pbuff += 0x10;
+
+	return pbuff;
+}
+
+static inline u32 __va_to_pa(u32 addr, struct netdata_local *pldat)
+{
+	u32 phaddr;
+
+	phaddr = addr - pldat->dma_buff_base_v;
+	phaddr += pldat->dma_buff_base_p;
+
+	return phaddr;
+}
+
+/* Setup TX/RX descriptors */
+static void __lpc_txrx_desc_setup(struct netdata_local *pldat)
+{
+	u32 tbuff, *ptxstat;
+	int i;
+	struct txrx_desc_t *ptxrxdesc;
+	struct rx_status_t *prxstat;
+
+	tbuff = __ptr_align(pldat->dma_buff_base_v);
+
+	/* Setup TX descriptors, status, and buffers */
+	for (i = 0; i < ENET_TX_DESC; i++) {
+		pldat->tx_desc_v [i] = tbuff;
+		tbuff += sizeof(struct txrx_desc_t);
+	}
+	for (i = 0; i < ENET_TX_DESC; i++) {
+		pldat->tx_stat_v [i] = tbuff;
+		tbuff += sizeof(u32);
+	}
+	tbuff = __ptr_align(tbuff);
+	for (i = 0; i < ENET_TX_DESC; i++) {
+		pldat->tx_buff_v [i] = tbuff;
+		tbuff += ENET_MAXF_SIZE;
+	}
+
+	/* Setup RX descriptors, status, and buffers */
+	for (i = 0; i < ENET_RX_DESC; i++) {
+		pldat->rx_desc_v [i] = tbuff;
+		tbuff += sizeof(struct txrx_desc_t);
+	}
+	tbuff = __ptr_align(tbuff);
+	for (i = 0; i < ENET_RX_DESC; i++) {
+		pldat->rx_stat_v [i] = tbuff;
+		tbuff += sizeof(struct rx_status_t);
+	}
+	tbuff = __ptr_align(tbuff);
+	for (i = 0; i < ENET_RX_DESC; i++) {
+		pldat->rx_buff_v [i] = tbuff;
+		tbuff += ENET_MAXF_SIZE;
+	}
+
+	/* Map the TX descriptors to the TX buffers in hardware */
+	for (i = 0; i < ENET_TX_DESC; i++) {
+		ptxstat = (u32 *) pldat->tx_stat_v [i];
+		ptxrxdesc = (struct txrx_desc_t *) pldat->tx_desc_v [i];
+
+		ptxrxdesc->packet = __va_to_pa(pldat->tx_buff_v [i], pldat);
+		ptxrxdesc->control = 0;
+		*ptxstat = 0;
+	}
+
+	/* Map the RX descriptors to the RX buffers in hardware */
+	for (i = 0; i < ENET_RX_DESC; i++) {
+		prxstat = (struct rx_status_t *) pldat->rx_stat_v [i];
+		ptxrxdesc = (struct txrx_desc_t *) pldat->rx_desc_v [i];
+
+		ptxrxdesc->packet = __va_to_pa(pldat->rx_buff_v [i], pldat);
+		ptxrxdesc->control = 0x80000000 | (ENET_MAXF_SIZE - 1);
+		prxstat->statusinfo = 0;
+		prxstat->statushashcrc = 0;
+	}
+
+	/* Setup base addresses in hardware to point to buffers and
+	   descriptors */
+	writel((ENET_TX_DESC - 1),
+		LPC_ENET_TXDESCRIPTORNUMBER(pldat->net_base));
+	writel(__va_to_pa(pldat->tx_desc_v [0], pldat),
+		LPC_ENET_TXDESCRIPTOR(pldat->net_base));
+	writel(__va_to_pa(pldat->tx_stat_v [0], pldat),
+		LPC_ENET_TXSTATUS(pldat->net_base));
+	writel((ENET_RX_DESC - 1),
+		LPC_ENET_RXDESCRIPTORNUMBER(pldat->net_base));
+	writel(__va_to_pa(pldat->rx_desc_v [0], pldat),
+		LPC_ENET_RXDESCRIPTOR(pldat->net_base));
+	writel(__va_to_pa(pldat->rx_stat_v [0], pldat),
+		LPC_ENET_RXSTATUS(pldat->net_base));
+}
+
+static void __lpc_eth_init(struct netdata_local *pldat)
+{
+	u32 tmp;
+
+	/* Disable controller and reset */
+	tmp = readl(LPC_ENET_COMMAND(pldat->net_base));
+	tmp &= ~LPC_COMMAND_RXENABLE | LPC_COMMAND_TXENABLE;
+	writel(tmp, LPC_ENET_COMMAND(pldat->net_base));
+	tmp = readl(LPC_ENET_MAC1(pldat->net_base));
+	tmp &= ~LPC_MAC1_RECV_ENABLE;
+	writel(tmp, LPC_ENET_MAC1(pldat->net_base));
+
+	/* Initial MAC setup */
+	writel(LPC_MAC1_PASS_ALL_RX_FRAMES, LPC_ENET_MAC1(pldat->net_base));
+	writel((LPC_MAC2_PAD_CRC_ENABLE | LPC_MAC2_CRC_ENABLE),
+		LPC_ENET_MAC2(pldat->net_base));
+	writel(ENET_MAXF_SIZE, LPC_ENET_MAXF(pldat->net_base));
+
+	/* Collision window, gap */
+	writel((LPC_CLRT_LOAD_RETRY_MAX(0xF) |
+		LPC_CLRT_LOAD_COLLISION_WINDOW(0x37)),
+		LPC_ENET_CLRT(pldat->net_base));
+	writel(LPC_IPGR_LOAD_PART2(0x12), LPC_ENET_IPGR(pldat->net_base));
+
+#if defined (CONFIG_ARCH_LPC32XX_MII_SUPPORT)
+	writel(LPC_COMMAND_PASSRUNTFRAME, LPC_ENET_COMMAND(pldat->net_base));
+#else
+	writel((LPC_COMMAND_PASSRUNTFRAME | LPC_COMMAND_RMII),
+		LPC_ENET_COMMAND(pldat->net_base));
+	writel(LPC_SUPP_RESET_RMII, LPC_ENET_SUPP(pldat->net_base));
+#endif
+
+	__lpc_params_setup(pldat);
+
+	/* Setup TX and RX descriptors */
+	__lpc_txrx_desc_setup(pldat);
+
+	/* Setup packet filtering */
+	writel((LPC_RXFLTRW_ACCEPTUBROADCAST | LPC_RXFLTRW_ACCEPTPERFECT),
+		LPC_ENET_RXFILTER_CTRL(pldat->net_base));
+
+	/* Clear and enable interrupts */
+	writel(0xFFFF, LPC_ENET_INTCLEAR(pldat->net_base));
+	writel((LPC_MACINT_RXDONEINTEN | LPC_MACINT_TXDONEINTEN),
+		LPC_ENET_INTENABLE(pldat->net_base));
+
+	/* Get the next TX buffer output index */
+	pldat->num_used_tx_buffs = 0;
+	pldat->last_tx_idx =
+		readl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));
+
+	/* Enable controller */
+	tmp = readl(LPC_ENET_COMMAND(pldat->net_base));
+	tmp |= LPC_COMMAND_RXENABLE | LPC_COMMAND_TXENABLE;
+	writel(tmp, LPC_ENET_COMMAND(pldat->net_base));
+	tmp = readl(LPC_ENET_MAC1(pldat->net_base));
+	tmp |= LPC_MAC1_RECV_ENABLE;
+	writel(tmp, LPC_ENET_MAC1(pldat->net_base));
+}
+
+static void __lpc_net_shutdown(struct netdata_local *pldat)
+{
+	/* Reset ethernet and power down PHY */
+	__lpc_eth_reset(pldat);
+	writel(0, LPC_ENET_MAC1(pldat->net_base));
+	writel(0, LPC_ENET_MAC2(pldat->net_base));
+}
+
+/*
+ * MAC<--->PHY support functions
+ */
+static int lpc_mdio_read(struct mii_bus *bus, int phy_id, int phyreg)
+{
+	struct netdata_local *pldat = bus->priv;
+	unsigned long timeout = jiffies + msecs_to_jiffies(100);
+	int lps;
+
+	writel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));
+	writel(LPC_MCMD_READ, LPC_ENET_MCMD(pldat->net_base));
+
+	/* Wait for unbusy status */
+	while (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {
+		if (time_after(jiffies,timeout))
+			return -EIO;
+		cpu_relax();
+	}
+
+	lps = (int) readl(LPC_ENET_MRDD(pldat->net_base));
+	writel(0, LPC_ENET_MCMD(pldat->net_base));
+
+	return lps;
+}
+
+static int lpc_mdio_write(struct mii_bus *bus, int phy_id, int phyreg,
+			u16 phydata)
+{
+	struct netdata_local *pldat = bus->priv;
+	unsigned long timeout = jiffies + msecs_to_jiffies(100);
+
+	writel(((phy_id << 8) | phyreg), LPC_ENET_MADR(pldat->net_base));
+	writel(phydata, LPC_ENET_MWTD(pldat->net_base));
+
+	/* Wait for completion */
+	while (readl(LPC_ENET_MIND(pldat->net_base)) & LPC_MIND_BUSY) {
+		if (time_after(jiffies,timeout))
+			return -EIO;
+		cpu_relax();
+	}
+
+	return 0;
+}
+
+static int lpc_mdio_reset(struct mii_bus *bus)
+{
+	return __lpc_mii_mngt_reset((struct netdata_local *) bus->priv);
+}
+
+static void lpc_handle_link_change(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct phy_device *phydev = pldat->phy_dev;
+	unsigned long flags;
+
+	int status_change = 0;
+
+	spin_lock_irqsave(&pldat->lock, flags);
+
+	if (phydev->link) {
+		if ((pldat->speed != phydev->speed) ||
+		    (pldat->duplex != phydev->duplex)) {
+			pldat->speed = phydev->speed;
+			pldat->duplex = phydev->duplex;
+			status_change = 1;
+		}
+	}
+
+	if (phydev->link != pldat->link) {
+		if (!phydev->link) {
+			pldat->speed = 0;
+			pldat->duplex = -1;
+		}
+		pldat->link = phydev->link;
+
+		status_change = 1;
+	}
+
+	spin_unlock_irqrestore(&pldat->lock, flags);
+
+	if (status_change)
+		__lpc_params_setup(pldat);
+}
+
+static int lpc_mii_probe(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct phy_device *phydev = NULL;
+	int phy_addr;
+
+	/* find the first phy */
+	for (phy_addr = 0; phy_addr < PHY_MAX_ADDR; phy_addr++) {
+		if (pldat->mii_bus->phy_map[phy_addr]) {
+			phydev = pldat->mii_bus->phy_map[phy_addr];
+			break;
+		}
+	}
+
+	if (!phydev) {
+		pr_err("%s: no PHY found\n", ndev->name);
+		return -ENODEV;
+	}
+
+	/* Attach to the PHY */
+#if defined (CONFIG_ARCH_LPC32XX_MII_SUPPORT)
+	pr_info("%s: using MII interface\n", ndev->name);
+	phydev = phy_connect(ndev, dev_name(&phydev->dev),
+		&lpc_handle_link_change, 0, PHY_INTERFACE_MODE_MII);
+#else
+	pr_info("%s: using RMII interface\n", ndev->name);
+	phydev = phy_connect(ndev, dev_name(&phydev->dev),
+		&lpc_handle_link_change, 0, PHY_INTERFACE_MODE_RMII);
+#endif
+
+	if (IS_ERR(phydev)) {
+		pr_err("%s: Could not attach to PHY\n", ndev->name);
+		return PTR_ERR(phydev);
+	}
+
+	/* mask with MAC supported features */
+	phydev->supported &= PHY_BASIC_FEATURES;
+
+	phydev->advertising = phydev->supported;
+
+	pldat->link = 0;
+	pldat->speed = 0;
+	pldat->duplex = -1;
+	pldat->phy_dev = phydev;
+
+	return 0;
+}
+
+static int lpc_mii_init(struct netdata_local *pldat)
+{
+	int err = -ENXIO, i;
+
+	pldat->mii_bus = mdiobus_alloc();
+	if (!pldat->mii_bus) {
+		err = -ENOMEM;
+		goto err_out;
+	}
+
+	/* Setup MII mode */
+#if defined (CONFIG_ARCH_LPC32XX_MII_SUPPORT)
+	writel(LPC_COMMAND_PASSRUNTFRAME, LPC_ENET_COMMAND(pldat->net_base));
+#else
+	writel((LPC_COMMAND_PASSRUNTFRAME | LPC_COMMAND_RMII),
+		LPC_ENET_COMMAND(pldat->net_base));
+	writel(LPC_SUPP_RESET_RMII, LPC_ENET_SUPP(pldat->net_base));
+#endif
+
+	pldat->mii_bus->name = "lpc_mii_bus";
+	pldat->mii_bus->read = &lpc_mdio_read;
+	pldat->mii_bus->write = &lpc_mdio_write;
+	pldat->mii_bus->reset = &lpc_mdio_reset;
+	snprintf(pldat->mii_bus->id, MII_BUS_ID_SIZE, "%x", pldat->pdev->id);
+	pldat->mii_bus->priv = pldat;
+	pldat->mii_bus->parent = &pldat->pdev->dev;
+	pldat->mii_bus->phy_mask = 0xFFFFFFF0;
+
+	if (pldat->ncfg)
+		pldat->mii_bus->phy_mask = pldat->ncfg->phy_mask;
+
+	pldat->mii_bus->irq = kmalloc(sizeof(int) * PHY_MAX_ADDR, GFP_KERNEL);
+	if (!pldat->mii_bus->irq) {
+		err = -ENOMEM;
+		goto err_out_1;
+	}
+
+	for (i = 0; i < PHY_MAX_ADDR; i++)
+		pldat->mii_bus->irq[i] = PHY_POLL;
+
+	//platform_set_drvdata(pldat->ndev, pldat->mii_bus);
+
+	if (mdiobus_register(pldat->mii_bus)) {
+		goto err_out_free_mdio_irq;
+	}
+
+	if (lpc_mii_probe(pldat->ndev) != 0) {
+		goto err_out_unregister_bus;
+	}
+
+	return 0;
+
+err_out_unregister_bus:
+	mdiobus_unregister(pldat->mii_bus);
+err_out_free_mdio_irq:
+	kfree(pldat->mii_bus->irq);
+err_out_1:
+	mdiobus_free(pldat->mii_bus);
+err_out:
+	return err;
+}
+
+static void __lpc_handle_xmit(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct sk_buff *skb;
+	unsigned int txcidx, *ptxstat, txstat;
+
+	txcidx = readl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));
+	while (pldat->last_tx_idx != txcidx)
+	{
+		skb = (struct sk_buff *) pldat->skb[pldat->last_tx_idx];
+
+		/* A buffer is available, get buffer status */
+		ptxstat = (unsigned int *) pldat->tx_stat_v[pldat->last_tx_idx];
+		txstat = *ptxstat;
+
+		/* Next buffer and decrement used buffer counter */
+		pldat->num_used_tx_buffs--;
+		pldat->last_tx_idx++;
+		if (pldat->last_tx_idx >= ENET_TX_DESC)
+			pldat->last_tx_idx = 0;
+
+		/* Update collision counter */
+		ndev->stats.collisions += ((txstat >> 21) & 0xF);
+
+		/* Any errors occurred? */
+		if (txstat & 0x80000000) {
+			if (txstat & 0x20000000) {
+				/* FIFO underrun */
+				ndev->stats.tx_fifo_errors++;
+				ndev->stats.tx_errors++;
+			}
+			if (txstat & 0x10000000) {
+				/* Late collision */
+				ndev->stats.tx_aborted_errors++;
+				ndev->stats.tx_errors++;
+			}
+			if (txstat & 0x08000000) {
+				/* Excessive collision */
+				ndev->stats.tx_aborted_errors++;
+				ndev->stats.tx_errors++;
+			}
+			if (txstat & 0x04000000) {
+				/* Defer limit */
+				ndev->stats.tx_aborted_errors++;
+				ndev->stats.tx_errors++;
+			}
+
+			/* Buffer transmit failed, requeue it */
+			lpc_net_hard_start_xmit(skb, ndev);
+		} else {
+			/* Update stats */
+			ndev->stats.tx_packets++;
+			ndev->stats.tx_bytes += skb->len;
+
+			/* Free buffer */
+			dev_kfree_skb_irq(skb);
+		}
+
+		txcidx = readl(LPC_ENET_TXCONSUMEINDEX(pldat->net_base));
+	}
+
+	if (netif_queue_stopped(ndev))
+		netif_wake_queue(ndev);
+}
+
+static void __lpc_handle_recv(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct sk_buff *skb;
+	int rxconsidx, len, ethst;
+	struct rx_status_t *prxstat;
+	u8 *prdbuf;
+
+	/* Get the current RX buffer indexes */
+	rxconsidx = (int) readl(LPC_ENET_RXCONSUMEINDEX(pldat->net_base));
+	while (rxconsidx != (int) readl(LPC_ENET_RXPRODUCEINDEX(pldat->net_base)))
+	{
+		/* Get pointer to receive status */
+		prxstat = (struct rx_status_t *) pldat->rx_stat_v [rxconsidx];
+		len = (prxstat->statusinfo & 0x7FF) + 1;
+
+		/* Status error? */
+		ethst = prxstat->statusinfo;
+		if ((ethst & 0xBF800000) == 0x84000000)
+			ethst &= ~0x80000000;
+
+		if (ethst & 0x80000000) {
+			/* Check statuses */
+			if (prxstat->statusinfo & (1 << 28)) {
+				/* Overrun error */
+				ndev->stats.rx_fifo_errors++;
+			} else if (prxstat->statusinfo & (1 << 23)) {
+				/* CRC error */
+				ndev->stats.rx_crc_errors++;
+			} else if (prxstat->statusinfo & (1 << 25)) {
+				/* Length error */
+				ndev->stats.rx_length_errors++;
+			} else if (prxstat->statusinfo & 0x80000000) {
+				/* Other error */
+				ndev->stats.rx_length_errors++;
+			}
+			ndev->stats.rx_errors++;
+		} else {
+			/* Packet is good */
+			skb = dev_alloc_skb(len + 8);
+			if (!skb)
+				ndev->stats.rx_dropped++;
+			else {
+				skb_reserve(skb, 8);
+				prdbuf = skb_put(skb, (len - 0));
+
+				/* Copy packer from buffer */
+				memcpy(prdbuf, (void *) pldat->rx_buff_v [rxconsidx], len);
+
+				/* Pass to upper layer */
+				skb->protocol = eth_type_trans(skb, ndev);
+				netif_rx(skb);
+				ndev->last_rx = jiffies;
+				ndev->stats.rx_packets++;
+				ndev->stats.rx_bytes += len;
+			}
+		}
+
+		/* Increment consume index */
+		rxconsidx = rxconsidx + 1;
+		if (rxconsidx >= ENET_RX_DESC)
+			rxconsidx = 0;
+		writel((u32) rxconsidx, LPC_ENET_RXCONSUMEINDEX(pldat->net_base));
+	}
+}
+
+static irqreturn_t __lpc_eth_interrupt(int irq, void *dev_id)
+{
+	struct net_device *ndev = dev_id;
+	struct netdata_local *pldat = netdev_priv(ndev);
+	u32 tmp;
+	unsigned long flags;
+
+	//spin_lock(&pldat->lock);
+	spin_lock_irqsave(&pldat->lock, flags);
+
+	/* Get the interrupt status */
+	tmp = readl(LPC_ENET_INTSTATUS(pldat->net_base));
+
+	while (tmp) {
+		/* Clear interrupts */
+		writel(tmp, LPC_ENET_INTCLEAR(pldat->net_base));
+
+		/* Transmit complete? */
+		if (tmp & (LPC_MACINT_TXUNDERRUNINTEN | LPC_MACINT_TXERRORINTEN |
+			LPC_MACINT_TXFINISHEDINTEN | LPC_MACINT_TXDONEINTEN))
+			__lpc_handle_xmit(ndev);
+
+		/* Receive buffer available */
+		if (tmp & (LPC_MACINT_RXOVERRUNINTEN | LPC_MACINT_RXERRORONINT |
+			LPC_MACINT_RXFINISHEDINTEN | LPC_MACINT_RXDONEINTEN))
+			__lpc_handle_recv(ndev);
+
+		/* Recheck the interrupt status */
+		tmp = readl(LPC_ENET_INTSTATUS(pldat->net_base));
+	}
+
+	//spin_unlock(&pldat->lock);
+	spin_unlock_irqrestore(&pldat->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static int lpc_net_close(struct net_device *ndev)
+{
+	unsigned long flags;
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	if (netif_msg_ifdown(pldat))
+	{
+		dev_dbg(&pldat->pdev->dev, "shutting down %s\n", ndev->name);
+	}
+
+	netif_stop_queue(ndev);
+
+	if (pldat->phy_dev)
+	{
+		phy_stop(pldat->phy_dev);
+	}
+
+	spin_lock_irqsave(&pldat->lock, flags);
+	__lpc_eth_reset(pldat);
+	netif_carrier_off(ndev);
+	writel(0, LPC_ENET_MAC1(pldat->net_base));
+	writel(0, LPC_ENET_MAC2(pldat->net_base));
+	spin_unlock_irqrestore(&pldat->lock, flags);
+
+	__lpc_net_clock_enable(pldat, 0);
+
+	return 0;
+}
+
+static int lpc_net_hard_start_xmit(struct sk_buff *skb, struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	unsigned int len, txidx;
+	u32 *ptxstat;
+	struct txrx_desc_t *ptxrxdesc;
+
+	len = skb->len;
+
+	spin_lock_irq(&pldat->lock);
+
+	if (pldat->num_used_tx_buffs >= (ENET_TX_DESC - 1)) {
+		/* This function should never be called when there are no
+		   buffers, log the error */
+		netif_stop_queue(ndev);
+		spin_unlock_irq(&pldat->lock);
+		dev_err(&pldat->pdev->dev,
+			"BUG! TX request when no free TX buffers!\n");
+		return 1;
+	}
+
+	/* Get the next TX descriptor index */
+	txidx = readl(LPC_ENET_TXPRODUCEINDEX(pldat->net_base));
+
+	/* Setup control for the transfer */
+	ptxstat = (u32 *) pldat->tx_stat_v [txidx];
+	*ptxstat = 0;
+	ptxrxdesc = (struct txrx_desc_t *) pldat->tx_desc_v [txidx];
+	ptxrxdesc->control = (len - 1) | 0xC0000000;
+
+	/* Copy data to the DMA buffer */
+	memcpy((void *) pldat->tx_buff_v [txidx], skb->data, len);
+
+	/* Save the buffer and increment the buffer counter */
+	pldat->skb[txidx] = skb;
+	pldat->num_used_tx_buffs++;
+
+	/* Start transmit */
+	txidx++;
+	if (txidx >= ENET_TX_DESC)
+		txidx = 0;
+	writel((u32) txidx, LPC_ENET_TXPRODUCEINDEX(pldat->net_base));
+
+	/* Stop queue if no more TX buffers */
+	if (pldat->num_used_tx_buffs >= (ENET_TX_DESC - 1))
+		netif_stop_queue(ndev);
+
+	spin_unlock_irq(&pldat->lock);
+	ndev->trans_start = jiffies;
+
+	return 0;
+}
+
+static void lpc_net_timeout(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	/* This should never happen and indicates a problem */
+	dev_err(&pldat->pdev->dev, "BUG! TX timeout occurred!\n");
+}
+
+static int lpc_set_mac_address(struct net_device *ndev, void *p)
+{
+        struct sockaddr *addr = p;
+	struct netdata_local *pldat = netdev_priv(ndev);
+	unsigned long flags;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+                return -EADDRNOTAVAIL;
+        memcpy(ndev->dev_addr, addr->sa_data, ETH_ALEN);
+
+	spin_lock_irqsave(&pldat->lock, flags);
+
+	/* Set station address */
+	__lpc_set_mac(pldat, ndev->dev_addr);
+
+	spin_unlock_irqrestore(&pldat->lock, flags);
+
+	return 0;
+}
+
+static void lpc_net_set_multicast_list(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct netdev_hw_addr *ha;
+	u32 tmp32, hash_val, hashlo, hashhi;
+	unsigned long flags;
+
+	spin_lock_irqsave(&pldat->lock, flags);
+
+	/* Set station address */
+	__lpc_set_mac(pldat, ndev->dev_addr);
+
+	tmp32 =  LPC_RXFLTRW_ACCEPTUBROADCAST | LPC_RXFLTRW_ACCEPTPERFECT;
+
+	if (ndev->flags & IFF_PROMISC)
+		tmp32 |= LPC_RXFLTRW_ACCEPTUNICAST | LPC_RXFLTRW_ACCEPTUMULTICAST;
+	if (ndev->flags & IFF_ALLMULTI)
+		tmp32 |= LPC_RXFLTRW_ACCEPTUMULTICAST;
+
+	if(!netdev_mc_empty(ndev))
+		tmp32 |= LPC_RXFLTRW_ACCEPTUMULTICASTHASH;
+
+	writel(tmp32, LPC_ENET_RXFILTER_CTRL(pldat->net_base));
+
+
+	/* Set initial hash table */
+	hashlo = 0x0;
+	hashhi = 0x0;
+
+	/* 64 bits : multicast address in hash table */
+	netdev_for_each_mc_addr(ha, ndev) {
+		hash_val = (ether_crc(6, ha->addr) >> 23) & 0x3F;
+
+		if (hash_val >= 32)
+			hashhi |= 1 << (hash_val - 32);
+		else
+			hashlo |= 1 << hash_val;
+	}
+
+	writel(hashlo, LPC_ENET_HASHFILTERL(pldat->net_base));
+	writel(hashhi, LPC_ENET_HASHFILTERH(pldat->net_base));
+
+	spin_unlock_irqrestore(&pldat->lock, flags);
+}
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+static void lpc_net_poll_controller(struct net_device *ndev)
+{
+	disable_irq(ndev->irq);
+	__lpc_eth_interrupt(dev->irq, ndev);
+	enable_irq(ndev->irq);
+}
+#endif
+
+static int lpc_net_ioctl(struct net_device *ndev, struct ifreq *req, int cmd)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct phy_device *phydev = pldat->phy_dev;
+
+	if (!netif_running(ndev))
+	{
+		return -EINVAL;
+	}
+
+	if (!phydev)
+	{
+		return -ENODEV;
+	}
+
+	//return phy_mii_ioctl(phydev, if_mii(req), cmd);
+	return phy_mii_ioctl(phydev, req, cmd);
+}
+
+static int lpc_net_open(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	/* if the phy is not yet registered, retry later*/
+	if (!pldat->phy_dev)
+	{
+		return -EAGAIN;
+	}
+
+	if (netif_msg_ifup(pldat))
+	{
+		dev_dbg(&pldat->pdev->dev, "enabling %s\n", ndev->name);
+	}
+
+	if (!is_valid_ether_addr(ndev->dev_addr))
+	{
+		return -EADDRNOTAVAIL;
+	}
+
+	__lpc_net_clock_enable(pldat, 1);
+
+	/* Reset and initialize */
+	__lpc_eth_reset(pldat);
+	__lpc_eth_init(pldat);
+
+	/* schedule a link state check */
+	phy_start(pldat->phy_dev);
+	netif_start_queue(ndev);
+
+	return 0;
+}
+
+/*
+ * Ethtool ops
+ */
+static void lpc_net_ethtool_getdrvinfo(struct net_device *ndev,
+	struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, MODNAME);
+	strcpy(info->version, DRV_VERSION);
+	strcpy(info->bus_info, dev_name(ndev->dev.parent));
+}
+
+static u32 lpc_net_ethtool_getmsglevel(struct net_device *ndev)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	return pldat->msg_enable;
+}
+
+static void lpc_net_ethtool_setmsglevel(struct net_device *ndev, u32 level)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	pldat->msg_enable = level;
+}
+
+static int lpc_net_ethtool_getsettings(struct net_device *ndev,
+	struct ethtool_cmd *cmd)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct phy_device *phydev = pldat->phy_dev;
+
+	if (!phydev)
+	{
+		return -ENODEV;
+	}
+
+	return phy_ethtool_gset(phydev, cmd);
+}
+
+static int lpc_net_ethtool_setsettings(struct net_device *ndev,
+	struct ethtool_cmd *cmd)
+{
+	struct netdata_local *pldat = netdev_priv(ndev);
+	struct phy_device *phydev = pldat->phy_dev;
+
+	if (!phydev)
+	{
+		return -ENODEV;
+	}
+
+	return phy_ethtool_sset(phydev, cmd);
+}
+
+static const struct ethtool_ops lpc_net_ethtool_ops = {
+	.get_drvinfo	= lpc_net_ethtool_getdrvinfo,
+	.get_settings	= lpc_net_ethtool_getsettings,
+	.set_settings	= lpc_net_ethtool_setsettings,
+	.get_msglevel	= lpc_net_ethtool_getmsglevel,
+	.set_msglevel	= lpc_net_ethtool_setmsglevel,
+	.get_link	= ethtool_op_get_link,
+};
+
+static const struct net_device_ops lpc_netdev_ops = {
+	.ndo_open		= lpc_net_open,
+	.ndo_stop		= lpc_net_close,
+	.ndo_start_xmit		= lpc_net_hard_start_xmit,
+	.ndo_set_rx_mode	= lpc_net_set_multicast_list,
+	.ndo_do_ioctl		= lpc_net_ioctl,
+	.ndo_tx_timeout		= lpc_net_timeout,
+	.ndo_set_mac_address	= lpc_set_mac_address,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.poll_controller	= lpc_net_poll_controller;
+#endif
+};
+
+static int lpc_net_drv_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct net_device *ndev;
+	struct netdata_local *pldat;
+	struct phy_device *phydev;
+	dma_addr_t dma_handle;
+	int irq, ret;
+
+	/* Get platform resources */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	irq = platform_get_irq(pdev, 0);
+	if ((!res) || (irq < 0) || (irq >= NR_IRQS)) {
+		dev_err(&pdev->dev, "error getting resources.\n");
+		ret = -ENXIO;
+		goto err_exit;
+	}
+
+	/* Allocate net driver data structure */
+	ndev = alloc_etherdev(sizeof(struct netdata_local));
+	if (!ndev) {
+		dev_err(&pdev->dev, "could not allocate device.\n");
+		ret = -ENOMEM;
+		goto err_exit;
+	}
+
+	SET_NETDEV_DEV(ndev, &pdev->dev);
+
+	pldat = netdev_priv(ndev);
+	pldat->pdev = pdev;
+	pldat->ndev = ndev;
+
+	spin_lock_init(&pldat->lock);
+
+	/* Save resources */
+	pldat->net_region_start = res->start;
+	pldat->net_region_size = res->end - res->start + 1;
+	ndev->irq = irq;
+
+	/* Get clock for the device */
+	pldat->clk = clk_get(&pdev->dev, NULL);
+	if (IS_ERR(pldat->clk)) {
+		dev_err(&pdev->dev, "error getting clock.\n");
+		ret = PTR_ERR(pldat->clk);
+		goto err_out_free_dev;
+	}
+
+	/* Enable network clock */
+	__lpc_net_clock_enable(pldat, 1);
+
+	/* Map IO space */
+	pldat->net_base = ioremap(pldat->net_region_start, pldat->net_region_size);
+	if (!pldat->net_base) {
+		dev_err(&pdev->dev, "failed to map registers\n");
+		ret = -ENOMEM;
+		goto err_out_disable_clocks;
+	}
+	ret = request_irq(ndev->irq, __lpc_eth_interrupt, 0,
+			  ndev->name, ndev);
+	if (ret) {
+		dev_err(&pdev->dev, "error requesting interrupt.\n");
+		goto err_out_iounmap;
+	}
+
+	/* Fill in the fields of the device structure with ethernet values. */
+	ether_setup(ndev);
+
+	/* Setup driver functions */
+	ndev->netdev_ops = &lpc_netdev_ops;
+	ndev->ethtool_ops = &lpc_net_ethtool_ops;
+	ndev->base_addr = pldat->net_region_start;
+	ndev->watchdog_timeo = msecs_to_jiffies(watchdog);
+
+	/* Save board specific configuration */
+	pldat->ncfg = (struct lpc_net_cfg *) pdev->dev.platform_data;
+	if (pldat->ncfg == NULL) {
+		dev_err(&pdev->dev, "error requesting interrupt.\n");
+		pldat->ncfg = &__lpc_local_net_config;
+	}
+
+	/* Get size of DMA buffers/descriptors region */
+	pldat->dma_buff_size = (ENET_TX_DESC + ENET_RX_DESC) * (ENET_MAXF_SIZE +
+		sizeof(struct txrx_desc_t) + sizeof(struct rx_status_t));
+	pldat->dma_buff_base_v = 0;
+
+#if defined(CONFIG_ARCH_LPC32XX_IRAM_FOR_NET)
+	dma_handle = (dma_addr_t) LPC32XX_IRAM_BASE;
+	if (pldat->dma_buff_size <= lpc32xx_return_iram_size())
+		pldat->dma_buff_base_v = (u32) io_p2v(LPC32XX_IRAM_BASE);
+	else
+		pr_err("%s: IRAM not big enough for net buffers, "
+			"using SDRAM instead.\n", MODNAME);
+#endif
+
+	if (pldat->dma_buff_base_v == 0) {
+		pldat->dma_buff_size += 4096; /* Allows room for alignment */
+
+		/* Align on the next highest page entry size */
+		pldat->dma_buff_size &= 0Xfffff000;
+		pldat->dma_buff_size += 0X00001000;
+
+		/* Allocate a chunk of memory for the DMA ethernet buffers and descriptors */
+		pldat->dma_buff_base_v = (u32) dma_alloc_coherent(&pldat->pdev->dev,
+			pldat->dma_buff_size, &dma_handle, GFP_KERNEL);
+
+		if (pldat->dma_buff_base_v == (u32) NULL)
+		{
+			dev_err(&pdev->dev, "error getting DMA region.\n");
+			ret = -ENOMEM;
+			goto err_out_free_irq;
+		}
+	}
+	pldat->dma_buff_base_p = (u32) dma_handle;
+
+	pr_debug("IO address start     :0x%08x\n", (u32) pldat->net_region_start);
+	pr_debug("IO address size      :%d\n", (u32) pldat->net_region_size);
+	pr_debug("IO address (mapped)  :0x%08x\n", (u32) pldat->net_base);
+	pr_debug("IRQ number           :%d\n", ndev->irq);
+	pr_debug("DMA buffer size      :%d\n", pldat->dma_buff_size);
+	pr_debug("DMA buffer P address :0x%08x\n", pldat->dma_buff_base_p);
+	pr_debug("DMA buffer V address :0x%08x\n", pldat->dma_buff_base_v);
+
+	/* Get the board MAC address */
+	ret = get_mac_addr(ndev->dev_addr);
+	if (ret) {
+		/* Mac address load error */
+		goto err_out_dma_unmap;
+	}
+	if (!is_valid_ether_addr(ndev->dev_addr)) {
+		pr_info("%s: Invalid ethernet MAC address.  Please "
+		       "set using ifconfig\n", ndev->name);
+	}
+
+	/* Reset the ethernet controller */
+	__lpc_eth_reset(pldat);
+
+	/* then shut everything down to save power */
+	__lpc_net_shutdown(pldat);
+
+	/* Set default parameters */
+	pldat->msg_enable = NETIF_MSG_LINK;
+
+	/* Force an MII interface reset and clock setup */
+	__lpc_mii_mngt_reset(pldat);
+
+	/* Force default PHY interface setup in chip, this will probably be
+	   changed by the PHY driver */
+	pldat->link = 0;
+	pldat->speed = 100;
+	pldat->duplex = DUPLEX_FULL;
+	__lpc_params_setup(pldat);
+
+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(&pdev->dev, "Cannot register net device, aborting.\n");
+		goto err_out_dma_unmap;
+	}
+	platform_set_drvdata(pdev, ndev);
+
+	if (lpc_mii_init(pldat) != 0) {
+		goto err_out_unregister_netdev;
+	}
+
+	pr_info("%s: LPC mac at 0x%08lx irq %d\n",
+	       ndev->name, ndev->base_addr, ndev->irq);
+
+	phydev = pldat->phy_dev;
+	pr_info("%s: attached PHY driver [%s] "
+		"(mii_bus:phy_addr=%s, irq=%d)\n",
+		ndev->name, phydev->drv->name, dev_name(&phydev->dev),
+		phydev->irq);
+
+	device_init_wakeup(&pdev->dev, 1);
+	device_set_wakeup_enable(&pdev->dev, 0);
+
+	return 0;
+
+err_out_unregister_netdev:
+	platform_set_drvdata(pdev, NULL);
+	unregister_netdev(ndev);
+err_out_dma_unmap:
+#if defined(CONFIG_ARCH_LPC32XX_IRAM_FOR_NET)
+	if (pldat->dma_buff_size > lpc32xx_return_iram_size())
+#endif
+	dma_free_coherent(&pldat->pdev->dev, pldat->dma_buff_size,
+		(void *) pldat->dma_buff_base_v, (dma_addr_t) pldat->dma_buff_base_p);
+err_out_free_irq:
+	free_irq(ndev->irq, ndev);
+err_out_iounmap:
+	iounmap(pldat->net_base);
+err_out_disable_clocks:
+	clk_disable(pldat->clk);
+	clk_put(pldat->clk);
+err_out_free_dev:
+	free_netdev(ndev);
+err_exit:
+	pr_err("%s: not found (%d).\n", MODNAME, ret);
+	return ret;
+}
+
+static int lpc_net_drv_remove(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	unregister_netdev(ndev);
+	platform_set_drvdata(pdev, NULL);
+
+#if defined(CONFIG_ARCH_LPC32XX_IRAM_FOR_NET)
+	if (pldat->dma_buff_size > lpc32xx_return_iram_size())
+#endif
+	dma_free_coherent(&pldat->pdev->dev, pldat->dma_buff_size,
+		(void *) pldat->dma_buff_base_v,
+		(dma_addr_t) pldat->dma_buff_base_p);
+	free_irq(ndev->irq, ndev);
+	iounmap(pldat->net_base);
+	clk_disable(pldat->clk);
+	clk_put(pldat->clk);
+	free_netdev(ndev);
+
+	return 0;
+}
+
+static int lpc_net_drv_suspend(struct platform_device *pdev,
+	pm_message_t state)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct netdata_local *pldat = netdev_priv(ndev);
+
+	if (device_may_wakeup(&pdev->dev))
+		enable_irq_wake(ndev->irq);
+
+	if (ndev) {
+		if (netif_running(ndev)) {
+			netif_device_detach(ndev);
+			__lpc_net_shutdown(pldat);
+			clk_disable(pldat->clk);
+
+			/*
+			 * Reset again now clock is disable to be sure
+			 * EMC_MDC is down
+			 */
+			__lpc_eth_reset(pldat);
+		}
+	}
+
+	return 0;
+}
+
+static int lpc_net_drv_resume(struct platform_device *pdev)
+{
+	struct net_device *ndev = platform_get_drvdata(pdev);
+	struct netdata_local *pldat;
+
+	if (device_may_wakeup(&pdev->dev))
+		disable_irq_wake(ndev->irq);
+
+	if (ndev) {
+		if (netif_running(ndev)) {
+			pldat = netdev_priv(ndev);
+
+			/* Enable interface clock */
+			clk_enable(pldat->clk);
+
+			/* Reset and initialize */
+			__lpc_eth_reset(pldat);
+			__lpc_eth_init(pldat);
+
+			netif_device_attach(ndev);
+		}
+	}
+
+	return 0;
+}
+
+static struct platform_driver lpc_net_driver = {
+	.probe		= lpc_net_drv_probe,
+	.remove		= __devexit_p(lpc_net_drv_remove),
+	.suspend	= lpc_net_drv_suspend,
+	.resume		= lpc_net_drv_resume,
+	.driver		= {
+		.name	= MODNAME,
+	},
+};
+
+static int __init lpc_net_init(void)
+{
+	return platform_driver_register(&lpc_net_driver);
+}
+
+static void __exit lpc_net_cleanup(void)
+{
+	platform_driver_unregister(&lpc_net_driver);
+}
+
+module_init(lpc_net_init);
+module_exit(lpc_net_cleanup);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com");
+MODULE_DESCRIPTION("LPC Ethernet Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/net/ethernet/nxp/lpc_eth.h b/drivers/net/ethernet/nxp/lpc_eth.h
new file mode 100644
index 0000000..1835a9d
--- /dev/null
+++ b/drivers/net/ethernet/nxp/lpc_eth.h
@@ -0,0 +1,317 @@
+/*
+ * drivers/net/lpc-eth.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __LPC_ETH_H
+#define __LPC_ETH_H
+
+#include <linux/types.h>
+
+/*
+ * Ethernet MAC controller Register offsets
+ */
+#define LPC_ENET_MAC1(x)			(x + 0x000)
+#define LPC_ENET_MAC2(x)			(x + 0x004)
+#define LPC_ENET_IPGT(x)			(x + 0x008)
+#define LPC_ENET_IPGR(x)			(x + 0x00C)
+#define LPC_ENET_CLRT(x)			(x + 0x010)
+#define LPC_ENET_MAXF(x)			(x + 0x014)
+#define LPC_ENET_SUPP(x)			(x + 0x018)
+#define LPC_ENET_TEST(x)			(x + 0x01C)
+#define LPC_ENET_MCFG(x)			(x + 0x020)
+#define LPC_ENET_MCMD(x)			(x + 0x024)
+#define LPC_ENET_MADR(x)			(x + 0x028)
+#define LPC_ENET_MWTD(x)			(x + 0x02C)
+#define LPC_ENET_MRDD(x)			(x + 0x030)
+#define LPC_ENET_MIND(x)			(x + 0x034)
+#define LPC_ENET_SA0(x)				(x + 0x040)
+#define LPC_ENET_SA1(x)				(x + 0x044)
+#define LPC_ENET_SA2(x)				(x + 0x048)
+#define LPC_ENET_COMMAND(x)			(x + 0x100)
+#define LPC_ENET_STATUS(x)			(x + 0x104)
+#define LPC_ENET_RXDESCRIPTOR(x)		(x + 0x108)
+#define LPC_ENET_RXSTATUS(x)			(x + 0x10C)
+#define LPC_ENET_RXDESCRIPTORNUMBER(x)		(x + 0x110)
+#define LPC_ENET_RXPRODUCEINDEX(x)		(x + 0x114)
+#define LPC_ENET_RXCONSUMEINDEX(x)		(x + 0x118)
+#define LPC_ENET_TXDESCRIPTOR(x)		(x + 0x11C)
+#define LPC_ENET_TXSTATUS(x)			(x + 0x120)
+#define LPC_ENET_TXDESCRIPTORNUMBER(x)		(x + 0x124)
+#define LPC_ENET_TXPRODUCEINDEX(x)		(x + 0x128)
+#define LPC_ENET_TXCONSUMEINDEX(x)		(x + 0x12C)
+#define LPC_ENET_TSV0(x)			(x + 0x158)
+#define LPC_ENET_TSV1(x)			(x + 0x15C)
+#define LPC_ENET_RSV(x)				(x + 0x160)
+#define LPC_ENET_FLOWCONTROLCOUNTER(x)		(x + 0x170)
+#define LPC_ENET_FLOWCONTROLSTATUS(x)		(x + 0x174)
+#define LPC_ENET_RXFILTER_CTRL(x)		(x + 0x200)
+#define LPC_ENET_RXFILTERWOLSTATUS(x)		(x + 0x204)
+#define LPC_ENET_RXFILTERWOLCLEAR(x)		(x + 0x208)
+#define LPC_ENET_HASHFILTERL(x)			(x + 0x210)
+#define LPC_ENET_HASHFILTERH(x)			(x + 0x214)
+#define LPC_ENET_INTSTATUS(x)			(x + 0xFE0)
+#define LPC_ENET_INTENABLE(x)			(x + 0xFE4)
+#define LPC_ENET_INTCLEAR(x)			(x + 0xFE8)
+#define LPC_ENET_INTSET(x)			(x + 0xFEC)
+#define LPC_ENET_POWERDOWN(x)			(x + 0xFF4)
+
+/*
+ * Structure of a TX/RX descriptors and RX status
+ */
+struct txrx_desc_t {
+	volatile u32 packet;
+	volatile u32 control;
+};
+struct rx_status_t {
+	volatile u32 statusinfo;
+	volatile u32 statushashcrc;
+};
+
+/*
+ * mac1 register definitions
+ */
+#define LPC_MAC1_RECV_ENABLE			(1 << 0)
+#define LPC_MAC1_PASS_ALL_RX_FRAMES		(1 << 1)
+#define LPC_MAC1_RX_FLOW_CONTROL		(1 << 2)
+#define LPC_MAC1_TX_FLOW_CONTROL		(1 << 3)
+#define LPC_MAC1_LOOPBACK			(1 << 4)
+#define LPC_MAC1_RESET_TX			(1 << 8)
+#define LPC_MAC1_RESET_MCS_TX			(1 << 9)
+#define LPC_MAC1_RESET_RX			(1 << 10)
+#define LPC_MAC1_RESET_MCS_RX			(1 << 11)
+#define LPC_MAC1_SIMULATION_RESET		(1 << 14)
+#define LPC_MAC1_SOFT_RESET			(1 << 15)
+
+/*
+ * mac2 register definitions
+ */
+#define LPC_MAC2_FULL_DUPLEX			(1 << 0)
+#define LPC_MAC2_FRAME_LENGTH_CHECKING		(1 << 1)
+#define LPC_MAC2_HUGH_LENGTH_CHECKING		(1 << 2)
+#define LPC_MAC2_DELAYED_CRC			(1 << 3)
+#define LPC_MAC2_CRC_ENABLE			(1 << 4)
+#define LPC_MAC2_PAD_CRC_ENABLE			(1 << 5)
+#define LPC_MAC2_VLAN_PAD_ENABLE		(1 << 6)
+#define LPC_MAC2_AUTO_DETECT_PAD_ENABLE		(1 << 7)
+#define LPC_MAC2_PURE_PREAMBLE_ENFORCEMENT	(1 << 8)
+#define LPC_MAC2_LONG_PREAMBLE_ENFORCEMENT	(1 << 9)
+#define LPC_MAC2_NO_BACKOFF			(1 << 12)
+#define LPC_MAC2_BACK_PRESSURE			(1 << 13)
+#define LPC_MAC2_EXCESS_DEFER			(1 << 14)
+
+/*
+ * ipgt register definitions
+ */
+#define LPC_IPGT_LOAD(n)			((n) & 0x7F)
+
+/*
+ * ipgr register definitions
+ */
+#define LPC_IPGR_LOAD_PART2(n)			((n) & 0x7F)
+#define LPC_IPGR_LOAD_PART1(n)			(((n) & 0x7F) << 8)
+
+/*
+ * clrt register definitions
+ */
+#define LPC_CLRT_LOAD_RETRY_MAX(n)		((n) & 0xF)
+#define LPC_CLRT_LOAD_COLLISION_WINDOW(n)	(((n) & 0x3F) << 8)
+
+/*
+ * maxf register definitions
+ */
+#define LPC_MAXF_LOAD_MAX_FRAME_LEN(n)		((n) & 0xFFFF)
+
+/*
+ * supp register definitions
+ */
+#define LPC_SUPP_SPEED				(1 << 8)
+#define LPC_SUPP_RESET_RMII			(1 << 11)
+
+/*
+ * test register definitions
+ */
+#define LPC_TEST_SHORTCUT_PAUSE_QUANTA		(1 << 0)
+#define LPC_TEST_PAUSE				(1 << 1)
+#define LPC_TEST_BACKPRESSURE			(1 << 2)
+
+/*
+ * mcfg register definitions
+ */
+#define LPC_MCFG_SCAN_INCREMENT			(1 << 0)
+#define LPC_MCFG_SUPPRESS_PREAMBLE		(1 << 1)
+#define LPC_MCFG_CLOCK_SELECT(n)		(((n) & 0x7) << 2)
+#define LPC_MCFG_CLOCK_HOST_DIV_4		0
+#define LPC_MCFG_CLOCK_HOST_DIV_6		2
+#define LPC_MCFG_CLOCK_HOST_DIV_8		3
+#define LPC_MCFG_CLOCK_HOST_DIV_10		4
+#define LPC_MCFG_CLOCK_HOST_DIV_14		5
+#define LPC_MCFG_CLOCK_HOST_DIV_20		6
+#define LPC_MCFG_CLOCK_HOST_DIV_28		7
+#define LPC_MCFG_RESET_MII_MGMT			(1 << 15)
+
+/*
+ * mcmd register definitions
+ */
+#define LPC_MCMD_READ				(1 << 0)
+#define LPC_MCMD_SCAN				(1 << 1)
+
+/*
+ * madr register definitions
+ */
+#define LPC_MADR_REGISTER_ADDRESS(n)		((n) & 0x1F)
+#define LPC_MADR_PHY_0ADDRESS(n)		(((n) & 0x1F) << 8)
+
+/*
+ * mwtd register definitions
+ */
+#define LPC_MWDT_WRITE(n)			((n) & 0xFFFF)
+
+/*
+ * mrdd register definitions
+ */
+#define LPC_MRDD_READ_MASK			0xFFFF
+
+/*
+ * mind register definitions
+ */
+#define LPC_MIND_BUSY				(1 << 0)
+#define LPC_MIND_SCANNING			(1 << 1)
+#define LPC_MIND_NOT_VALID			(1 << 2)
+#define LPC_MIND_MII_LINK_FAIL			(1 << 3)
+
+/*
+ * command register definitions
+ */
+#define LPC_COMMAND_RXENABLE			(1 << 0)
+#define LPC_COMMAND_TXENABLE			(1 << 1)
+#define LPC_COMMAND_REG_RESET			(1 << 3)
+#define LPC_COMMAND_TXRESET			(1 << 4)
+#define LPC_COMMAND_RXRESET			(1 << 5)
+#define LPC_COMMAND_PASSRUNTFRAME		(1 << 6)
+#define LPC_COMMAND_PASSRXFILTER		(1 << 7)
+#define LPC_COMMAND_TXFLOWCONTROL		(1 << 8)
+#define LPC_COMMAND_RMII			(1 << 9)
+#define LPC_COMMAND_FULLDUPLEX			(1 << 10)
+
+/*
+ * status register definitions
+ */
+#define LPC_STATUS_RXACTIVE			(1 << 0)
+#define LPC_STATUS_TXACTIVE			(1 << 1)
+
+/*
+ * tsv0 register definitions
+ */
+#define LPC_TSV0_CRC_ERROR			(1 << 0)
+#define LPC_TSV0_LENGTH_CHECK_ERROR		(1 << 1)
+#define LPC_TSV0_LENGTH_OUT_OF_RANGE		(1 << 2)
+#define LPC_TSV0_DONE				(1 << 3)
+#define LPC_TSV0_MULTICAST			(1 << 4)
+#define LPC_TSV0_BROADCAST			(1 << 5)
+#define LPC_TSV0_PACKET_DEFER			(1 << 6)
+#define LPC_TSV0_ESCESSIVE_DEFER		(1 << 7)
+#define LPC_TSV0_ESCESSIVE_COLLISION		(1 << 8)
+#define LPC_TSV0_LATE_COLLISION			(1 << 9)
+#define LPC_TSV0_GIANT				(1 << 10)
+#define LPC_TSV0_UNDERRUN			(1 << 11)
+#define LPC_TSV0_TOTAL_BYTES(n)			(((n) >> 12) & 0xFFFF)
+#define LPC_TSV0_CONTROL_FRAME			(1 << 28)
+#define LPC_TSV0_PAUSE				(1 << 29)
+#define LPC_TSV0_BACKPRESSURE			(1 << 30)
+#define LPC_TSV0_VLAN				(1 << 31)
+
+/*
+ * tsv1 register definitions
+ */
+#define LPC_TSV1_TRANSMIT_BYTE_COUNT(n)		((n) & 0xFFFF)
+#define LPC_TSV1_COLLISION_COUNT(n)		(((n) >> 16) & 0xF)
+
+/*
+ * rsv register definitions
+ */
+#define LPC_RSV_RECEIVED_BYTE_COUNT(n)		((n) & 0xFFFF)
+#define LPC_RSV_RXDV_EVENT_IGNORED		(1 << 16)
+#define LPC_RSV_RXDV_EVENT_PREVIOUSLY_SEEN	(1 << 17)
+#define LPC_RSV_CARRIER_EVNT_PREVIOUS_SEEN	(1 << 18)
+#define LPC_RSV_RECEIVE_CODE_VIOLATION		(1 << 19)
+#define LPC_RSV_CRC_ERROR			(1 << 20)
+#define LPC_RSV_LENGTH_CHECK_ERROR		(1 << 21)
+#define LPC_RSV_LENGTH_OUT_OF_RANGE		(1 << 22)
+#define LPC_RSV_RECEIVE_OK			(1 << 23)
+#define LPC_RSV_MULTICAST			(1 << 24)
+#define LPC_RSV_BROADCAST			(1 << 25)
+#define LPC_RSV_DRIBBLE_NIBBLE			(1 << 26)
+#define LPC_RSV_CONTROL_FRAME			(1 << 27)
+#define LPC_RSV_PAUSE				(1 << 28)
+#define LPC_RSV_UNSUPPORTED_OPCODE		(1 << 29)
+#define LPC_RSV_VLAN				(1 << 30)
+
+/*
+ * flowcontrolcounter register definitions
+ */
+#define LPC_FCCR_MIRRORCOUNTER(n)		((n) & 0xFFFF)
+#define LPC_FCCR_PAUSETIMER(n)			(((n) >> 16) & 0xFFFF)
+
+/*
+ * flowcontrolstatus register definitions
+ */
+#define LPC_FCCR_MIRRORCOUNTERCURRENT(n)	((n) & 0xFFFF)
+
+/*
+ * rxfliterctrl, rxfilterwolstatus, and rxfilterwolclear shared
+ * register definitions
+ */
+#define LPC_RXFLTRW_ACCEPTUNICAST		(1 << 0)
+#define LPC_RXFLTRW_ACCEPTUBROADCAST		(1 << 1)
+#define LPC_RXFLTRW_ACCEPTUMULTICAST		(1 << 2)
+#define LPC_RXFLTRW_ACCEPTUNICASTHASH		(1 << 3)
+#define LPC_RXFLTRW_ACCEPTUMULTICASTHASH	(1 << 4)
+#define LPC_RXFLTRW_ACCEPTPERFECT		(1 << 5)
+
+/*
+ * rxfliterctrl register definitions
+ */
+#define LPC_RXFLTRWSTS_MAGICPACKETENWOL		(1 << 12)
+#define LPC_RXFLTRWSTS_RXFILTERENWOL		(1 << 13)
+
+/*
+ * rxfilterwolstatus/rxfilterwolclear register definitions
+ */
+#define LPC_RXFLTRWSTS_RXFILTERWOL		(1 << 7)
+#define LPC_RXFLTRWSTS_MAGICPACKETWOL		(1 << 8)
+
+/*
+ * intstatus, intenable, intclear, and Intset shared register
+ * definitions
+ */
+#define LPC_MACINT_RXOVERRUNINTEN		(1 << 0)
+#define LPC_MACINT_RXERRORONINT			(1 << 1)
+#define LPC_MACINT_RXFINISHEDINTEN		(1 << 2)
+#define LPC_MACINT_RXDONEINTEN			(1 << 3)
+#define LPC_MACINT_TXUNDERRUNINTEN		(1 << 4)
+#define LPC_MACINT_TXERRORINTEN			(1 << 5)
+#define LPC_MACINT_TXFINISHEDINTEN		(1 << 6)
+#define LPC_MACINT_TXDONEINTEN			(1 << 7)
+#define LPC_MACINT_SOFTINTEN			(1 << 12)
+#define LPC_MACINT_WAKEUPINTEN			(1 << 13)
+
+/*
+ * powerdown register definitions
+ */
+#define LPC_POWERDOWN_MACAHB			(1 << 31)
+
+#endif
diff --git a/drivers/rtc/rtc-lpc32xx.c b/drivers/rtc/rtc-lpc32xx.c
index ecc1713..d242913 100644
--- a/drivers/rtc/rtc-lpc32xx.c
+++ b/drivers/rtc/rtc-lpc32xx.c
@@ -202,7 +202,7 @@ static int __devinit lpc32xx_rtc_probe(struct platform_device *pdev)
 	struct lpc32xx_rtc *rtc;
 	resource_size_t size;
 	int rtcirq;
-	u32 tmp;
+	u32 tmp, ucount, dcount;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res) {
@@ -272,6 +272,24 @@ static int __devinit lpc32xx_rtc_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, rtc);
 
+	/*
+	* Check SRAM integrity by comparing UP and DOWN counters
+	* If they don't match, reset them.
+	*/
+
+	/* Disable RTC during read (preventing count between reads) */
+	tmp = rtc_readl(rtc, LPC32XX_RTC_CTRL);
+	rtc_writel(rtc, LPC32XX_RTC_CTRL, tmp | LPC32XX_RTC_CTRL_CNTR_DIS);
+	ucount = rtc_readl(rtc, LPC32XX_RTC_UCOUNT);
+	dcount = rtc_readl(rtc, LPC32XX_RTC_DCOUNT);
+	rtc_writel(rtc, LPC32XX_RTC_CTRL, tmp &= ~LPC32XX_RTC_CTRL_CNTR_DIS);
+
+	if( (dcount + ucount) != 0xFFFFFFFF )
+	{
+		dev_dbg(&pdev->dev, "Dcount (%08X) and Ucount (%08X) mismatch, reset them.\n", dcount, ucount );
+		lpc32xx_rtc_set_mmss(&pdev->dev, 0);
+	}
+
 	rtc->rtc = rtc_device_register(RTC_NAME, &pdev->dev, &lpc32xx_rtc_ops,
 		THIS_MODULE);
 	if (IS_ERR(rtc->rtc)) {
diff --git a/drivers/tty/serial/8250/8250.c b/drivers/tty/serial/8250/8250.c
index 0e2c703..c671eac 100644
--- a/drivers/tty/serial/8250/8250.c
+++ b/drivers/tty/serial/8250/8250.c
@@ -166,10 +166,18 @@ static const struct serial8250_config uart_config[] = {
 	},
 	[PORT_16550A] = {
 		.name		= "16550A",
+#ifdef CONFIG_ARCH_LPC32XX
+		.fifo_size  = 64,
+		.tx_loadsz  = 32,
+		.fcr        = UART_FCR_DMA_SELECT | UART_FCR_ENABLE_FIFO |
+									UART_FCR_R_TRIG_00 | UART_FCR_T_TRIG_00,
+		.flags      = UART_CAP_FIFO,
+#else
 		.fifo_size	= 16,
 		.tx_loadsz	= 16,
 		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
 		.flags		= UART_CAP_FIFO,
+#endif
 	},
 	[PORT_CIRRUS] = {
 		.name		= "Cirrus",
@@ -865,7 +873,7 @@ static int broken_efr(struct uart_8250_port *up)
 	/*
 	 * Exar ST16C2550 "A2" devices incorrectly detect as
 	 * having an EFR, and report an ID of 0x0201.  See
-	 * http://linux.derkeiler.com/Mailing-Lists/Kernel/2004-11/4812.html 
+	 * http://linux.derkeiler.com/Mailing-Lists/Kernel/2004-11/4812.html
 	 */
 	if (autoconfig_read_divisor_id(up) == 0x0201 && size_fifo(up) == 16)
 		return 1;
@@ -2028,6 +2036,10 @@ static int serial8250_startup(struct uart_port *port)
 
 	if (is_real_interrupt(up->port.irq)) {
 		unsigned char iir1;
+#ifdef CONFIG_ARCH_LPC32XX
+		serial_outp(up, UART_FCR, UART_FCR_DMA_SELECT | UART_FCR_ENABLE_FIFO |
+				UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
+#endif
 		/*
 		 * Test for UARTs that do not reassert THRE when the
 		 * transmitter is idle and the interrupt has already
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 2de9924..7a2c323 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -704,6 +704,22 @@ config SERIAL_PNX8XXX_CONSOLE
 	  If you have a MIPS-based Philips SoC such as PNX8550 or PNX8330
 	  and you want to use serial console, say Y. Otherwise, say N.
 
+config SERIAL_HS_LPC32XX
+	tristate "LPC32xx high serial port support"
+	depends on ARCH_LPC32XX
+	select SERIAL_CORE
+	help
+		Support for the LPC32XX high speed serial ports
+
+config SERIAL_HS_LPC32XX_CONSOLE
+	bool "Enable LPC32XX high speed UART serial console"
+	depends on SERIAL_HS_LPC32XX
+	select SERIAL_CORE_CONSOLE
+	help
+		If you would like to be able to use one of the high speed serial
+		ports on the LPC32XX as the console, you can do so by answering
+		Y to this option.
+
 config SERIAL_CORE
 	tristate
 
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index fef32e1..2f84642 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -34,6 +34,7 @@ obj-$(CONFIG_SERIAL_MUX) += mux.o
 obj-$(CONFIG_SERIAL_68328) += 68328serial.o
 obj-$(CONFIG_SERIAL_MCF) += mcf.o
 obj-$(CONFIG_SERIAL_PMACZILOG) += pmac_zilog.o
+obj-$(CONFIG_SERIAL_HS_LPC32XX) += lpc32xx_hs.o
 obj-$(CONFIG_SERIAL_DZ) += dz.o
 obj-$(CONFIG_SERIAL_ZS) += zs.o
 obj-$(CONFIG_SERIAL_SH_SCI) += sh-sci.o
diff --git a/drivers/tty/serial/lpc32xx_hs.c b/drivers/tty/serial/lpc32xx_hs.c
new file mode 100644
index 0000000..e1bcf2d
--- /dev/null
+++ b/drivers/tty/serial/lpc32xx_hs.c
@@ -0,0 +1,768 @@
+/*
+ * drivers/serial/lpc32xx_hs.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2010 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/sysrq.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_core.h>
+#include <linux/serial.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/nmi.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+
+#include <mach/board.h>
+
+/*
+ * High speed UART register offsets
+ */
+#define LPC32XX_HSUART_FIFO(x)			(x + 0x00)
+#define LPC32XX_HSUART_LEVEL(x)			(x + 0x04)
+#define LPC32XX_HSUART_IIR(x)			(x + 0x08)
+#define LPC32XX_HSUART_CTRL(x)			(x + 0x0C)
+#define LPC32XX_HSUART_RATE(x)			(x + 0x10)
+
+#define LPC32XX_HSU_BREAK_DATA			(1 << 10)
+#define LPC32XX_HSU_ERROR_DATA			(1 << 9)
+#define LPC32XX_HSU_RX_EMPTY			(1 << 8)
+
+#define LPC32XX_HSU_TX_LEV(n)			(((n) >> 8) & 0xFF)
+#define LPC32XX_HSU_RX_LEV(n)			((n) & 0xFF)
+
+#define LPC32XX_HSU_TX_INT_SET			(1 << 6)
+#define LPC32XX_HSU_RX_OE_INT			(1 << 5)
+#define LPC32XX_HSU_BRK_INT			(1 << 4)
+#define LPC32XX_HSU_FE_INT			(1 << 3)
+#define LPC32XX_HSU_RX_TIMEOUT_INT		(1 << 2)
+#define LPC32XX_HSU_RX_TRIG_INT			(1 << 1)
+#define LPC32XX_HSU_TX_INT			(1 << 0)
+
+#define LPC32XX_HSU_HRTS_INV			(1 << 21)
+#define LPC32XX_HSU_HRTS_TRIG_8B		(0x0 << 19)
+#define LPC32XX_HSU_HRTS_TRIG_16B		(0x1 << 19)
+#define LPC32XX_HSU_HRTS_TRIG_32B		(0x2 << 19)
+#define LPC32XX_HSU_HRTS_TRIG_48B		(0x3 << 19)
+#define LPC32XX_HSU_HRTS_EN			(1 << 18)
+#define LPC32XX_HSU_TMO_DISABLED		(0x0 << 16)
+#define LPC32XX_HSU_TMO_INACT_4B		(0x1 << 16)
+#define LPC32XX_HSU_TMO_INACT_8B		(0x2 << 16)
+#define LPC32XX_HSU_TMO_INACT_16B		(0x3 << 16)
+#define LPC32XX_HSU_HCTS_INV			(1 << 15)
+#define LPC32XX_HSU_HCTS_EN			(1 << 14)
+#define LPC32XX_HSU_OFFSET(n)			((n) << 9)
+#define LPC32XX_HSU_BREAK			(1 << 8)
+#define LPC32XX_HSU_ERR_INT_EN			(1 << 7)
+#define LPC32XX_HSU_RX_INT_EN			(1 << 6)
+#define LPC32XX_HSU_TX_INT_EN			(1 << 5)
+#define LPC32XX_HSU_RX_TL1B			(0x0 << 2)
+#define LPC32XX_HSU_RX_TL4B			(0x1 << 2)
+#define LPC32XX_HSU_RX_TL8B			(0x2 << 2)
+#define LPC32XX_HSU_RX_TL16B			(0x3 << 2)
+#define LPC32XX_HSU_RX_TL32B			(0x4 << 2)
+#define LPC32XX_HSU_RX_TL48B			(0x5 << 2)
+#define LPC32XX_HSU_TX_TLEMPTY			(0x0 << 0)
+#define LPC32XX_HSU_TX_TL0B			(0x0 << 0)
+#define LPC32XX_HSU_TX_TL4B			(0x1 << 0)
+#define LPC32XX_HSU_TX_TL8B			(0x2 << 0)
+#define LPC32XX_HSU_TX_TL16B			(0x3 << 0)
+
+#define MODNAME "lpc32xx_hsuart"
+
+#define FIFO_READ_LIMIT 128
+#define MAX_PORTS 3
+#define LPC32XX_TTY_NAME "ttyTX"
+#define LPC32XX_TTY_MINOR_START	196
+#define LPC32XX_TTY_MAJOR 204
+static struct lpc32xx_hsuart_port lpc32xx_hs_ports[MAX_PORTS];
+
+#ifdef CONFIG_SERIAL_HS_LPC32XX_CONSOLE
+static void wait_for_xmit_empty(struct uart_port *port)
+{
+	unsigned int timeout = 10000;
+
+	do {
+		if (LPC32XX_HSU_TX_LEV(__raw_readl(LPC32XX_HSUART_LEVEL(
+			port->membase))) == 0)
+			break;
+		if (--timeout == 0)
+			break;
+		udelay(1);
+	} while (1);
+}
+
+static void wait_for_xmit_ready(struct uart_port *port)
+{
+	unsigned int timeout = 10000;
+
+	while (1) {
+		if (LPC32XX_HSU_TX_LEV(__raw_readl(LPC32XX_HSUART_LEVEL(
+			port->membase))) < 32)
+			break;
+		if (--timeout == 0)
+			break;
+		udelay(1);
+	}
+}
+
+static void lpc32xx_hsuart_console_putchar(struct uart_port *port, int ch)
+{
+	wait_for_xmit_ready(port);
+	__raw_writel((u32) ch, LPC32XX_HSUART_FIFO(port->membase));
+}
+
+static void lpc32xx_hsuart_console_write(struct console *co, const char *s,
+	unsigned int count) {
+	struct lpc32xx_hsuart_port *up = &lpc32xx_hs_ports[co->index];
+	unsigned long flags;
+	int locked = 1;
+
+	touch_nmi_watchdog();
+	local_irq_save(flags);
+	if (up->port.sysrq)
+		locked = 0;
+	else if (oops_in_progress)
+		locked = spin_trylock(&up->port.lock);
+	else
+		spin_lock(&up->port.lock);
+
+	uart_console_write(&up->port, s, count,
+		lpc32xx_hsuart_console_putchar);
+	wait_for_xmit_empty(&up->port);
+
+	if (locked)
+		spin_unlock(&up->port.lock);
+	local_irq_restore(flags);
+}
+
+static int __init lpc32xx_hsuart_console_setup(struct console *co,
+	char *options) {
+	struct uart_port *port;
+	int baud = 115200;
+	int bits = 8;
+	int parity = 'n';
+	int flow = 'n';
+
+	if (co->index >= MAX_PORTS)
+		co->index = 0;
+
+	port = &lpc32xx_hs_ports[co->index].port;
+	if (!port->membase)
+		return -ENODEV;
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(port, co, baud, parity, bits, flow);
+}
+
+static struct uart_driver lpc32xx_hs_reg;
+static struct console lpc32xx_hsuart_console = {
+	.name		= LPC32XX_TTY_NAME,
+	.write		= lpc32xx_hsuart_console_write,
+	.device		= uart_console_device,
+	.setup		= lpc32xx_hsuart_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &lpc32xx_hs_reg,
+};
+
+static int __init lpc32xx_hsuart_console_init(void)
+{
+	register_console(&lpc32xx_hsuart_console);
+	return 0;
+}
+console_initcall(lpc32xx_hsuart_console_init);
+
+#define LPC32XX_HSUART_CONSOLE	(&lpc32xx_hsuart_console)
+#else
+#define LPC32XX_HSUART_CONSOLE NULL
+#endif
+
+static struct uart_driver lpc32xx_hs_reg = {
+	.owner		= THIS_MODULE,
+	.driver_name	= MODNAME,
+	.dev_name	= LPC32XX_TTY_NAME,
+	.major		= LPC32XX_TTY_MAJOR,
+	.minor		= LPC32XX_TTY_MINOR_START,
+	.nr		= MAX_PORTS,
+	.cons		= LPC32XX_HSUART_CONSOLE,
+};
+static int uarts_registered;
+
+static unsigned int __serial_get_clock_div(unsigned long uartclk,
+	unsigned long rate) {
+	u32 div, goodrate, hsu_rate, l_hsu_rate, comprate;
+	u32 rate_diff;
+
+	/* Find the closest divider to get the desired clock rate */
+	div = uartclk / rate;
+	goodrate = hsu_rate = (div / 14) - 1;
+	if (hsu_rate != 0)
+		hsu_rate--;
+
+	/* Tweak divider */
+	l_hsu_rate = hsu_rate + 3;
+	rate_diff = 0xFFFFFFFF;
+
+	while (hsu_rate < l_hsu_rate) {
+		comprate = uartclk / ((hsu_rate + 1) * 14);
+		if (abs(comprate - rate) < rate_diff) {
+			goodrate = hsu_rate;
+			rate_diff = abs(comprate - rate);
+		}
+
+		hsu_rate++;
+	}
+	if (hsu_rate > 0xFF)
+		hsu_rate = 0xFF;
+
+	return goodrate;
+}
+
+static void __serial_uart_flush(struct uart_port *port)
+{
+	u32 tmp;
+	int cnt = 0;
+
+	while ((__raw_readl(LPC32XX_HSUART_LEVEL(port->membase)) > 0) &&
+		(cnt++ < FIFO_READ_LIMIT))
+		tmp = __raw_readl(LPC32XX_HSUART_FIFO(port->membase));
+}
+
+static void __serial_lpc32xx_rx(struct uart_port *port)
+{
+	unsigned int tmp, flag;
+
+	/* Read data from FIFO and push into terminal */
+	tmp = __raw_readl(LPC32XX_HSUART_FIFO(port->membase));
+	while (!(tmp & LPC32XX_HSU_RX_EMPTY)) {
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		if (tmp & LPC32XX_HSU_ERROR_DATA) {
+			/* Framing error */
+			__raw_writel(LPC32XX_HSU_FE_INT,
+				LPC32XX_HSUART_IIR(port->membase));
+			port->icount.frame++;
+			flag = TTY_FRAME;
+			tty_insert_flip_char(port->state->port.tty, 0,
+				TTY_FRAME);
+			tty_schedule_flip(port->state->port.tty);
+		}
+
+		tty_insert_flip_char(port->state->port.tty, (tmp & 0xFF),
+			flag);
+
+		tmp = __raw_readl(LPC32XX_HSUART_FIFO(port->membase));
+	}
+}
+
+static void __serial_lpc32xx_tx(struct uart_port *port)
+{
+	struct circ_buf *xmit = &port->state->xmit;
+	unsigned int tmp;
+
+	if (port->x_char) {
+		__raw_writel((u32) port->x_char,
+			LPC32XX_HSUART_FIFO(port->membase));
+		port->icount.tx++;
+		port->x_char = 0;
+		return;
+	}
+
+	if (uart_circ_empty(xmit) || uart_tx_stopped(port))
+		goto exit_tx;
+
+	/* Transfer data */
+	while (LPC32XX_HSU_TX_LEV(__raw_readl(
+		LPC32XX_HSUART_LEVEL(port->membase))) < 64) {
+		__raw_writel((u32) xmit->buf[xmit->tail],
+			LPC32XX_HSUART_FIFO(port->membase));
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->icount.tx++;
+		if (uart_circ_empty(xmit))
+			break;
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+exit_tx:
+	if (uart_circ_empty(xmit)) {
+		tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+		tmp &= ~LPC32XX_HSU_TX_INT_EN;
+		__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+	}
+}
+
+static irqreturn_t serial_lpc32xx_interrupt(int irq, void *dev_id)
+{
+	struct uart_port *port = dev_id;
+	u32 status;
+
+	spin_lock(&port->lock);
+
+	/* Read UART status and clear latched interrupts */
+	status = __raw_readl(LPC32XX_HSUART_IIR(port->membase));
+
+	if (status & LPC32XX_HSU_BRK_INT) {
+		/* Break received */
+		__raw_writel(LPC32XX_HSU_BRK_INT,
+			LPC32XX_HSUART_IIR(port->membase));
+		port->icount.brk++;
+		uart_handle_break(port);
+	}
+
+	/* Framing error */
+	if (status & LPC32XX_HSU_FE_INT)
+		__raw_writel(LPC32XX_HSU_FE_INT,
+			LPC32XX_HSUART_IIR(port->membase));
+
+	if (status & LPC32XX_HSU_RX_OE_INT) {
+		/* Receive FIFO overrun */
+		__raw_writel(LPC32XX_HSU_RX_OE_INT,
+			LPC32XX_HSUART_IIR(port->membase));
+		port->icount.overrun++;
+		tty_insert_flip_char(port->state->port.tty, 0, TTY_OVERRUN);
+		tty_schedule_flip(port->state->port.tty);
+	}
+
+	/* Data received? */
+	if (status & (LPC32XX_HSU_RX_TIMEOUT_INT | LPC32XX_HSU_RX_TRIG_INT)) {
+		__serial_lpc32xx_rx(port);
+		spin_unlock(&port->lock);
+		tty_flip_buffer_push(port->state->port.tty);
+		spin_lock(&port->lock);
+	}
+
+	/* Transmit data request? */
+	if ((status & LPC32XX_HSU_TX_INT) && (!uart_tx_stopped(port))) {
+		__raw_writel(LPC32XX_HSU_TX_INT,
+			LPC32XX_HSUART_IIR(port->membase));
+		__serial_lpc32xx_tx(port);
+	}
+
+	spin_unlock(&port->lock);
+
+	return IRQ_HANDLED;
+}
+
+/* port->lock is not held.  */
+static unsigned int serial_lpc32xx_tx_empty(struct uart_port *port)
+{
+	unsigned int ret = 0;
+
+	if (LPC32XX_HSU_TX_LEV(__raw_readl(
+		LPC32XX_HSUART_LEVEL(port->membase))) == 0)
+		ret = TIOCSER_TEMT;
+
+	return ret;
+}
+
+/* port->lock held by caller.  */
+static void serial_lpc32xx_set_mctrl(struct uart_port *port,
+	unsigned int mctrl) {
+	/* No signals are supported on HS UARTs */
+}
+
+/* port->lock is held by caller and interrupts are disabled.  */
+static unsigned int serial_lpc32xx_get_mctrl(struct uart_port *port)
+{
+	/* No signals are supported on HS UARTs */
+	return TIOCM_CAR | TIOCM_DSR | TIOCM_CTS;
+}
+
+/* port->lock held by caller.  */
+static void serial_lpc32xx_stop_tx(struct uart_port *port)
+{
+	u32 tmp;
+
+	tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+	tmp &= ~LPC32XX_HSU_TX_INT_EN;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+}
+
+/* port->lock held by caller.  */
+static void serial_lpc32xx_start_tx(struct uart_port *port)
+{
+	u32 tmp;
+
+	__serial_lpc32xx_tx(port);
+	tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+	tmp |= LPC32XX_HSU_TX_INT_EN;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+}
+
+/* port->lock held by caller.  */
+static void serial_lpc32xx_stop_rx(struct uart_port *port)
+{
+	u32 tmp;
+
+	tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+	tmp &= ~(LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN);
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+
+	__raw_writel((LPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT |
+		LPC32XX_HSU_FE_INT), LPC32XX_HSUART_IIR(port->membase));
+}
+
+/* port->lock held by caller.  */
+static void serial_lpc32xx_enable_ms(struct uart_port *port)
+{
+	/* Modem status is not supported */
+}
+
+/* port->lock is not held.  */
+static void serial_lpc32xx_break_ctl(struct uart_port *port,
+	int break_state) {
+	unsigned long flags;
+	u32 tmp;
+
+	spin_lock_irqsave(&port->lock, flags);
+	tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+	if (break_state != 0)
+		tmp |= LPC32XX_HSU_BREAK;
+	else
+		tmp &= ~LPC32XX_HSU_BREAK;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+/* port->lock is not held.  */
+static int serial_lpc32xx_startup(struct uart_port *port)
+{
+	int retval;
+	unsigned long flags;
+	u32 tmp;
+	struct lpc32xx_hsuart_port *p = (struct lpc32xx_hsuart_port *)port;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	__serial_uart_flush(port);
+
+	__raw_writel((LPC32XX_HSU_TX_INT | LPC32XX_HSU_FE_INT |
+		LPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT),
+		LPC32XX_HSUART_IIR(port->membase));
+
+	__raw_writel(0xFF, LPC32XX_HSUART_RATE(port->membase));
+
+	/*
+	 * Set receiver timeout, HSU offset of 20, no break, no interrupts,
+	 * and default FIFO trigger levels
+	 */
+	tmp = LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |
+		LPC32XX_HSU_OFFSET(p->fbit_sam) | LPC32XX_HSU_TMO_INACT_4B;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	retval = request_irq(port->irq, serial_lpc32xx_interrupt,
+			     0, MODNAME, port);
+	if (!retval)
+		__raw_writel((tmp | LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN),
+			LPC32XX_HSUART_CTRL(port->membase));
+
+	return retval;
+}
+
+/* port->lock is not held.  */
+static void serial_lpc32xx_shutdown(struct uart_port *port)
+{
+	u32 tmp;
+	unsigned long flags;
+	struct lpc32xx_hsuart_port *p = (struct lpc32xx_hsuart_port *)port;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	tmp = LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |
+		LPC32XX_HSU_OFFSET(p->fbit_sam) | LPC32XX_HSU_TMO_INACT_4B;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+
+	spin_unlock_irqrestore(&port->lock, flags);
+
+	free_irq(port->irq, port);
+}
+
+/* port->lock is not held.  */
+static void serial_lpc32xx_set_termios(struct uart_port *port,
+	struct ktermios *termios, struct ktermios *old)
+{
+	unsigned long flags;
+	unsigned int baud, quot;
+	u32 tmp;
+
+	/* Always 8-bit, no parity, 1 stop bit */
+	termios->c_cflag &= ~(CSIZE | CSTOPB | PARENB | PARODD);
+	termios->c_cflag |= CS8;
+
+	termios->c_cflag &= ~(HUPCL | CMSPAR | CLOCAL | CRTSCTS);
+
+	baud = uart_get_baud_rate(port, termios, old, 0,
+		(port->uartclk / 14));
+	quot = __serial_get_clock_div(port->uartclk, baud);
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	/* Ignore characters? */
+	tmp = __raw_readl(LPC32XX_HSUART_CTRL(port->membase));
+	if ((termios->c_cflag & CREAD) == 0)
+		tmp &= ~(LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN);
+	else
+		tmp |= LPC32XX_HSU_RX_INT_EN | LPC32XX_HSU_ERR_INT_EN;
+	__raw_writel(tmp, LPC32XX_HSUART_CTRL(port->membase));
+
+	__raw_writel(quot, LPC32XX_HSUART_RATE(port->membase));
+
+	uart_update_timeout(port, termios->c_cflag, baud);
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static const char *serial_lpc32xx_type(struct uart_port *port)
+{
+	return MODNAME;
+}
+
+static void serial_lpc32xx_release_port(struct uart_port *port)
+{
+	if ((port->iotype == UPIO_MEM32) && (port->mapbase)) {
+		if (port->flags & UPF_IOREMAP) {
+			iounmap(port->membase);
+			port->membase = NULL;
+		}
+
+		release_mem_region(port->mapbase, SZ_4K);
+	}
+}
+
+static int serial_lpc32xx_request_port(struct uart_port *port)
+{
+	int ret = -ENODEV;
+
+	if ((port->iotype == UPIO_MEM32) && (port->mapbase)) {
+		ret = 0;
+
+		if (!request_mem_region(port->mapbase, SZ_4K, MODNAME))
+			ret = -EBUSY;
+		else if (port->flags & UPF_IOREMAP) {
+			port->membase = ioremap(port->mapbase, SZ_4K);
+			if (!port->membase) {
+				release_mem_region(port->mapbase, SZ_4K);
+				ret = -ENOMEM;
+			}
+		}
+	}
+
+	return ret;
+}
+
+static void serial_lpc32xx_config_port(struct uart_port *port, int uflags)
+{
+	int ret;
+	struct lpc32xx_hsuart_port *p = (struct lpc32xx_hsuart_port *)port;
+
+	ret = serial_lpc32xx_request_port(port);
+	if (ret < 0)
+		return;
+	port->type = PORT_UART00;
+	port->fifosize = 64;
+
+	__serial_uart_flush(port);
+
+	__raw_writel((LPC32XX_HSU_TX_INT | LPC32XX_HSU_FE_INT |
+		LPC32XX_HSU_BRK_INT | LPC32XX_HSU_RX_OE_INT),
+		LPC32XX_HSUART_IIR(port->membase));
+
+	__raw_writel(0xFF, LPC32XX_HSUART_RATE(port->membase));
+
+	/* Set receiver timeout, HSU offset of 20, no break, no interrupts,
+	   and default FIFO trigger levels */
+	__raw_writel(LPC32XX_HSU_TX_TL8B | LPC32XX_HSU_RX_TL32B |
+		LPC32XX_HSU_OFFSET(p->fbit_sam) | LPC32XX_HSU_TMO_INACT_4B,
+		LPC32XX_HSUART_CTRL(port->membase));
+}
+
+static int serial_lpc32xx_verify_port(struct uart_port *port,
+	struct serial_struct *ser)
+{
+	int ret = 0;
+
+	if (ser->type != PORT_UART00)
+		ret = -EINVAL;
+
+	return ret;
+}
+
+static struct uart_ops serial_lpc32xx_pops = {
+	.tx_empty	= serial_lpc32xx_tx_empty,
+	.set_mctrl	= serial_lpc32xx_set_mctrl,
+	.get_mctrl	= serial_lpc32xx_get_mctrl,
+	.stop_tx	= serial_lpc32xx_stop_tx,
+	.start_tx	= serial_lpc32xx_start_tx,
+	.stop_rx	= serial_lpc32xx_stop_rx,
+	.enable_ms	= serial_lpc32xx_enable_ms,
+	.break_ctl	= serial_lpc32xx_break_ctl,
+	.startup	= serial_lpc32xx_startup,
+	.shutdown	= serial_lpc32xx_shutdown,
+	.set_termios	= serial_lpc32xx_set_termios,
+	.type		= serial_lpc32xx_type,
+	.release_port	= serial_lpc32xx_release_port,
+	.request_port	= serial_lpc32xx_request_port,
+	.config_port	= serial_lpc32xx_config_port,
+	.verify_port	= serial_lpc32xx_verify_port,
+};
+
+/*
+ * Register a set of serial devices attached to a platform device
+ */
+static int __devinit serial_hs_lpc32xx_probe(struct platform_device *pdev)
+{
+	struct lpc32xx_hsuart_port *p = pdev->dev.platform_data;
+	struct lpc32xx_hsuart_port *pdr;
+	int i, ret = 0;
+
+	uarts_registered = 0;
+	for (i = 0; p && (p->port.flags != 0); i++) {
+		pdr = &lpc32xx_hs_ports[i];
+		memset(pdr, 0, sizeof(struct lpc32xx_hsuart_port));
+
+		pdr->port.iotype	= p->port.iotype;
+		pdr->port.membase	= p->port.membase;
+		pdr->port.mapbase	= p->port.mapbase;
+		pdr->port.irq		= p->port.irq;
+		pdr->port.uartclk	= p->port.uartclk;
+		pdr->port.regshift	= p->port.regshift;
+		pdr->port.flags		= p->port.flags | UPF_FIXED_PORT;
+		pdr->port.dev		= &pdev->dev;
+		pdr->port.ops		= &serial_lpc32xx_pops;
+		pdr->port.line		= p->port.line;
+		pdr->fbit_sam		= p->fbit_sam;
+
+		/* If First sample point is beyond limit,
+		 * set it to default value - 20
+		 */
+		if((pdr->fbit_sam < 0) || (pdr->fbit_sam > 31)) {
+			pdr->fbit_sam = 20;
+		}
+
+		spin_lock_init(&pdr->port.lock);
+
+		uart_add_one_port(&lpc32xx_hs_reg, &pdr->port);
+		p++;
+		uarts_registered++;
+	}
+
+	return ret;
+}
+
+/*
+ * Remove serial ports registered against a platform device.
+ */
+static int __devexit serial_hs_lpc32xx_remove(struct platform_device *pdev)
+{
+	struct lpc32xx_hsuart_port *p;
+	int i;
+
+	for (i = 0; i < uarts_registered; i++) {
+		p = &lpc32xx_hs_ports[i];
+
+		if (p->port.dev == &pdev->dev)
+			uart_remove_one_port(&lpc32xx_hs_reg, &p->port);
+	}
+
+	platform_set_drvdata(pdev, NULL);
+
+	return 0;
+}
+
+
+#if defined (CONFIG_PM)
+static int serial_hs_lpc32xx_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int i;
+
+	for (i = 0; i < uarts_registered; i++) {
+		struct lpc32xx_hsuart_port *p = &lpc32xx_hs_ports[i];
+
+		if (p->port.type != PORT_UNKNOWN && p->port.dev == &dev->dev)
+			uart_suspend_port(&lpc32xx_hs_reg, &p->port);
+	}
+
+	return 0;
+}
+
+static int serial_hs_lpc32xx_resume(struct platform_device *dev)
+{
+	int i;
+
+	for (i = 0; i < uarts_registered; i++) {
+		struct lpc32xx_hsuart_port *p = &lpc32xx_hs_ports[i];
+
+		if (p->port.type != PORT_UNKNOWN && p->port.dev == &dev->dev)
+			uart_resume_port(&lpc32xx_hs_reg, &p->port);
+	}
+
+	return 0;
+}
+#else
+#define serial_hs_lpc32xx_suspend	NULL
+#define serial_hs_lpc32xx_resume	NULL
+#endif
+
+static struct platform_driver serial_hs_lpc32xx_driver = {
+	.probe		= serial_hs_lpc32xx_probe,
+	.remove		= __devexit_p(serial_hs_lpc32xx_remove),
+ 	.suspend	= serial_hs_lpc32xx_suspend,
+ 	.resume		= serial_hs_lpc32xx_resume,
+	.driver		= {
+		.name	= MODNAME,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init lpc32xx_hsuart_init(void)
+{
+	int ret;
+
+	ret = uart_register_driver(&lpc32xx_hs_reg);
+	if (ret == 0) {
+		ret = platform_driver_register(&serial_hs_lpc32xx_driver);
+		if (ret)
+			uart_unregister_driver(&lpc32xx_hs_reg);
+	}
+
+	return ret;
+}
+
+static void __exit lpc32xx_hsuart_exit(void)
+{
+	platform_driver_unregister(&serial_hs_lpc32xx_driver);
+	uart_unregister_driver(&lpc32xx_hs_reg);
+}
+
+module_init(lpc32xx_hsuart_init);
+module_exit(lpc32xx_hsuart_exit);
+
+MODULE_AUTHOR("Kevin Wells (kevin.wells@nxp.com)");
+MODULE_DESCRIPTION("NXP LPC32XX High speed UART driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/usb/gadget/Kconfig b/drivers/usb/gadget/Kconfig
index 7ecb68a..d73cdfe 100644
--- a/drivers/usb/gadget/Kconfig
+++ b/drivers/usb/gadget/Kconfig
@@ -147,6 +147,16 @@ config USB_AT91
 	   dynamically linked module called "at91_udc" and force all
 	   gadget drivers to also be dynamically linked.
 
+config USB_GADGET_LPC32XX
+       boolean "LPC32XX USB Device Port"
+       depends on ARCH_LPC32XX
+
+config USB_LPC32XX
+       tristate
+       depends on USB_GADGET_LPC32XX
+       default USB_GADGET
+       select USB_GADGET_SELECTED
+
 config USB_ATMEL_USBA
 	tristate "Atmel USBA"
 	select USB_GADGET_DUALSPEED
diff --git a/drivers/usb/gadget/Makefile b/drivers/usb/gadget/Makefile
index b7f6eef..1565253 100644
--- a/drivers/usb/gadget/Makefile
+++ b/drivers/usb/gadget/Makefile
@@ -26,6 +26,7 @@ obj-$(CONFIG_USB_CI13XXX_PCI)	+= ci13xxx_pci.o
 obj-$(CONFIG_USB_S3C_HSOTG)	+= s3c-hsotg.o
 obj-$(CONFIG_USB_S3C_HSUDC)	+= s3c-hsudc.o
 obj-$(CONFIG_USB_LANGWELL)	+= langwell_udc.o
+obj-$(CONFIG_USB_LPC32XX)	+= lpc32xx_udc.o
 obj-$(CONFIG_USB_EG20T)		+= pch_udc.o
 obj-$(CONFIG_USB_MV_UDC)	+= mv_udc.o
 mv_udc-y			:= mv_udc_core.o
diff --git a/drivers/usb/gadget/gadget_chips.h b/drivers/usb/gadget/gadget_chips.h
index a8855d0..fc9b3b1 100644
--- a/drivers/usb/gadget/gadget_chips.h
+++ b/drivers/usb/gadget/gadget_chips.h
@@ -42,6 +42,7 @@
 #define gadget_is_net2272(g)		(!strcmp("net2272", (g)->name))
 #define gadget_is_net2280(g)		(!strcmp("net2280", (g)->name))
 #define gadget_is_omap(g)		(!strcmp("omap_udc", (g)->name))
+#define gadget_is_lpc32xx(g)            (!strcmp("lpc32xx_udc", (g)->name))
 #define gadget_is_pch(g)		(!strcmp("pch_udc", (g)->name))
 #define gadget_is_pxa(g)		(!strcmp("pxa25x_udc", (g)->name))
 #define gadget_is_pxa27x(g)		(!strcmp("pxa27x_udc", (g)->name))
diff --git a/drivers/usb/gadget/lpc32xx_udc.c b/drivers/usb/gadget/lpc32xx_udc.c
new file mode 100644
index 0000000..cd0605c
--- /dev/null
+++ b/drivers/usb/gadget/lpc32xx_udc.c
@@ -0,0 +1,3195 @@
+/*
+ * drivers/usb/gadget/lpc32xx_udc.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ * Copyright (C) 2006 Mike James , Philips Semiconductors
+ *
+ * Note: This driver is based on original work done by Mike James for
+ *       the LPC3180.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * Update Feb 2011
+ * Known driver issues
+ *
+ * Spinlock handling
+ * All spinlock grab/release issues seems to be fixed. It is possible there
+ * may be paths that haven't yet been tested.
+ *
+ * Printer class driver
+ * There seems to be an issue with this specific driver related to spinlocks.
+ * The issue does seem to be class driver related, not chip driver related.
+ * Some functions are called from the printer class driver with class specific
+ * spinlocks enabled. This might be fixed in a later kernel release.
+ *
+ * Isochronous endpoint transfers (audio class driver)
+ * Isochronous transfers do not work reliably. Tested with the audio class
+ * driver and ALSA, USB audio streaming does work, but issues appear with
+ * ISO endpoint transfer and control endpoints related to ALSA set/get
+ * functions. It is possible this may be related to the gadget audio support.
+ *
+ * Host suspend/resume do not fully shut down the USB
+ * The I2C transceiver and device clocks should be shut down when the
+ * hosts is suspended. This will be fixed later. The current drawback
+ * is power usage during suspend is higher than if not fully powered
+ * down
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/proc_fs.h>
+#include <linux/clk.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+#include <linux/i2c.h>
+#include <linux/kthread.h>
+#include <linux/freezer.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmapool.h>
+#include <linux/workqueue.h>
+
+#include <asm/byteorder.h>
+#include <mach/hardware.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include <mach/platform.h>
+#include <mach/irqs.h>
+#include <mach/usbd.h>
+#include <mach/board.h>
+#include "lpc32xx_udc.h"
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+#include <linux/seq_file.h>
+#endif
+
+#define UDCA_BUFF_SIZE (128)
+
+#define USB_CTRL	IO_ADDRESS(LPC32XX_CLK_PM_BASE + 0x64)
+#define USB_CLOCK_MASK (AHB_M_CLOCK_ON| OTG_CLOCK_ON | DEV_CLOCK_ON | I2C_CLOCK_ON)
+
+/* USB_CTRL bit defines */
+#define USB_SLAVE_HCLK_EN	(1 << 24)
+#define USB_HOST_NEED_CLK_EN	(1 << 21)
+#define USB_DEV_NEED_CLK_EN	(1 << 22)
+
+#define USB_OTG_CLK_CTRL	IO_ADDRESS(LPC32XX_USB_BASE + 0xFF4)
+#define USB_OTG_CLK_STAT	IO_ADDRESS(LPC32XX_USB_BASE + 0xFF8)
+
+/* USB_OTG_CLK_CTRL bit defines */
+#define AHB_M_CLOCK_ON		(1 << 4)
+#define OTG_CLOCK_ON		(1 << 3)
+#define I2C_CLOCK_ON		(1 << 2)
+#define DEV_CLOCK_ON		(1 << 1)
+#define HOST_CLOCK_ON		(1 << 0)
+
+#define USB_OTG_STAT_CONTROL	IO_ADDRESS(LPC32XX_USB_BASE + 0x110)
+
+/* USB_OTG_STAT_CONTROL bit defines */
+#define TRANSPARENT_I2C_EN	(1 << 7)
+#define HOST_EN			(1 << 0)
+
+/* ISP1301 USB transceiver I2C registers */
+#define	ISP1301_MODE_CONTROL_1		0x04	/* u8 read, set, +1 clear */
+
+#define	MC1_SPEED_REG		(1 << 0)
+#define	MC1_SUSPEND_REG		(1 << 1)
+#define	MC1_DAT_SE0		(1 << 2)
+#define	MC1_TRANSPARENT		(1 << 3)
+#define	MC1_BDIS_ACON_EN	(1 << 4)
+#define	MC1_OE_INT_EN		(1 << 5)
+#define	MC1_UART_EN		(1 << 6)
+#define	MC1_MASK		0x7f
+
+#define	ISP1301_MODE_CONTROL_2		0x12	/* u8 read, set, +1 clear */
+
+#define	MC2_GLOBAL_PWR_DN	(1 << 0)
+#define	MC2_SPD_SUSP_CTRL	(1 << 1)
+#define	MC2_BI_DI		(1 << 2)
+#define	MC2_TRANSP_BDIR0	(1 << 3)
+#define	MC2_TRANSP_BDIR1	(1 << 4)
+#define	MC2_AUDIO_EN		(1 << 5)
+#define	MC2_PSW_EN		(1 << 6)
+#define	MC2_EN2V7		(1 << 7)
+
+#define	ISP1301_OTG_CONTROL_1		0x06	/* u8 read, set, +1 clear */
+#define	OTG1_DP_PULLUP		(1 << 0)
+#define	OTG1_DM_PULLUP		(1 << 1)
+#define	OTG1_DP_PULLDOWN	(1 << 2)
+#define	OTG1_DM_PULLDOWN	(1 << 3)
+#define	OTG1_ID_PULLDOWN	(1 << 4)
+#define	OTG1_VBUS_DRV		(1 << 5)
+#define	OTG1_VBUS_DISCHRG	(1 << 6)
+#define	OTG1_VBUS_CHRG		(1 << 7)
+#define	ISP1301_OTG_STATUS		0x10	/* u8 readonly */
+#define	OTG_B_SESS_END		(1 << 6)
+#define	OTG_B_SESS_VLD		(1 << 7)
+
+#define INT_CR_INT		(1 << 7)
+#define INT_BDIS_ACON		(1 << 6)
+#define INT_ID_FLOAT		(1 << 5)
+#define INT_DM_HI		(1 << 4)
+#define INT_ID_GND		(1 << 3)
+#define INT_DP_HI		(1 << 2)
+#define INT_SESS_VLD		(1 << 1)
+#define INT_VBUS_VLD		(1 << 0)
+
+#define ISP1301_I2C_ADDR 0x2C
+
+#define ISP1301_I2C_MODE_CONTROL_1 0x4
+#define ISP1301_I2C_MODE_CONTROL_2 0x12
+#define ISP1301_I2C_OTG_CONTROL_1 0x6
+#define ISP1301_I2C_OTG_CONTROL_2 0x10
+#define ISP1301_I2C_INTERRUPT_SOURCE 0x8
+#define ISP1301_I2C_INTERRUPT_LATCH 0xA
+#define ISP1301_I2C_INTERRUPT_FALLING 0xC
+#define ISP1301_I2C_INTERRUPT_RISING 0xE
+#define ISP1301_I2C_REG_CLEAR_ADDR 1
+
+#define	DRIVER_VERSION	"$Revision: 1.02 $"
+static const char driver_name [] = "lpc32xx_udc";
+
+static void udc_set_address(struct lpc32xx_udc *udc, u32 addr);
+static int udc_ep_in_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep);
+static int udc_ep_out_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep);
+static int udc_ep0_in_req(struct lpc32xx_udc *udc);
+static int udc_ep0_out_req(struct lpc32xx_udc *udc);
+
+/*
+ *
+ * proc interface support
+ *
+ */
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+static char *epnames[] = {"INT", "ISO", "BULK", "CTRL"};
+static const char debug_filename[] = "driver/udc";
+
+static void proc_ep_show(struct seq_file *s, struct lpc32xx_ep *ep)
+{
+	struct lpc32xx_request *req;
+
+	seq_printf(s, "\n");
+	seq_printf(s, "%12s, maxpacket %4d %3s",
+			ep->ep.name, ep->ep.maxpacket,
+			ep->is_in ? "in" : "out");
+	seq_printf(s, " type %4s", epnames[ep->eptype]);
+	seq_printf(s, " ints: %12d", ep->totalints);
+
+	if (list_empty (&ep->queue))
+		seq_printf(s, "\t(queue empty)\n");
+	else {
+		list_for_each_entry (req, &ep->queue, queue) {
+			u32 length = req->req.actual;
+
+			seq_printf(s, "\treq %p len %d/%d buf %p\n",
+					&req->req, length,
+					req->req.length, req->req.buf);
+		}
+	}
+}
+
+static int proc_udc_show(struct seq_file *s, void *unused)
+{
+	struct lpc32xx_udc *udc = s->private;
+	struct lpc32xx_ep *ep;
+	unsigned long flags;
+
+	seq_printf(s, "%s: version %s\n", driver_name, DRIVER_VERSION);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	seq_printf(s, "vbus %s, pullup %s, %s powered%s, gadget %s\n\n",
+			udc->vbus ? "present" : "off",
+			udc->enabled
+			? (udc->vbus ? "active" : "enabled")
+			: "disabled",
+			udc->selfpowered ? "self" : "VBUS",
+			udc->suspended ? ", suspended" : "",
+			udc->driver ? udc->driver->driver.name : "(none)");
+
+	if (udc->enabled && udc->vbus) {
+		proc_ep_show(s, &udc->ep[0]);
+		list_for_each_entry (ep, &udc->gadget.ep_list, ep.ep_list) {
+			if (ep->desc) {
+				proc_ep_show(s, ep);
+			}
+		}
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static int proc_udc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_udc_show, PDE(inode)->data);
+}
+
+static const struct file_operations proc_ops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_udc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void create_debug_file(struct lpc32xx_udc *udc)
+{
+	udc->pde = proc_create_data(debug_filename, 0, NULL, &proc_ops, udc);
+}
+
+static void remove_debug_file(struct lpc32xx_udc *udc)
+{
+	if (udc->pde)
+		remove_proc_entry(debug_filename, NULL);
+}
+
+#else
+static inline void create_debug_file(struct lpc32xx_udc *udc) {}
+static inline void remove_debug_file(struct lpc32xx_udc *udc) {}
+#endif
+
+/*
+ *
+ * ISP1301 transceiver support functions
+ *
+ */
+struct i2c_driver isp1301_driver;
+struct i2c_client *isp1301_i2c_client;
+static int isp1301_probe(struct i2c_client *client, const struct i2c_device_id *i2c_id);
+static int isp1301_remove(struct i2c_client *client);
+
+static const unsigned short normal_i2c[] =
+{ ISP1301_I2C_ADDR, ISP1301_I2C_ADDR + 1, I2C_CLIENT_END };
+
+static const struct i2c_device_id isp1301_id[] = {
+	{ "isp1301_pnx", 0 },
+	{ }
+};
+
+struct i2c_driver isp1301_driver = {
+	.driver = {
+		.name = "isp1301_pnx",
+	},
+	.probe = isp1301_probe,
+	.remove = isp1301_remove,
+	.id_table = isp1301_id,
+};
+
+static int isp1301_probe(struct i2c_client *client, const struct i2c_device_id *i2c_id)
+{
+	return 0;
+}
+
+static int isp1301_remove(struct i2c_client *client)
+{
+	return 0;
+}
+
+static void i2c_write(u8 buf, u8 subaddr)
+{
+	char tmpbuf[2];
+
+	tmpbuf[0] = subaddr;	/*register number */
+	tmpbuf[1] = buf;	/*register data */
+	i2c_master_send(isp1301_i2c_client, &tmpbuf[0], 2);
+}
+
+static u16 i2c_read(u8 subaddr)
+{
+	u8 data;
+
+	i2c_master_send(isp1301_i2c_client, &subaddr, 1);
+	i2c_master_recv(isp1301_i2c_client, (u8 *) &data, 1);
+
+	return data;
+}
+
+static u16 i2c_read16(u8 subaddr)
+{
+	u16 data;
+
+	i2c_master_send(isp1301_i2c_client, &subaddr, 1);
+	i2c_master_recv(isp1301_i2c_client, (u8 *) &data, 2);
+
+	return data;
+}
+
+/* Primary initializion sequence for the ISP1301 transceiver */
+static void isp1301_udc_configure(struct lpc32xx_udc *udc)
+{
+	/* LPC32XX only supports DAT_SE0 USB mode */
+	/* This sequence is important */
+
+	/* Disable transparent UART mode first */
+	i2c_write(MC1_UART_EN, (ISP1301_I2C_MODE_CONTROL_1 |
+				ISP1301_I2C_REG_CLEAR_ADDR));
+
+	/* Set full speed and SE0 mode */
+	i2c_write(~0, (ISP1301_I2C_MODE_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write((MC1_SPEED_REG | MC1_DAT_SE0), ISP1301_I2C_MODE_CONTROL_1);
+
+	/* The PSW_OE enable bit state is reversed in the ISP1301 User's guide! */
+	i2c_write(~0, (ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write((MC2_BI_DI | MC2_SPD_SUSP_CTRL), ISP1301_I2C_MODE_CONTROL_2);
+
+	/* Driver VBUS_DRV high or low depending on board setup */
+	if (udc->board->vbus_drv_pol != 0) {
+		i2c_write(OTG1_VBUS_DRV, ISP1301_I2C_OTG_CONTROL_1);
+	}
+	else {
+		i2c_write(OTG1_VBUS_DRV, (ISP1301_I2C_OTG_CONTROL_1 |
+					ISP1301_I2C_REG_CLEAR_ADDR));
+	}
+
+	/* Bi-derctional mode with suspend control */
+	/* Enable both pulldowns for now - the pullup will be enable when VBUS is detected */
+	i2c_write(~0, (ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write((0 | OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN),
+			ISP1301_I2C_OTG_CONTROL_1);
+
+	/* Discharge VBUS (just in case) */
+	i2c_write(OTG1_VBUS_DISCHRG, ISP1301_I2C_OTG_CONTROL_1);
+	mdelay(1);
+	i2c_write(OTG1_VBUS_DISCHRG,
+			(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+
+	/* Clear and enable VBUS high edge interrupt */
+	i2c_write(~0, ISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR);
+	i2c_write(~0, ISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR);
+	i2c_write(INT_VBUS_VLD, ISP1301_I2C_INTERRUPT_FALLING);
+	i2c_write(~0, ISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR);
+	i2c_write(INT_VBUS_VLD, ISP1301_I2C_INTERRUPT_RISING);
+
+	/* Enable usb_need_clk clock after transceiver is initialized */
+	__raw_writel((__raw_readl(USB_CTRL) | (1 << 22)), USB_CTRL);
+
+	dev_dbg(udc->dev, "USB transceiver Vendor ID  : 0x%04x\n", i2c_read16(0x00));
+	dev_dbg(udc->dev, "USB transceiver Product ID : 0x%04x\n", i2c_read16(0x02));
+	dev_dbg(udc->dev, "USB transceiver Version ID : 0x%04x\n", i2c_read16(0x14));
+}
+
+/* Enables or disables the USB device pullup via the ISP1301 transceiver */
+static void isp1301_pullup_set(int en_pullup)
+{
+	if (en_pullup) {
+		/* Enable pullup for bus signalling */
+		i2c_write(OTG1_DP_PULLUP, ISP1301_I2C_OTG_CONTROL_1);
+	}
+	else {
+		/* Enable pullup for bus signalling */
+		i2c_write(OTG1_DP_PULLUP,
+				(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+	}
+}
+
+static void pullup_work(struct work_struct *work)
+{
+	struct lpc32xx_udc *udc = container_of(work, struct lpc32xx_udc, pullup_wq);
+
+	isp1301_pullup_set(udc->pullup);
+}
+
+static void isp1301_pullup_enable(struct lpc32xx_udc *udc, int en_pullup, int block)
+{
+	if (en_pullup == udc->pullup)
+		return;
+
+	udc->pullup = en_pullup;
+	if (block)
+		isp1301_pullup_set(en_pullup);
+	else
+		schedule_work(&udc->pullup_wq);
+}
+
+#ifdef CONFIG_PM
+/* Powers up or down the ISP1301 transceiver */
+static void isp1301_set_powerstate(int enable) {
+	if (enable != 0) {
+		/* Power up ISP1301 - this ISP1301 will automatically wakeup
+		   when VBUS is detected */
+		i2c_write(MC2_GLOBAL_PWR_DN,
+				(ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR));
+	}
+	else {
+		/* Power down ISP1301 */
+		i2c_write(MC2_GLOBAL_PWR_DN, ISP1301_I2C_MODE_CONTROL_2);
+	}
+}
+
+static void power_work(struct work_struct *work)
+{
+	struct lpc32xx_udc *udc = container_of(work, struct lpc32xx_udc, power_wq);
+
+	isp1301_set_powerstate(udc->poweron);
+}
+#endif
+
+/*
+ *
+ * USB protocol engine command/data read/write helper functions
+ *
+ */
+/* Issues a single command to the USB device state machine */
+static void udc_protocol_cmd_w(struct lpc32xx_udc *udc, u32 cmd)
+{
+	u32 pass = 0;
+	int to;
+
+	/* EP may lock on CLRI if this read isn't done */
+	volatile u32 tmp = __raw_readl(USBD_DEVINTST(udc->udp_baseaddr));
+	(void) tmp;
+
+	while (pass == 0) {
+		__raw_writel(USBD_CCEMPTY, USBD_DEVINTCLR(udc->udp_baseaddr));
+
+		/* Write command code */
+		__raw_writel(cmd, USBD_CMDCODE(udc->udp_baseaddr));
+		to = 10000;
+		while (((__raw_readl(USBD_DEVINTST(udc->udp_baseaddr)) &
+			USBD_CCEMPTY) == 0) && (to > 0)) {
+			to--;
+		}
+
+		if (to > 0) pass = 1;
+	}
+}
+
+/* Issues 2 commands (or command and data) to the USB device state machine */
+static inline void udc_protocol_cmd_data_w(struct lpc32xx_udc *udc, u32 cmd, u32 data) {
+	udc_protocol_cmd_w(udc, cmd);
+	udc_protocol_cmd_w(udc, data);
+}
+
+/* Issues a single command to the USB device state machine and reads
+   response data */
+static u32 udc_protocol_cmd_r(struct lpc32xx_udc *udc, u32 cmd)
+{
+	volatile u32 tmp;
+	int to = 1000;
+
+	/* Write a command and read data from the protocol engine */
+	__raw_writel((USBD_CDFULL | USBD_CCEMPTY),
+			USBD_DEVINTCLR(udc->udp_baseaddr));
+
+	/* Write command code */
+	udc_protocol_cmd_w(udc, cmd);
+
+	tmp = __raw_readl(USBD_DEVINTST(udc->udp_baseaddr));
+	while ((!(__raw_readl(USBD_DEVINTST(udc->udp_baseaddr)) & USBD_CDFULL))
+		&& (to > 0))
+		to--;
+	if (!to)
+		dev_dbg(udc->dev, "Protocol engine didn't receive response (CDFULL)\n");
+
+	return __raw_readl(USBD_CMDDATA(udc->udp_baseaddr));
+}
+
+/*
+ *
+ * USB device interrupt mask support functions
+ *
+ */
+/* Enable one or more USB device interrupts */
+static inline void uda_enable_devint(struct lpc32xx_udc *udc, u32 devmask) {
+	udc->enabled_devints |= devmask;
+	__raw_writel(udc->enabled_devints, USBD_DEVINTEN(udc->udp_baseaddr));
+}
+
+/* Disable one or more USB device interrupts */
+static inline void uda_disable_devint(struct lpc32xx_udc *udc, u32 mask) {
+	udc->enabled_devints &= ~mask;
+	__raw_writel(udc->enabled_devints, USBD_DEVINTEN(udc->udp_baseaddr));
+}
+
+/* Clear one or more USB device interrupts */
+static inline void uda_clear_devint(struct lpc32xx_udc *udc, u32 mask) {
+	__raw_writel(mask, USBD_DEVINTCLR(udc->udp_baseaddr));
+}
+
+/*
+ *
+ * Endpoint interrupt disable/enable functions
+ *
+ */
+/* Enable one or more USB endpoint interrupts */
+static void uda_enable_hwepint(struct lpc32xx_udc *udc, u32 hwep) {
+	udc->enabled_hwepints |= (1 << hwep);
+	__raw_writel(udc->enabled_hwepints, USBD_EPINTEN(udc->udp_baseaddr));
+}
+
+/* Disable one or more USB endpoint interrupts */
+static void uda_disable_hwepint(struct lpc32xx_udc *udc, u32 hwep) {
+	udc->enabled_hwepints &= ~(1 << hwep);
+	__raw_writel(udc->enabled_hwepints, USBD_EPINTEN(udc->udp_baseaddr));
+}
+
+/* Clear one or more USB endpoint interrupts */
+static inline void uda_clear_hwepint(struct lpc32xx_udc *udc, u32 hwep) {
+	__raw_writel((1 << hwep), USBD_EPINTCLR(udc->udp_baseaddr));
+}
+
+/* Enable DMA for the HW channel */
+static inline void udc_ep_dma_enable(struct lpc32xx_udc *udc, u32 hwep) {
+	__raw_writel((1 << hwep), USBD_EPDMAEN(udc->udp_baseaddr));
+}
+
+/* Disable DMA for the HW channel */
+static inline void udc_ep_dma_disable(struct lpc32xx_udc *udc, u32 hwep) {
+	__raw_writel((1 << hwep), USBD_EPDMADIS(udc->udp_baseaddr));
+}
+
+/*
+ *
+ * Endpoint realize/unrealize functions
+ *
+ */
+/* Before an endpoint can be used, it needs to be realized
+   in the USB protocol engine - this realizes the endpoint.
+   The interrupt (FIFO or DMA) is not enabled with this function */
+static void udc_realize_hwep(struct lpc32xx_udc *udc, u32 hwep,
+		u32 maxpacket) {
+	int to = 1000;
+
+	__raw_writel(USBD_EP_RLZED, USBD_DEVINTCLR(udc->udp_baseaddr));
+	__raw_writel(hwep, USBD_EPIND(udc->udp_baseaddr));
+	udc->realized_eps |= (1 << hwep);
+	__raw_writel(udc->realized_eps, USBD_REEP(udc->udp_baseaddr));
+	__raw_writel(maxpacket, USBD_EPMAXPSIZE(udc->udp_baseaddr));
+
+	/* Wait until endpoint is realized in hardware */
+	while ((!(__raw_readl(USBD_DEVINTST(udc->udp_baseaddr)) & USBD_EP_RLZED))
+		&& (to > 0))
+		to--;
+	if (!to)
+		dev_dbg(udc->dev, "EP not correctly realized in hardware\n");
+
+	__raw_writel(USBD_EP_RLZED, USBD_DEVINTCLR(udc->udp_baseaddr));
+}
+
+/* Unrealize an EP */
+static void udc_unrealize_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc->realized_eps &= ~(1 << hwep);
+	__raw_writel(udc->realized_eps, USBD_REEP(udc->udp_baseaddr));
+}
+
+/*
+ *
+ * Endpoint support functions
+ *
+ */
+/* Select and clear endpoint interrupt */
+static u32 udc_selep_clrint(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_protocol_cmd_w(udc, CMD_SEL_EP_CLRI(hwep));
+	return udc_protocol_cmd_r(udc, DAT_SEL_EP_CLRI(hwep));
+}
+
+/* Disables the endpoint in the USB protocol engine */
+static void udc_disable_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),
+			DAT_WR_BYTE(EP_STAT_DA));
+}
+
+/* Stalls the endpoint - endpoint will return STALL */
+static void udc_stall_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),
+			DAT_WR_BYTE(EP_STAT_ST));
+}
+
+/* Clear stall or reset endpoint */
+static void udc_clrstall_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(hwep),
+			DAT_WR_BYTE(0));
+}
+
+/* Select an endpoint for endpoint status, clear, validate */
+static void udc_select_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_protocol_cmd_w(udc, CMD_SEL_EP(hwep));
+}
+
+/*
+ *
+ * Endpoint buffer management functions
+ *
+ */
+/* Clear the current endpoint's buffer */
+static void udc_clr_buffer_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_select_hwep(udc, hwep);
+	udc_protocol_cmd_w(udc, CMD_CLR_BUF);
+}
+
+/* Validate the current endpoint's buffer */
+static void udc_val_buffer_hwep(struct lpc32xx_udc *udc, u32 hwep) {
+	udc_select_hwep(udc, hwep);
+	udc_protocol_cmd_w(udc, CMD_VALID_BUF);
+}
+
+static inline u32 udc_clearep_getsts(struct lpc32xx_udc *udc, u32 hwep) {
+	/* Clear EP interrupt */
+	uda_clear_hwepint(udc, hwep);
+	return udc_selep_clrint(udc, hwep);
+}
+
+/*
+ *
+ * USB EP DMA support
+ *
+ */
+/* Allocate a DMA Descriptor */
+static struct lpc32xx_usbd_dd_gad *udc_dd_alloc(struct lpc32xx_udc *udc) {
+	dma_addr_t			dma;
+	struct lpc32xx_usbd_dd_gad	*dd;
+
+	dd = (struct lpc32xx_usbd_dd_gad *) dma_pool_alloc(
+			udc->dd_cache, (GFP_KERNEL | GFP_DMA), &dma);
+	if (dd)
+		dd->this_dma = dma;
+
+	return dd;
+}
+
+/* Free a DMA Descriptor */
+static void udc_dd_free(struct lpc32xx_udc *udc, struct lpc32xx_usbd_dd_gad *dd)
+{
+	dma_pool_free(udc->dd_cache, dd, dd->this_dma);
+}
+
+/*
+ *
+ * USB setup and shutdown functions
+ *
+ */
+/* Enables or disables most of the USB system clocks when low power mode is
+   needed. Clocks are typically started on a connection event, and disabled
+   when a cable is disconnected */
+#define OTGOFF_CLK_MASK (AHB_M_CLOCK_ON | I2C_CLOCK_ON)
+static void udc_clk_set(struct lpc32xx_udc *udc, int enable)
+{
+	int to = 1000;
+
+	if (enable != 0) {
+		if (udc->clocked)
+			return;
+
+		udc->clocked = 1;
+
+		/* 48MHz PLL up */
+		clk_enable(udc->usb_pll_clk);
+
+		/* Enable the USb device clock */
+		__raw_writel(__raw_readl(USB_CTRL) | USB_DEV_NEED_CLK_EN, USB_CTRL);
+
+		/* Set to enable all needed USB OTG clocks */
+		__raw_writel(USB_CLOCK_MASK, USB_OTG_CLK_CTRL);
+
+		while (((__raw_readl(USB_OTG_CLK_STAT) & USB_CLOCK_MASK) !=
+				USB_CLOCK_MASK) && (to > 0))
+			to--;
+		if (!to)
+			dev_dbg(udc->dev, "Cannot enable USB OTG clocking\n");
+	}
+	else {
+		if (!udc->clocked)
+			return;
+
+		udc->clocked = 0;
+
+		/* Never disable the USB_HCLK during normal operation */
+
+		/* 48MHz PLL dpwn */
+		clk_disable(udc->usb_pll_clk);
+
+		/* Enable the USb device clock */
+		__raw_writel(__raw_readl(USB_CTRL) & ~USB_DEV_NEED_CLK_EN, USB_CTRL);
+
+		/* Set to enable all needed USB OTG clocks */
+		__raw_writel(OTGOFF_CLK_MASK, USB_OTG_CLK_CTRL);
+
+		while (((__raw_readl(USB_OTG_CLK_STAT) & OTGOFF_CLK_MASK) !=
+				OTGOFF_CLK_MASK) && (to > 0))
+			to--;
+		if (!to)
+			dev_dbg(udc->dev, "Cannot disable USB OTG clocking\n");
+	}
+}
+
+static void udc_disable(struct lpc32xx_udc *udc) {
+	u32 i;
+
+	/* Disable device */
+	udc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(0));
+	udc_protocol_cmd_data_w(udc, CMD_SET_DEV_STAT, DAT_WR_BYTE(0));
+
+	/* Disable all device interrupts (including EP0) */
+	uda_disable_devint(udc, 0x3FF);
+
+	/* Disable and reset all endpoint interrupts */
+	for (i = 0; i < 32; i++) {
+	     	uda_disable_hwepint(udc, i);
+		uda_clear_hwepint(udc, i);
+		udc_disable_hwep(udc, i);
+		udc_unrealize_hwep(udc, i);
+		udc->udca_v_base [i] = 0;
+
+		/* Disable and clear all interrupts and DMA */
+		udc_ep_dma_disable(udc, i);
+		__raw_writel((1 << i), USBD_EOTINTCLR(udc->udp_baseaddr));
+		__raw_writel((1 << i), USBD_NDDRTINTCLR(udc->udp_baseaddr));
+		__raw_writel((1 << i), USBD_SYSERRTINTCLR(udc->udp_baseaddr));
+		__raw_writel((1 << i), USBD_DMARCLR(udc->udp_baseaddr));
+	}
+
+	/* Disable DMA interrupts */
+	__raw_writel(0, USBD_DMAINTEN(udc->udp_baseaddr));
+
+	__raw_writel(0, USBD_UDCAH(udc->udp_baseaddr));
+}
+
+static void udc_enable(struct lpc32xx_udc *udc)
+{
+	u32 i;
+	struct lpc32xx_ep *ep = &udc->ep[0];
+
+	/* Start with known state */
+	udc_disable(udc);
+
+	/* Enable device */
+	udc_protocol_cmd_data_w(udc, CMD_SET_DEV_STAT, DAT_WR_BYTE(DEV_CON));
+
+	/* EP interrupts on high priority, FRAME interrupt on low priority */
+	__raw_writel(USBD_EP_FAST, USBD_DEVINTPRI(udc->udp_baseaddr));
+	__raw_writel(0xFFFF, USBD_EPINTPRI(udc->udp_baseaddr));
+
+	/* Clear any pending device interrupts */
+	__raw_writel(0x3FF, USBD_DEVINTCLR(udc->udp_baseaddr));
+
+	/* Setup UDCA - not yet used (DMA) */
+	__raw_writel((u32) udc->udca_p_base, USBD_UDCAH(udc->udp_baseaddr));
+
+	/* Only enable EP0 in and out for now, EP0 only works in FIFO mode */
+	for (i = 0; i <= 1; i++) {
+		udc_realize_hwep(udc, i, ep->ep.maxpacket);
+		uda_enable_hwepint(udc, i);
+		udc_select_hwep(udc, i);
+		udc_clrstall_hwep(udc, i);
+		udc_clr_buffer_hwep(udc, i);
+	}
+
+	/* Device interrupt setup */
+	uda_clear_devint(udc, (USBD_ERR_INT | USBD_DEV_STAT | USBD_EP_SLOW |
+				USBD_EP_FAST));
+	uda_enable_devint(udc, (USBD_ERR_INT | USBD_DEV_STAT | USBD_EP_SLOW |
+				USBD_EP_FAST));
+
+	/* Set device address to 0 - called twice to force a latch in the USB
+	   engine without the need of a setup packet status closure */
+	udc_set_address(udc, 0);
+	udc_set_address(udc, 0);
+
+	/* Enable master DMA interrupts */
+	__raw_writel((USBD_SYS_ERR_INT | USBD_EOT_INT), USBD_DMAINTEN(udc->udp_baseaddr));
+
+	udc->dev_status = 0;
+}
+
+/*
+ *
+ * USB device board specific events handled via callbacks
+ *
+ */
+/* Connection change event - notify board function of change */
+static void uda_power_event(struct lpc32xx_udc *udc, u32 conn) {
+	/* Just notify of a connection change event (optional) */
+	if (udc->board->conn_chgb != NULL) {
+		udc->board->conn_chgb(conn);
+	}
+}
+
+/* Suspend/resume event - notify board function of change */
+static void uda_resm_susp_event(struct lpc32xx_udc *udc, u32 conn) {
+	/* Just notify of a Suspend/resume change event (optional) */
+	if (udc->board->susp_chgb != NULL) {
+		udc->board->susp_chgb(conn);
+	}
+
+	if (conn)
+		udc->suspended = 0;
+	else
+		udc->suspended = 1;
+}
+
+/* Remote wakeup enable/disable - notify board function of change */
+static void uda_remwkp_cgh(struct lpc32xx_udc *udc) {
+	if (udc->board->rmwk_chgb != NULL) {
+		udc->board->rmwk_chgb(udc->dev_status &
+				(1 << USB_DEVICE_REMOTE_WAKEUP));
+	}
+}
+
+/* Reads data from FIFO, adjusts for alignment and data size */
+static void udc_pop_fifo(struct lpc32xx_udc *udc, u8 *data, u32 bytes) {
+	int n, i, bl;
+	u16 *p16;
+	u32 *p32, tmp, cbytes;
+
+	/* Use optimal data transfer method based on source address and size */
+	switch (((u32) data) & 0x3) {
+		case 0: /* 32-bit aligned */
+			p32 = (u32 *) data;
+			cbytes = (bytes & ~0x3);
+
+			/* Copy 32-bit aligned data first */
+			for (n = 0; n < cbytes; n += 4)
+				*p32++ = __raw_readl(USBD_RXDATA(udc->udp_baseaddr));
+
+			/* Handle any remaining bytes */
+			bl = bytes - cbytes;
+			if (bl) {
+				tmp = __raw_readl(USBD_RXDATA(udc->udp_baseaddr));
+				for (n = 0; n < bl; n++)
+					data[cbytes + n] = ((tmp >> (n * 8)) & 0xFF);
+
+			}
+			break;
+
+		case 1: /* 8-bit aligned */
+		case 3:
+			/* Each byte has to be handled independently */
+			for (n = 0; n < bytes; n += 4) {
+				tmp = __raw_readl(USBD_RXDATA(udc->udp_baseaddr));
+
+				bl = bytes - n;
+				if (bl > 3)
+					bl = 3;
+
+				for (i = 0; i < bl; i++)
+					data[n + i] = (u8) ((tmp >> (n * 8)) & 0xFF);
+			}
+			break;
+
+		case 2: /* 16-bit aligned */
+			p16 = (u16 *) data;
+			cbytes = (bytes & ~0x3);
+
+			/* Copy 32-bit sized objects first with 16-bit alignment */
+			for (n = 0; n < cbytes; n += 4) {
+				tmp = __raw_readl(USBD_RXDATA(udc->udp_baseaddr));
+				*p16++ = (u16) (tmp & 0xFFFF);
+				*p16++ = (u16) ((tmp >> 16) & 0xFFFF);
+			}
+
+			/* Handle any remaining bytes */
+			bl = bytes - cbytes;
+			if (bl) {
+				tmp = __raw_readl(USBD_RXDATA(udc->udp_baseaddr));
+				for (n = 0; n < bl; n++)
+					data[cbytes + n] = ((tmp >> (n * 8)) & 0xFF);
+			}
+			break;
+	}
+}
+
+/* Read data from the FIFO for an endpoint. This function is for endpoints (such
+   as EP0) that don't use DMA. This function should only be called if a packet
+   is known to be ready to read for the endpopint. Note that the endpoint must
+   be selected in the protocol engine prior to this call. */
+static u32 udc_read_hwep(struct lpc32xx_udc *udc, u32 hwep, u32 *data,
+		int bytes) {
+	volatile u32 tmpv;
+	int to = 1000;
+	u32 tmp, hwrep = ((hwep & 0x1E) << 1) | CTRL_RD_EN;
+
+	/* Setup read of endpoint */
+	__raw_writel(hwrep, USBD_CTRL(udc->udp_baseaddr));
+
+	/* Wait until packet is ready */
+	while (((__raw_readl(USBD_RXPLEN(udc->udp_baseaddr)) & PKT_RDY) == 0)
+		&& (to > 0))
+		to--;
+	if (!to)
+		dev_dbg(udc->dev, "No packet ready on FIFO EP read\n");
+
+	/* Mask out count */
+	tmp = tmpv & PKT_LNGTH_MASK;
+	if (bytes < tmp) {
+		tmp = (u32) bytes;
+	}
+
+	if ((tmp > 0) && (data != NULL)) {
+		udc_pop_fifo(udc, (u8 *) data, tmp);
+	}
+
+	__raw_writel(((hwep & 0x1E) << 1), USBD_CTRL(udc->udp_baseaddr));
+
+	/* Clear the buffer */
+	udc_clr_buffer_hwep(udc, hwep);
+
+	return tmp;
+}
+
+/* Stuffs data into the FIFO, adjusts for alignment and data size */
+static void udc_stuff_fifo(struct lpc32xx_udc *udc, u8 *data, u32 bytes) {
+	int n, i, bl;
+	u16 *p16;
+	u32 *p32, tmp, cbytes;
+
+	/* Use optimal data transfer method based on source address and size */
+	switch (((u32) data) & 0x3) {
+		case 0: /* 32-bit aligned */
+			p32 = (u32 *) data;
+			cbytes = (bytes & ~0x3);
+
+			/* Copy 32-bit aligned data first */
+			for (n = 0; n < cbytes; n += 4)
+				__raw_writel(*p32++, USBD_TXDATA(udc->udp_baseaddr));
+
+			/* Handle any remaining bytes */
+			bl = bytes - cbytes;
+			if (bl) {
+				tmp = 0;
+				for (n = 0; n < bl; n++)
+					tmp |= (u32) (data[cbytes + n] << (n * 8));
+
+				__raw_writel(tmp, USBD_TXDATA(udc->udp_baseaddr));
+			}
+			break;
+
+		case 1: /* 8-bit aligned */
+		case 3:
+			/* Each byte has to be handled independently */
+			for (n = 0; n < bytes; n += 4) {
+				bl = bytes - n;
+				if (bl > 4)
+					bl = 4;
+
+				tmp = 0;
+				for (i = 0; i < bl; i++)
+					tmp |= (u32) (data[n + i] << (i * 8));
+
+				__raw_writel(tmp, USBD_TXDATA(udc->udp_baseaddr));
+			}
+			break;
+
+		case 2: /* 16-bit aligned */
+			p16 = (u16 *) data;
+			cbytes = (bytes & ~0x3);
+
+			/* Copy 32-bit aligned data first */
+			for (n = 0; n < cbytes; n += 4) {
+				tmp = (u32) (*p16++ & 0xFFFF);
+				tmp |= (u32) ((*p16++ & 0xFFFF) << 16);
+				__raw_writel(tmp, USBD_TXDATA(udc->udp_baseaddr));
+			}
+
+			/* Handle any remaining bytes */
+			bl = bytes - cbytes;
+			if (bl) {
+				tmp = 0;
+				for (n = 0; n < bl; n++)
+					tmp |= (u32) (data[cbytes + n] << (n * 8));
+
+				__raw_writel(tmp, USBD_TXDATA(udc->udp_baseaddr));
+			}
+			break;
+	}
+}
+
+/* Write data to the FIFO for an endpoint. This function is for endpoints (such
+   as EP0) that don't use DMA. Note that the endpoint must be selected in the
+   protocol engine prior to this call. */
+static void udc_write_hwep(struct lpc32xx_udc *udc, u32 hwep,
+		u32 *data, u32 bytes) {
+	u32 hwwep = ((hwep & 0x1E) << 1) | CTRL_WR_EN;
+
+	if ((bytes > 0) && (data == NULL)) {
+		return;
+	}
+
+	/* Setup write of endpoint */
+	__raw_writel(hwwep, USBD_CTRL(udc->udp_baseaddr));
+
+	__raw_writel(bytes, USBD_TXPLEN(udc->udp_baseaddr));
+
+	/* Need at least 1 byte to trigger TX */
+	if (bytes == 0) {
+		__raw_writel(0, USBD_TXDATA(udc->udp_baseaddr));
+	}
+	else {
+		udc_stuff_fifo(udc, (u8 *) data, bytes);
+	}
+
+	__raw_writel(((hwep & 0x1E) << 1), USBD_CTRL(udc->udp_baseaddr));
+
+	udc_val_buffer_hwep(udc, hwep);
+}
+
+/*
+ *
+ * USB protocol high level support functions
+ *
+ */
+/* Set/reset USB device address */
+static void udc_set_address(struct lpc32xx_udc *udc, u32 addr) {
+	/* Address will be latched at the end of the status phase, or
+	   latched immediately if function is called twice */
+	udc_protocol_cmd_data_w(udc, CMD_SET_ADDR,
+			DAT_WR_BYTE(DEV_EN | addr));
+}
+
+/* USB device reset - resets USB to a default state with just EP0
+   enabled */
+static void uda_usb_reset(struct lpc32xx_udc *udc) {
+	u32 i = 0;
+	/* Re-init device controller and EP0 */
+	udc_enable(udc);
+	udc->gadget.speed = USB_SPEED_FULL;
+
+	for (i = 1; i < NUM_ENDPOINTS; i++) {
+		struct lpc32xx_ep *ep = &udc->ep[i];
+		ep->req_pending = 0;
+	}
+}
+
+/* Send a ZLP on EP0 */
+static void udc_ep0_send_zlp(struct lpc32xx_udc *udc) {
+	udc_write_hwep(udc, EP_IN, NULL, 0);
+}
+
+/* Get current frame number */
+static u16 udc_get_current_frame(struct lpc32xx_udc *udc) {
+	u16 flo, fhi;
+
+	udc_protocol_cmd_w(udc, CMD_RD_FRAME);
+	flo = (u16) udc_protocol_cmd_r(udc, DAT_RD_FRAME);
+	fhi = (u16) udc_protocol_cmd_r(udc, DAT_RD_FRAME);
+
+	return (fhi << 8) | flo;
+}
+
+/* Set the device as configured - enables all endpoints */
+static inline void udc_set_device_configured(struct lpc32xx_udc *udc) {
+	udc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(CONF_DVICE));
+}
+
+/* Set the device as unconfigured - disables all endpoints */
+static inline void udc_set_device_unconfigured(struct lpc32xx_udc *udc) {
+	udc_protocol_cmd_data_w(udc, CMD_CFG_DEV, DAT_WR_BYTE(0));
+}
+
+/* reinit == restore inital software state */
+static void udc_reinit(struct lpc32xx_udc *udc)
+{
+	u32 i;
+
+	INIT_LIST_HEAD(&udc->gadget.ep_list);
+	INIT_LIST_HEAD(&udc->gadget.ep0->ep_list);
+
+	for (i = 0; i < NUM_ENDPOINTS; i++) {
+		struct lpc32xx_ep *ep = &udc->ep[i];
+
+		if (i != 0) {
+			list_add_tail(&ep->ep.ep_list, &udc->gadget.ep_list);
+		}
+		ep->desc = NULL;
+		ep->ep.maxpacket = ep->maxpacket;
+		INIT_LIST_HEAD(&ep->queue);
+		ep->req_pending = 0;
+	}
+
+	udc->ep0state = WAIT_FOR_SETUP;
+}
+
+/* Must be called with lock */
+static void done(struct lpc32xx_ep *ep, struct lpc32xx_request *req, int status)
+{
+	struct lpc32xx_udc *udc = ep->udc;
+
+	list_del_init(&req->queue);
+	if (req->req.status == -EINPROGRESS) {
+		req->req.status = status;
+	}
+	else {
+		status = req->req.status;
+	}
+
+	if (ep->lep) {
+		enum dma_data_direction direction;
+
+		if (ep->is_in)
+			direction = DMA_TO_DEVICE;
+		else
+			direction = DMA_FROM_DEVICE;
+
+		if (req->mapped) {
+			dma_unmap_single(ep->udc->gadget.dev.parent,
+					req->req.dma, req->req.length, direction);
+			req->req.dma = 0;
+			req->mapped = 0;
+		}
+		else {
+			dma_sync_single_for_cpu(ep->udc->gadget.dev.parent,
+					req->req.dma, req->req.length, direction);
+		}
+
+		/* Free DDs */
+		udc_dd_free(udc, req->dd_desc_ptr);
+	}
+
+	if (status && status != -ESHUTDOWN) {
+		ep_dbg(ep, "%s done %p, status %d\n", ep->ep.name, req, status);
+	}
+
+	ep->req_pending = 0;
+	spin_unlock(&udc->lock);
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&udc->lock);
+}
+
+/* Must be called with lock */
+static void nuke(struct lpc32xx_ep *ep, int status)
+{
+	struct lpc32xx_request *req;
+
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct lpc32xx_request, queue);
+		done(ep, req, status);
+	}
+
+	if (ep->desc) {
+		if (status == -ESHUTDOWN) {
+			uda_disable_hwepint(ep->udc, ep->hwep_num);
+			udc_disable_hwep(ep->udc, ep->hwep_num);
+		}
+	}
+}
+
+/* Must be called with lock */
+static void stop_activity(struct lpc32xx_udc *udc)
+{
+	struct usb_gadget_driver *driver = udc->driver;
+	int i;
+
+	if (udc->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = NULL;
+
+	udc->gadget.speed = USB_SPEED_UNKNOWN;
+	udc->suspended = 0;
+
+	for (i = 0; i < NUM_ENDPOINTS; i++) {
+		struct lpc32xx_ep *ep = &udc->ep[i];
+		nuke(ep, -ESHUTDOWN);
+	}
+	if (driver) {
+		spin_unlock(&udc->lock);
+		driver->disconnect(&udc->gadget);
+		spin_lock(&udc->lock);
+	}
+
+	isp1301_pullup_enable(udc, 0, 0);
+	udc_disable(udc);
+	udc_reinit(udc);
+}
+
+/*
+ * Activate or kill host pullup
+ * Can be called with or without lock
+ */
+static void pullup(struct lpc32xx_udc *udc, int is_on)
+{
+	if(!udc->clocked)
+		return;
+
+	if (!udc->enabled || !udc->vbus)
+		is_on = 0;
+
+	if (is_on != udc->pullup)
+		isp1301_pullup_enable(udc, is_on, 0);
+}
+
+/* Must be called without lock */
+static int lpc32xx_ep_disable (struct usb_ep * _ep)
+{
+	struct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);
+	struct lpc32xx_udc *udc = ep->udc;
+	unsigned long	flags;
+
+	if ((ep->hwep_num_base == 0) || (ep->hwep_num == 0)) {
+		return -EINVAL;
+	}
+	spin_lock_irqsave(&udc->lock, flags);
+
+	nuke(ep, -ESHUTDOWN);
+
+	/* restore the endpoint's pristine config */
+	ep->desc = NULL;
+
+	/* Clear all DMA statuses for this EP */
+	udc_ep_dma_disable(udc, ep->hwep_num);
+	__raw_writel((1 << ep->hwep_num), USBD_EOTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_NDDRTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_SYSERRTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_DMARCLR(udc->udp_baseaddr));
+
+	/* Remove the DD pointer in the UDCA */
+	udc->udca_v_base[ep->hwep_num] = 0;
+
+	/* Disable and reset endpoint and interrupt */
+	uda_clear_hwepint(udc, ep->hwep_num);
+	udc_unrealize_hwep(udc, ep->hwep_num);
+
+	ep->hwep_num = 0;
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+        atomic_dec(&udc->enabled_ep_cnt);
+        wake_up(&udc->ep_disable_wait_queue);
+
+	return 0;
+}
+
+/* Must be called without lock */
+static int lpc32xx_ep_enable(struct usb_ep *_ep,
+		const struct usb_endpoint_descriptor *desc)
+{
+	struct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);
+	struct lpc32xx_udc *udc = ep->udc;
+	u16 maxpacket;
+	u32 tmp;
+	unsigned long flags;
+
+	/* Verify EP data */
+	if ((!_ep) || (!ep) || (!desc) || (ep->desc) ||
+			(desc->bDescriptorType != USB_DT_ENDPOINT) ||
+			((maxpacket = le16_to_cpu(desc->wMaxPacketSize)) == 0) ||
+			(maxpacket > ep->maxpacket)) {
+		dev_dbg(udc->dev, "bad ep or descriptor\n");
+		return -EINVAL;
+	}
+
+	/* Don't touch EP0 */
+	if (ep->hwep_num_base == 0) {
+		dev_dbg(udc->dev, "Can't re-enable EP0!!!\n");
+		return -EINVAL;
+	}
+
+	/* Is driver ready? */
+	if ((!udc->driver) || (udc->gadget.speed == USB_SPEED_UNKNOWN)) {
+		dev_dbg(udc->dev, "bogus device state\n");
+		return -ESHUTDOWN;
+	}
+
+	tmp = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
+	switch (tmp) {
+		case USB_ENDPOINT_XFER_CONTROL:
+			return -EINVAL;
+
+		case USB_ENDPOINT_XFER_INT:
+			if (maxpacket > ep->maxpacket) {
+				dev_dbg(udc->dev, "Bad INT endpoint maxpacket %d\n", maxpacket);
+				return -EINVAL;
+			}
+			break;
+
+		case USB_ENDPOINT_XFER_BULK:
+			switch (maxpacket) {
+				case 8:
+				case 16:
+				case 32:
+				case 64:
+					break;
+
+				default:
+					dev_dbg(udc->dev, "Bad BULK endpoint maxpacket %d\n", maxpacket);
+					return -EINVAL;
+			}
+			break;
+
+		case USB_ENDPOINT_XFER_ISOC:
+			break;
+	}
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* Initialize endpoint to match the selected descriptor */
+	ep->is_in = (desc->bEndpointAddress & USB_DIR_IN) != 0;
+	ep->desc = desc;
+	ep->ep.maxpacket = maxpacket;
+
+	/* Map hardware endpoint from base and direction */
+	if (ep->is_in) {
+		/* IN endpoints are offset 1 from the OUT endpoint */
+		ep->hwep_num = ep->hwep_num_base + EP_IN;
+	}
+	else {
+		ep->hwep_num = ep->hwep_num_base;
+	}
+
+	ep_dbg(ep, "EP enabled: %s, HW:%d, MP:%d IN:%d\n", ep->ep.name, ep->hwep_num,
+			maxpacket, (ep->is_in == 1));
+
+	/* Realize the endpoint, interrupt is enabled later when
+	   buffers are queued, IN EPs will NAK until buffers are ready */
+	udc_realize_hwep(udc, ep->hwep_num, ep->ep.maxpacket);
+	udc_clr_buffer_hwep(udc, ep->hwep_num);
+	uda_disable_hwepint(udc, ep->hwep_num);
+	udc_clrstall_hwep(udc, ep->hwep_num);
+
+	/* Clear all DMA statuses for this EP */
+	udc_ep_dma_disable(udc, ep->hwep_num);
+	__raw_writel((1 << ep->hwep_num), USBD_EOTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_NDDRTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_SYSERRTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_DMARCLR(udc->udp_baseaddr));
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	atomic_inc(&udc->enabled_ep_cnt);
+	return 0;
+}
+
+/*
+ * Allocate a USB request list
+ * Can be called with or without lock
+ */
+static struct usb_request *lpc32xx_ep_alloc_request(
+		struct usb_ep *_ep, gfp_t gfp_flags)
+{
+	struct lpc32xx_request *req;
+
+	req = kzalloc(sizeof (struct lpc32xx_request), gfp_flags);
+	if (!req)
+		return NULL;
+
+	INIT_LIST_HEAD(&req->queue);
+	return &req->req;
+}
+
+/*
+ * De-allocate a USB request list
+ * Can be called with or without lock
+ */
+static void lpc32xx_ep_free_request(struct usb_ep *_ep,
+		struct usb_request *_req)
+{
+	struct lpc32xx_request *req;
+
+	req = container_of(_req, struct lpc32xx_request, req);
+	BUG_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+/* Must be called without lock */
+static int lpc32xx_ep_queue(struct usb_ep *_ep,
+		struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct lpc32xx_request *req;
+	struct lpc32xx_ep *ep;
+	struct lpc32xx_udc *udc;
+	unsigned long flags;
+	int status = 0;
+
+	req = container_of(_req, struct lpc32xx_request, req);
+	ep = container_of(_ep, struct lpc32xx_ep, ep);
+
+	if (!_req || !_req->complete || !_req->buf || !list_empty(&req->queue)) {
+		return -EINVAL;
+	}
+
+	udc = ep->udc;
+
+	if (!_ep || (!ep->desc && ep->hwep_num_base != 0)) {
+		dev_dbg(udc->dev, "invalid ep\n");
+		return -EINVAL;
+	}
+
+
+	if ((!udc) || (!udc->driver) || (udc->gadget.speed == USB_SPEED_UNKNOWN)) {
+		dev_dbg(udc->dev, "invalid device\n");
+		return -EINVAL;
+	}
+
+	if (ep->lep) {
+		enum dma_data_direction direction;
+		struct lpc32xx_usbd_dd_gad *dd;
+
+		/* Map DMA pointer */
+		if (ep->is_in)
+			direction = DMA_TO_DEVICE;
+		else
+			direction = DMA_FROM_DEVICE;
+
+		if (req->req.dma == 0) {
+			req->req.dma = dma_map_single(
+					ep->udc->gadget.dev.parent,
+					req->req.buf, req->req.length, direction);
+			req->mapped = 1;
+		}
+		else {
+			dma_sync_single_for_device(
+					ep->udc->gadget.dev.parent,
+					req->req.dma, req->req.length, direction);
+			req->mapped = 0;
+		}
+
+		/* For the request, build a list of DDs */
+		dd = udc_dd_alloc(udc);
+		if (!dd) {
+			/* Error allocating DD */
+			return -ENOMEM;
+		}
+		req->dd_desc_ptr = dd;
+
+		/* Setup the DMA descriptor */
+		dd->dd_next_phy = dd->dd_next_v = NULL;
+		dd->dd_buffer_addr = (u32) req->req.dma;
+		dd->dd_status = 0;
+
+		/* Special handling for ISO EPs */
+		if (ep->eptype == EP_ISO_TYPE) {
+			dd->dd_setup = DD_SETUP_ISO_EP |
+				DD_SETUP_PACKETLEN(0) |
+				DD_SETUP_DMALENBYTES(1);
+			dd->dd_iso_ps_mem_addr = (u32 *) ((u32) dd->this_dma + 24);
+			if (ep->is_in)
+				dd->iso_status[0] = req->req.length;
+			else
+				dd->iso_status[0] = 0;
+		}
+		else
+			dd->dd_setup = DD_SETUP_PACKETLEN(ep->ep.maxpacket) |
+				DD_SETUP_DMALENBYTES(req->req.length);
+	}
+
+	ep_dbg(ep, "%s queue req %p len %d buf %p (in=%d) z=%d\n", _ep->name, _req, _req->length,
+			_req->buf, ep->is_in, _req->zero);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+	req->send_zlp = _req->zero;
+
+	/* Kickstart empty queues */
+	if (list_empty(&ep->queue)) {
+		list_add_tail(&req->queue, &ep->queue);
+
+		if (ep->hwep_num_base == 0) {
+			/* Handle expected data direction */
+			if (ep->is_in) {
+				/* IN packet to host */
+				udc->ep0state = DATA_IN;
+				status = udc_ep0_in_req(udc);
+			}
+			else {
+				/* OUT packet from host */
+				udc->ep0state = DATA_OUT;
+				status = udc_ep0_out_req(udc);
+			}
+		}
+		else if (ep->is_in) {
+			/* IN packet to host and kick off transfer */
+			if (!ep->req_pending)
+				udc_ep_in_req_dma(udc, ep);
+		}
+		else {
+			/* OUT packet from host and kick off list */
+			if (!ep->req_pending)
+				udc_ep_out_req_dma(udc, ep);
+		}
+	}
+	else {
+		list_add_tail(&req->queue, &ep->queue);
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return (status < 0) ? status : 0;
+}
+
+/* Must be called without lock */
+static int lpc32xx_ep_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct lpc32xx_ep	*ep;
+	struct lpc32xx_request	*req;
+	unsigned long flags;
+
+	ep = container_of(_ep, struct lpc32xx_ep, ep);
+	if (!_ep || ep->hwep_num_base == 0)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->udc->lock, flags);
+
+	/* make sure it's actually queued on this endpoint */
+	list_for_each_entry (req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		spin_unlock_irqrestore(&ep->udc->lock, flags);
+		return -EINVAL;
+	}
+
+	done(ep, req, -ECONNRESET);
+
+	spin_unlock_irqrestore(&ep->udc->lock, flags);
+
+	return 0;
+}
+
+/* Must be called without lock */
+static int lpc32xx_ep_set_halt(struct usb_ep *_ep, int value)
+{
+	struct lpc32xx_ep *ep = container_of(_ep, struct lpc32xx_ep, ep);
+	struct lpc32xx_udc *udc = ep->udc;
+	unsigned long flags;
+
+	if ((!ep) || (ep->desc == NULL) || (ep->hwep_num <= 1))
+		return -EINVAL;
+
+	/* Don't halt an IN EP */
+	if (ep->is_in)
+		return -EAGAIN;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	if (value == 1) {
+		/* stall */
+		udc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(ep->hwep_num),
+				DAT_WR_BYTE(EP_STAT_ST));
+	}
+	else {
+		/* End stall */
+		udc_protocol_cmd_data_w(udc, CMD_SET_EP_STAT(ep->hwep_num),
+				DAT_WR_BYTE(0));
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+static const struct usb_ep_ops lpc32xx_ep_ops = {
+	.enable		= lpc32xx_ep_enable,
+	.disable	= lpc32xx_ep_disable,
+	.alloc_request	= lpc32xx_ep_alloc_request,
+	.free_request	= lpc32xx_ep_free_request,
+	.queue		= lpc32xx_ep_queue,
+	.dequeue	= lpc32xx_ep_dequeue,
+	.set_halt	= lpc32xx_ep_set_halt,
+};
+
+/* Setup up a IN request for DMA transfer - this consists of determining the
+   list of DMA addresses for the transfer, allocating DMA Descriptors,
+   installing the DD into the UDCA, and then enabling the DMA for that EP */
+static int udc_ep_in_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)
+{
+	struct lpc32xx_request *req;
+	u32 hwep = ep->hwep_num;
+
+	ep->req_pending = 1;
+
+	/* There will always be a request waiting here */
+	req = list_entry(ep->queue.next, struct lpc32xx_request, queue);
+
+	/* Place the DD Descriptor into the UDCA */
+	udc->udca_v_base[hwep] = (u32) req->dd_desc_ptr->this_dma;
+
+	/* Enable DMA and interrupt for the HW EP */
+	udc_ep_dma_enable(udc, hwep);
+
+	/* Clear ZLP if last packet is not of MAXP size */
+	if (req->req.length % ep->ep.maxpacket)
+		req->send_zlp = 0;
+
+	return 0;
+}
+
+/* Setup up a OUT request for DMA transfer - this consists of determining the
+   list of DMA addresses for the transfer, allocating DMA Descriptors,
+   installing the DD into the UDCA, and then enabling the DMA for that EP */
+static int udc_ep_out_req_dma(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep)
+{
+	struct lpc32xx_request *req;
+	u32 hwep = ep->hwep_num;
+
+	ep->req_pending = 1;
+
+	/* There will always be a request waiting here */
+	req = list_entry(ep->queue.next, struct lpc32xx_request, queue);
+
+	/* Place the DD Descriptor into the UDCA */
+	udc->udca_v_base[hwep] = (u32) req->dd_desc_ptr->this_dma;
+
+	/* Enable DMA and interrupt for the HW EP */
+	udc_ep_dma_enable(udc, hwep);
+	return 0;
+}
+/* Send a ZLP on a non-0 IN EP */
+void udc_send_in_zlp(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep) {
+	/* Clear EP status */
+	udc_clearep_getsts(udc, ep->hwep_num);
+
+	/* Send ZLP via FIFO mechanism */
+	udc_write_hwep(udc, ep->hwep_num, NULL, 0);
+}
+
+/*
+ * Handle EP completion for ZLP
+ * This function will only be called when a delayed ZLP needs to be sent out
+ * after a DMA transfer has filled both buffers.
+ */
+void udc_handle_eps(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep) {
+	u32 epstatus;
+	struct lpc32xx_request *req;
+
+	if (ep->hwep_num <= 0)
+		return;
+
+	uda_clear_hwepint(udc,ep->hwep_num);
+
+	/* If this interrupt isn't enabled, return now */
+	if (!(udc->enabled_hwepints & (1 << ep->hwep_num)))
+		return;
+
+	/* Get endpoint status */
+	epstatus = udc_clearep_getsts(udc, ep->hwep_num);
+
+	/*
+	 * This should never happen, but protect against writing to the
+	 * buffer when full.
+	 */
+	if (epstatus & EP_SEL_F)
+		return;
+
+	if (ep->is_in) {
+		udc_send_in_zlp(udc,ep);
+		uda_disable_hwepint(udc, ep->hwep_num);
+	}
+	else
+		return;
+
+	/* If there isn't a request waiting, something went wrong */
+	req = list_entry(ep->queue.next, struct lpc32xx_request, queue);
+	if (req) {
+		done(ep, req, 0);
+
+		/* Start another request if ready */
+		if(!list_empty(&ep->queue)) {
+			if (ep->is_in)
+				udc_ep_in_req_dma(udc, ep);
+			else
+				udc_ep_out_req_dma(udc, ep);
+		}
+		else
+			ep->req_pending = 0;
+	}
+}
+
+
+/* DMA end of transfer completion */
+static void udc_handle_dma_ep(struct lpc32xx_udc *udc, struct lpc32xx_ep *ep) {
+	u32 status, epstatus;
+	struct lpc32xx_request *req;
+	struct lpc32xx_usbd_dd_gad *dd;
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+	ep->totalints++;
+#endif
+
+	req = list_entry(ep->queue.next, struct lpc32xx_request, queue);
+	if (!req) {
+		ep_err(ep, "DMA interrupt on no req!\n");
+		return;
+	}
+	dd = req->dd_desc_ptr;
+
+	/* DMA descriptor should always be retired for this call */
+	if (!(dd->dd_status & DD_STATUS_DD_RETIRED))
+		ep_warn(ep, "DMA descriptor did not retire\n");
+
+	/* Disable DMA */
+	udc_ep_dma_disable(udc, ep->hwep_num);
+	__raw_writel((1 << ep->hwep_num), USBD_EOTINTCLR(udc->udp_baseaddr));
+	__raw_writel((1 << ep->hwep_num), USBD_NDDRTINTCLR(udc->udp_baseaddr));
+
+	/* System error? */
+	if (__raw_readl(USBD_SYSERRTINTST(udc->udp_baseaddr)) & (1 << ep->hwep_num)) {
+		__raw_writel((1 << ep->hwep_num), USBD_SYSERRTINTCLR(udc->udp_baseaddr));
+		ep_err(ep, "AHB critical error!\n");
+		ep->req_pending = 0;
+
+		/* The error could of occurred on a packet of a multipacket transfer,
+		   so recovering the transfer is not possible. Close the request with
+		   an error */
+		done(ep, req, -ECONNABORTED);
+		return;
+	}
+
+	/* Handle the current DD's status */
+	status = dd->dd_status;
+	switch (status & DD_STATUS_STS_MASK) {
+		case DD_STATUS_STS_NS:
+			/* DD not serviced? This shouldn't happen! */
+			ep->req_pending = 0;
+			ep_err(ep, "DMA critical EP error: DD not serviced (0x%x)!\n", status);
+
+			done(ep, req, -ECONNABORTED);
+			return;
+
+		case DD_STATUS_STS_BS:
+			/* Interrupt only fires on EOT - This shouldn't happen! */
+			ep->req_pending = 0;
+			ep_err(ep, "DMA critical EP error: EOT prior to service completion (0x%x)!\n", status);
+			done(ep, req, -ECONNABORTED);
+			return;
+
+		case DD_STATUS_STS_NC:
+		case DD_STATUS_STS_DUR: /* Really just a short packet, not an underrun */
+			/* This is a good status and what we expect */
+			break;
+
+		default:
+			/* Data overrun, system error, or unknown */
+			ep->req_pending = 0;
+			ep_err(ep, "DMA critical EP error: System error (0x%x)!\n", status);
+			done(ep, req, -ECONNABORTED);
+			return;
+	}
+
+	/* ISO endpoints are handled differently */
+	if (ep->eptype == EP_ISO_TYPE) {
+		if (ep->is_in)
+			req->req.actual = req->req.length;
+		else
+			req->req.actual = dd->iso_status[0] & 0xFFFF;
+	} else
+		req->req.actual += DD_STATUS_CURDMACNT(status);
+
+	/* Send a ZLP if necessary. This will be done for non-int
+	   packets which have a size that is a divisor of MAXP */
+	if (req->send_zlp) {
+		/*
+		 * If at least 1 buffer is available, send the ZLP now.
+		 * Otherwise, the ZLP send needs to be deferred until a
+		 * buffer is available.
+		 */
+		if (udc_clearep_getsts(udc, ep->hwep_num) & EP_SEL_F) {
+			udc_clearep_getsts(udc, ep->hwep_num);
+			uda_enable_hwepint(udc, ep->hwep_num);
+			epstatus = udc_clearep_getsts(udc, ep->hwep_num);
+
+			/* Let the EP interrupt handle the ZLP */
+			return;
+		}
+		else
+			udc_send_in_zlp(udc, ep);
+	}
+
+	/* Transfer request is complete */
+	done(ep, req, 0);
+
+	/* Start another request if ready */
+	udc_clearep_getsts(udc, ep->hwep_num);
+	if(!list_empty((&ep->queue))) {
+		if (ep->is_in) {
+			udc_ep_in_req_dma(udc, ep);
+		}
+		else {
+			udc_ep_out_req_dma(udc, ep);
+		}
+	}
+	else
+		ep->req_pending = 0;
+
+}
+
+/*
+ *
+ * Endpoint 0 functions
+ * + *
+ * + */
+static void udc_handle_dev(struct lpc32xx_udc *udc) {
+	u32 tmp;
+
+	udc_protocol_cmd_w(udc, CMD_GET_DEV_STAT);
+	tmp = udc_protocol_cmd_r(udc, DAT_GET_DEV_STAT);
+
+	if (tmp & DEV_RST) {
+		uda_usb_reset(udc);
+	}
+	else if (tmp & DEV_CON_CH) {
+		uda_power_event(udc, (tmp & DEV_CON));
+	}
+	else if (tmp & DEV_SUS_CH) {
+		if (tmp & DEV_SUS) {
+			if (udc->vbus == 0)
+				stop_activity(udc);
+			else if ((udc->gadget.speed !=
+				USB_SPEED_UNKNOWN) && udc->driver) {
+				/* Power down transceiver */
+				udc->poweron = 0;
+				schedule_work(&udc->pullup_wq);
+				uda_resm_susp_event(udc, 1);
+			}
+		}
+		else {
+			if ((udc->gadget.speed != USB_SPEED_UNKNOWN) &&
+				udc->driver && udc->vbus) {
+				uda_resm_susp_event(udc, 0);
+				/* Power up transceiver */
+				udc->poweron = 1;
+				schedule_work(&udc->pullup_wq);
+			}
+		}
+	}
+}
+
+/* IN endpoint 0 transfer */
+static int udc_ep0_in_req(struct lpc32xx_udc *udc) {
+	struct lpc32xx_request *req;
+	struct lpc32xx_ep *ep0 = &udc->ep [0];
+	u32 tsend, ts = 0;
+
+	if (list_empty(&ep0->queue))
+	{
+		/* Nothing to send */
+		return 0;
+	}
+	else {
+		req = list_entry(ep0->queue.next,
+				struct lpc32xx_request, queue);
+	}
+
+	tsend = ts = req->req.length - req->req.actual;
+	if (ts == 0) {
+		/* Send a ZLP */
+		udc_ep0_send_zlp(udc);
+		done(ep0, req, 0);
+		return 1;
+	}
+	else if (ts > ep0->ep.maxpacket) {
+		/* Just send what we can */
+		ts = ep0->ep.maxpacket;
+	}
+
+	/* Write data to the EP0 FIFO and start transfer */
+	udc_write_hwep(udc, EP_IN, (req->req.buf + req->req.actual), ts);
+
+	/* Increment data pointer */
+	req->req.actual += ts;
+
+	if (tsend >= ep0->ep.maxpacket) {
+		/* Stay in data transfer state */
+		return 0;
+	}
+
+	/* Transfer request is complete */
+	udc->ep0state = WAIT_FOR_SETUP;
+	done(ep0, req, 0);
+	return 1;
+}
+
+/* OUT endpoint 0 transfer */
+static int udc_ep0_out_req(struct lpc32xx_udc *udc) {
+	struct lpc32xx_request *req;
+	struct lpc32xx_ep *ep0 = &udc->ep[0];
+	u32 tr, bufferspace;
+
+	if (list_empty(&ep0->queue)) {
+		return 0;
+	}
+	else {
+		req = list_entry(ep0->queue.next, struct lpc32xx_request, queue);
+	}
+
+	if (req) {
+		if (req->req.length == 0) {
+			/* Just dequeue request */
+			done(ep0, req, 0);
+			udc->ep0state = WAIT_FOR_SETUP;
+			return 1;
+		}
+
+		/* Get data from FIFO */
+		bufferspace = req->req.length - req->req.actual;
+		if (bufferspace > ep0->ep.maxpacket) {
+			bufferspace = ep0->ep.maxpacket;
+		}
+
+		/* Copy data to buffer */
+		prefetchw(req->req.buf + req->req.actual);
+		tr = udc_read_hwep(udc, EP_OUT,
+				(req->req.buf + req->req.actual), bufferspace);
+		req->req.actual += bufferspace;
+
+		if (tr < ep0->ep.maxpacket) {
+			/* This is the last packet */
+			done(ep0, req, 0);
+			udc->ep0state = WAIT_FOR_SETUP;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static int udc_get_status(struct lpc32xx_udc *udc, u16 reqtype, u16 wIndex) {
+	struct lpc32xx_ep *ep;
+	u32 ep0buff = 0, tmp;
+
+	switch (reqtype & USB_RECIP_MASK) {
+		case USB_RECIP_INTERFACE:
+			/* Not supported */
+			break;
+
+		case USB_RECIP_DEVICE:
+			ep0buff = (udc->selfpowered << USB_DEVICE_SELF_POWERED);
+			if (udc->dev_status & (1 << USB_DEVICE_REMOTE_WAKEUP)) {
+				ep0buff |= (1 << USB_DEVICE_REMOTE_WAKEUP);
+			}
+			break;
+
+		case USB_RECIP_ENDPOINT:
+			tmp = wIndex & USB_ENDPOINT_NUMBER_MASK;
+			ep = &udc->ep[tmp];
+			if ((tmp == 0) || (tmp >= NUM_ENDPOINTS) || (tmp && !ep->desc)) {
+				return -EOPNOTSUPP;
+			}
+
+			if (wIndex & USB_DIR_IN) {
+				if (!ep->is_in) {
+					/* Somethings wrong */
+					return -EOPNOTSUPP;
+				}
+			} else if (ep->is_in)
+				/* Not an IN endpoint */
+				return -EOPNOTSUPP;
+
+			/* Get status of the endpoint */
+			udc_protocol_cmd_w(udc, CMD_SEL_EP(ep->hwep_num));
+			tmp = udc_protocol_cmd_r(udc, DAT_SEL_EP(ep->hwep_num));
+
+			if (tmp & EP_SEL_ST) {
+				ep0buff = (1 << USB_ENDPOINT_HALT);
+			}
+			else {
+				ep0buff = 0;
+			}
+			break;
+
+		default:
+			break;
+	}
+
+	/* Return data */
+	udc_write_hwep(udc, EP_IN, &ep0buff, 2);
+
+	return 0;
+}
+
+static void udc_handle_ep0_setup(struct lpc32xx_udc *udc) {
+	struct lpc32xx_ep *ep, *ep0 = &udc->ep[0];
+	struct usb_ctrlrequest ctrlpkt;
+	int i, bytes;
+	u16 wIndex, wValue, wLength, reqtype, req, tmp;
+
+	/* Nuke previous transfers */
+	nuke(ep0, -EPROTO);
+
+	/* Get setup packet */
+	bytes = udc_read_hwep(udc, EP_OUT, (u32 *) &ctrlpkt, 8);
+	if (bytes != 8) {
+		ep_warn(ep0, "Incorrectly sized setup packet (s/b 8, is %d!\n", bytes);
+		return;
+	}
+
+	/* Native endianness */
+	wIndex = le16_to_cpu(ctrlpkt.wIndex);
+	wValue = le16_to_cpu(ctrlpkt.wValue);
+	wLength = le16_to_cpu(ctrlpkt.wLength);
+	reqtype = le16_to_cpu(ctrlpkt.bRequestType);
+
+	/* Set direction of EP0 */
+	if (likely(reqtype & USB_DIR_IN)) {
+		ep0->is_in = 1;
+	} else {
+		ep0->is_in = 0;
+	}
+
+	/* Handle SETUP packet */
+	req = le16_to_cpu(ctrlpkt.bRequest);
+	switch (req) {
+		case USB_REQ_CLEAR_FEATURE:
+		case USB_REQ_SET_FEATURE:
+			switch (reqtype) {
+				case (USB_TYPE_STANDARD | USB_RECIP_DEVICE):
+					if (wValue != USB_DEVICE_REMOTE_WAKEUP) {
+						/* Nothing else handled */
+						goto stall;
+					}
+
+					/* Tell board about event */
+					if (req == USB_REQ_CLEAR_FEATURE)
+						udc->dev_status &= ~(1 << USB_DEVICE_REMOTE_WAKEUP);
+					else
+						udc->dev_status |= (1 << USB_DEVICE_REMOTE_WAKEUP);
+					uda_remwkp_cgh(udc);
+					goto zlp_send;
+
+				case (USB_TYPE_STANDARD | USB_RECIP_ENDPOINT):
+					tmp = wIndex & USB_ENDPOINT_NUMBER_MASK;
+					if ((wValue != USB_ENDPOINT_HALT) || (tmp >= NUM_ENDPOINTS))
+						break;
+
+					/* Find hardware endpoint from logical endpoint */
+					ep = &udc->ep[tmp];
+					tmp = ep->hwep_num;
+					if (tmp == 0)
+						break;
+
+					if (req == USB_REQ_SET_FEATURE)
+						udc_stall_hwep(udc, tmp);
+					else
+						udc_clrstall_hwep(udc, tmp);
+
+					goto zlp_send;
+
+				default:
+					break;
+			}
+
+
+		case USB_REQ_SET_ADDRESS:
+			if (reqtype == (USB_TYPE_STANDARD | USB_RECIP_DEVICE)) {
+				udc_set_address(udc, wValue);
+				goto zlp_send;
+			}
+			break;
+
+		case USB_REQ_GET_STATUS:
+			udc_get_status(udc, reqtype, wIndex);
+			return;
+
+		default:
+			/* Let GadgetFs handle the descriptor instead */
+			break;
+	}
+
+	if (likely(udc->driver)) {
+		/* device-2-host (IN) or no data setup command, process immediately */
+		spin_unlock(&udc->lock);
+		i = udc->driver->setup(&udc->gadget, &ctrlpkt);
+
+		spin_lock(&udc->lock);
+		if (req == USB_REQ_SET_CONFIGURATION) {
+			/* Configuration is set after endpoints are realized */
+			if (wValue) {
+				/* Set configuration */
+				udc_set_device_configured(udc);
+
+				/* NAK EP interrupts do not need to be enabled for this
+				   driver, but if you really want them for statistic
+				   purposes, uncomment the following lines */
+				udc_protocol_cmd_data_w(udc, CMD_SET_MODE, DAT_WR_BYTE(AP_CLK |
+							INAK_BI | INAK_II));
+			}
+			else {
+				/* Clear configuration */
+				udc_set_device_unconfigured(udc);
+
+				/* Disable NAK interrupts */
+				udc_protocol_cmd_data_w(udc, CMD_SET_MODE, DAT_WR_BYTE(AP_CLK));
+			}
+		}
+
+		if (i < 0) {
+			/* setup processing failed, force stall */
+			dev_err(udc->dev, "req %02x.%02x protocol STALL; stat %d\n",
+					reqtype, req, i);
+			udc->ep0state = WAIT_FOR_SETUP;
+			goto stall;
+		}
+	}
+
+	if (!ep0->is_in) {
+		/* ZLP IN packet on on data phase */
+		udc_ep0_send_zlp(udc);
+	}
+
+	return;
+
+stall:
+	udc_stall_hwep(udc, EP_IN);
+	return;
+
+zlp_send:
+	udc_ep0_send_zlp(udc);
+	return;
+}
+
+/* IN endpoint 0 transfer */
+static void udc_handle_ep0_in(struct lpc32xx_udc *udc) {
+	struct lpc32xx_ep *ep0 = &udc->ep [0];
+	u32 epstatus;
+
+	/* Clear EP interrupt */
+	epstatus = udc_clearep_getsts(udc, EP_IN);
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+	ep0->totalints++;
+#endif
+
+	/* Stalled? Clear stall and reset buffers */
+	if (epstatus & EP_SEL_ST) {
+		udc_clrstall_hwep(udc, EP_IN);
+		nuke(ep0, -ECONNABORTED);
+		udc->ep0state = WAIT_FOR_SETUP;
+		return;
+	}
+
+	/* Is a buffer available? */
+	if (!(epstatus & EP_SEL_F)) {
+		/* Handle based on current state */
+		if (udc->ep0state == DATA_IN) {
+			udc_ep0_in_req(udc);
+		}
+		else {
+			/* Unknown state for EP0 oe end of DATA IN phase */
+			nuke(ep0, -ECONNABORTED);
+			udc->ep0state = WAIT_FOR_SETUP;
+		}
+	}
+}
+
+/* OUT endpoint 0 transfer */
+static void udc_handle_ep0_out(struct lpc32xx_udc *udc) {
+	struct lpc32xx_ep *ep0 = &udc->ep[0];
+	u32 epstatus;
+
+	/* Clear EP interrupt */
+	epstatus = udc_clearep_getsts(udc, EP_OUT);
+
+
+#ifdef CONFIG_USB_GADGET_DEBUG_FILES
+	ep0->totalints++;
+#endif
+
+	/* Stalled? */
+	if (epstatus & EP_SEL_ST) {
+		udc_clrstall_hwep(udc, EP_OUT);
+		nuke(ep0, -ECONNABORTED);
+		udc->ep0state = WAIT_FOR_SETUP;
+		return;
+	}
+
+	/* A NAK may occur if a packet coudn't be received yet */
+	if (epstatus & EP_SEL_EPN) {
+		return;
+	}
+	/* Setup packet incoming? */
+	if (epstatus & EP_SEL_STP) {
+		nuke(ep0, 0);
+		udc->ep0state = WAIT_FOR_SETUP;
+	}
+
+	/* Data available? */
+	if (epstatus & EP_SEL_F) {
+		/* Handle based on current state */
+		switch (udc->ep0state) {
+			case WAIT_FOR_SETUP:
+				udc_handle_ep0_setup(udc);
+				break;
+
+			case DATA_OUT:
+				udc_ep0_out_req(udc);
+				break;
+
+			default:
+				/* Unknown state for EP0 */
+				nuke(ep0, -ECONNABORTED);
+				udc->ep0state = WAIT_FOR_SETUP;
+		}
+	}
+}
+
+/* Must be called without lock */
+static int lpc32xx_get_frame(struct usb_gadget *gadget)
+{
+	int frame;
+	unsigned long flags;
+	struct lpc32xx_udc *udc = to_udc(gadget);
+
+	if (!udc->clocked)
+		return -EINVAL;
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	frame = (int) udc_get_current_frame(udc);
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return frame;
+}
+
+static int lpc32xx_wakeup(struct usb_gadget *gadget)
+{
+	return -ENOTSUPP;
+}
+
+static int lpc32xx_set_selfpowered(struct usb_gadget *gadget, int is_on)
+{
+	struct lpc32xx_udc *udc = to_udc(gadget);
+
+	/* Always self-powered */
+	udc->selfpowered = (is_on != 0);
+
+	return 0;
+	return -ENOTSUPP;
+}
+
+/*
+ * vbus is here!  turn everything on that's ready
+ * Must be called without lock
+ */
+static int lpc32xx_vbus_session(struct usb_gadget *gadget, int is_active)
+{
+	unsigned long flags;
+	struct lpc32xx_udc *udc = to_udc(gadget);
+
+	spin_lock_irqsave(&udc->lock, flags);
+
+	/* Doesn't need lock */
+	if (udc->driver) {
+		udc_clk_set(udc, 1);
+		udc_enable(udc);
+		pullup(udc, is_active);
+	}
+	else {
+		stop_activity(udc);
+		pullup(udc, 0);
+
+		spin_unlock_irqrestore(&udc->lock, flags);
+                /*
+		 *  Wait for all the endpoints to disable,
+		 *  before disabling clocks. Don't wait if
+		 *  endpoints are not enabled.
+		 */
+		if(atomic_read(&udc->enabled_ep_cnt))
+			wait_event_interruptible(udc->ep_disable_wait_queue,
+					(atomic_read(&udc->enabled_ep_cnt) == 0));
+
+		spin_lock_irqsave(&udc->lock, flags);
+
+		udc_clk_set(udc, 0);
+	}
+
+	spin_unlock_irqrestore(&udc->lock, flags);
+
+	return 0;
+}
+
+/* Can be called with or without lock */
+static int lpc32xx_pullup(struct usb_gadget *gadget, int is_on)
+{
+	struct lpc32xx_udc *udc = to_udc(gadget);
+
+	/* Doesn't need lock */
+	pullup(udc, is_on);
+
+	return 0;
+}
+
+static const struct usb_gadget_ops lpc32xx_udc_ops = {
+	.get_frame		= lpc32xx_get_frame,
+	.wakeup			= lpc32xx_wakeup,
+	.set_selfpowered	= lpc32xx_set_selfpowered,
+	.vbus_session		= lpc32xx_vbus_session,
+	.pullup			= lpc32xx_pullup,
+};
+
+static void nop_release(struct device *dev)
+{
+	/* nothing to free */
+}
+
+static struct lpc32xx_udc controller = {
+	.gadget = {
+		.ops	= &lpc32xx_udc_ops,
+		.ep0	= &controller.ep[0].ep,
+		.name	= driver_name,
+		.dev	= {
+			.init_name = "gadget",
+			.release = nop_release,
+		}
+	},
+	.ep[0] = {
+		.ep = {
+			.name	= "ep0",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 0,
+		.hwep_num	= 0, /* Can be 0 or 1, has special handling */
+		.lep		= 0,
+		.eptype		= EP_CTL_TYPE,
+	},
+	.ep[1] = {
+		.ep = {
+			.name	= "ep1-int",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 2,
+		.hwep_num	= 0, /* 2 or 3, will be set later */
+		.lep		= 1,
+		.eptype		= EP_INT_TYPE,
+	},
+	.ep[2] = {
+		.ep = {
+			.name	= "ep2-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 4,
+		.hwep_num	= 0, /* 4 or 5, will be set later */
+		.lep		= 2,
+		.eptype		= EP_BLK_TYPE,
+	},
+	.ep[3] = {
+		.ep = {
+			.name	= "ep3-iso",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 1023,
+		.hwep_num_base	= 6,
+		.hwep_num	= 0, /* 6 or 7, will be set later */
+		.lep		= 3,
+		.eptype		= EP_ISO_TYPE,
+	},
+	.ep[4] = {
+		.ep = {
+			.name	= "ep4-int",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 8,
+		.hwep_num	= 0, /* 8 or 9, will be set later */
+		.lep		= 4,
+		.eptype		= EP_INT_TYPE,
+	},
+	.ep[5] = {
+		.ep = {
+			.name	= "ep5-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 10,
+		.hwep_num	= 0, /* 10 or 11, will be set later */
+		.lep		= 5,
+		.eptype		= EP_BLK_TYPE,
+	},
+	.ep[6] = {
+		.ep = {
+			.name	= "ep6-iso",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 1023,
+		.hwep_num_base	= 12,
+		.hwep_num	= 0, /* 12 or 13, will be set later */
+		.lep		= 6,
+		.eptype		= EP_ISO_TYPE,
+	},
+	.ep[7] = {
+		.ep = {
+			.name	= "ep7-int",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 14,
+		.hwep_num	= 0,
+		.lep		= 7,
+		.eptype		= EP_INT_TYPE,
+	},
+	.ep[8] = {
+		.ep = {
+			.name	= "ep8-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 16,
+		.hwep_num	= 0,
+		.lep		= 8,
+		.eptype		= EP_BLK_TYPE,
+	},
+	.ep[9] = {
+		.ep = {
+			.name	= "ep9-iso",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 1023,
+		.hwep_num_base	= 18,
+		.hwep_num	= 0,
+		.lep		= 9,
+		.eptype		= EP_ISO_TYPE,
+	},
+	.ep[10] = {
+		.ep = {
+			.name	= "ep10-int",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 20,
+		.hwep_num	= 0,
+		.lep		= 10,
+		.eptype		= EP_INT_TYPE,
+	},
+	.ep[11] = {
+		.ep = {
+			.name	= "ep11-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 22,
+		.hwep_num	= 0,
+		.lep		= 11,
+		.eptype		= EP_BLK_TYPE,
+	},
+	.ep[12] = {
+		.ep = {
+			.name	= "ep12-iso",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 1023,
+		.hwep_num_base	= 24,
+		.hwep_num	= 0,
+		.lep		= 12,
+		.eptype		= EP_ISO_TYPE,
+	},
+	.ep[13] = {
+		.ep = {
+			.name	= "ep13-int",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 26,
+		.hwep_num	= 0,
+		.lep		= 13,
+		.eptype		= EP_INT_TYPE,
+	},
+	.ep[14] = {
+		.ep = {
+			.name	= "ep14-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 64,
+		.hwep_num_base	= 28,
+		.hwep_num	= 0,
+		.lep		= 14,
+		.eptype		= EP_BLK_TYPE,
+	},
+	.ep[15] = {
+		.ep = {
+			.name	= "ep15-bulk",
+			.ops	= &lpc32xx_ep_ops,
+		},
+		.udc		= &controller,
+		.maxpacket	= 1023,
+		.hwep_num_base	= 30,
+		.hwep_num	= 0,
+		.lep		= 15,
+		.eptype		= EP_BLK_TYPE,
+	},
+};
+
+/* ISO and status interrupts */
+static irqreturn_t lpc32xx_usb_lp_irq(int irq, void *_udc) {
+	u32 tmp, devstat;
+	struct lpc32xx_udc *udc = _udc;
+
+	spin_lock(&udc->lock);
+
+	/* Read the device status register */
+	devstat = __raw_readl(USBD_DEVINTST(udc->udp_baseaddr));
+
+	devstat &= ~USBD_EP_FAST;
+	__raw_writel(devstat, USBD_DEVINTCLR(udc->udp_baseaddr));
+	devstat = devstat & udc->enabled_devints;
+
+	/* Device specific handling needed? */
+	if (devstat & USBD_DEV_STAT) {
+		udc_handle_dev(udc);
+	}
+
+	/* Start of frame? */
+	if (devstat & FRAME_INT) {
+		/* The frame interrupt isn't really needed for ISO support,
+		   as the driver will queue the necessary packets */
+	}
+
+	/* Error? */
+	if (devstat & ERR_INT) {
+		/* All types of errors, from cable removal during transfer to
+		   misc protocol and bit errors. These are mostly for just info,
+		   as the USB hardware will work around these. If these errors
+		   happen alot, something is wrong. */
+		udc_protocol_cmd_w(udc, CMD_RD_ERR_STAT);
+		tmp = udc_protocol_cmd_r(udc, DAT_RD_ERR_STAT);
+		dev_dbg(udc->dev, "Device error (0x%x)!\n", tmp);
+	}
+
+	spin_unlock(&udc->lock);
+
+	return IRQ_HANDLED;
+}
+
+/* EP interrupts */
+static irqreturn_t lpc32xx_usb_hp_irq(int irq, void *_udc)
+{
+	u32 tmp;
+	struct lpc32xx_udc *udc = _udc;
+
+	spin_lock(&udc->lock);
+
+	/* Read the device status register */
+	__raw_writel(USBD_EP_FAST, USBD_DEVINTCLR(udc->udp_baseaddr));
+
+	/* Endpoints */
+	tmp = __raw_readl(USBD_EPINTST(udc->udp_baseaddr));
+
+	/* Special handling for EP0 */
+	if (tmp & (EP_MASK_SEL(0, EP_OUT) | EP_MASK_SEL(0, EP_IN))) {
+		/* Handle EP0 IN */
+		if (tmp & (EP_MASK_SEL(0, EP_IN)))
+			udc_handle_ep0_in(udc);
+
+		/* Handle EP0 OUT */
+		if (tmp & (EP_MASK_SEL(0, EP_OUT)))
+			udc_handle_ep0_out(udc);
+	}
+
+	/* All other EPs */
+	if (tmp & ~(EP_MASK_SEL(0, EP_OUT) | EP_MASK_SEL(0, EP_IN))) {
+		int i;
+
+		/* Handle other EP interrupts */
+		for (i = 1; i < NUM_ENDPOINTS; i++) {
+			if (tmp & (1 << udc->ep [i].hwep_num))
+				udc_handle_eps(udc, &udc->ep[i]);
+		}
+	}
+
+	spin_unlock(&udc->lock);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t lpc32xx_usb_devdma_irq(int irq, void *_udc)
+{
+	struct lpc32xx_udc *udc = _udc;
+
+	int i;
+	u32 tmp;
+
+	spin_lock(&udc->lock);
+
+	/* Handle EP DMA EOT interrupts */
+	tmp = __raw_readl(USBD_EOTINTST(udc->udp_baseaddr)) |
+		(__raw_readl(USBD_EPDMAST(udc->udp_baseaddr)) &
+		__raw_readl(USBD_NDDRTINTST(udc->udp_baseaddr))) |
+		__raw_readl(USBD_SYSERRTINTST(udc->udp_baseaddr));
+	for (i = 1; i < NUM_ENDPOINTS; i++) {
+		if (tmp & (1 << udc->ep [i].hwep_num))
+			udc_handle_dma_ep(udc, &udc->ep[i]);
+	}
+
+	spin_unlock(&udc->lock);
+
+	return IRQ_HANDLED;
+}
+
+/*
+ *
+ * VBUS detection, pullup handler, and Gadget cable state notification
+ *
+ */
+static void vbus_work(struct work_struct *work)
+{
+	u8 value;
+	struct lpc32xx_udc *udc = container_of(work, struct lpc32xx_udc, vbus_wq);
+
+	if (udc->enabled != 0) {
+		/* Discharge VBUS real quick */
+		i2c_write(OTG1_VBUS_DISCHRG, ISP1301_I2C_OTG_CONTROL_1);
+
+		/* Give VBUS some time (100mS) to discharge */
+		msleep(100);
+
+		/* Disable VBUS discharge resistor */
+		i2c_write(OTG1_VBUS_DISCHRG,
+			(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+
+		/* Clear interrupt */
+		i2c_write(~0, ISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR);
+
+		/* Get the VBUS status from the transceiver */
+		value = i2c_read(ISP1301_I2C_OTG_CONTROL_2);
+
+		/* VBUS on or off? */
+		if (value & OTG_B_SESS_VLD)
+			udc->vbus = 1;
+		else
+			udc->vbus = 0;
+
+		/* VBUS changed? */
+		if (udc->last_vbus != udc->vbus) {
+			udc->last_vbus = udc->vbus;
+			lpc32xx_vbus_session(&udc->gadget, udc->vbus);
+		}
+	}
+
+	/* Re-enable after completion */
+	enable_irq(udc->udp_irq[IRQ_USB_ATX]);
+}
+
+static irqreturn_t lpc32xx_usb_vbus_irq(int irq, void *_udc)
+{
+	struct lpc32xx_udc *udc = _udc;
+
+	/* Defer handling of VBUS IRQ to work queue */
+	disable_irq_nosync(udc->udp_irq[IRQ_USB_ATX]);
+	schedule_work(&udc->vbus_wq);
+
+	return IRQ_HANDLED;
+}
+
+int usb_gadget_probe_driver(struct usb_gadget_driver *driver,
+		int (*bind)(struct usb_gadget *))
+{
+	struct lpc32xx_udc *udc = &controller;
+	int retval, i;
+
+	if (!driver || driver->speed < USB_SPEED_FULL ||
+			!bind || !driver->setup) {
+		dev_err(udc->dev, "bad parameter.\n");
+		return -EINVAL;
+	}
+
+	if (udc->driver) {
+		dev_err(udc->dev, "UDC already has a gadget driver\n");
+		return -EBUSY;
+	}
+
+	udc->driver = driver;
+	udc->gadget.dev.driver = &driver->driver;
+	udc->enabled = 1;
+	udc->selfpowered = 1;
+	udc->vbus = 0;
+
+	retval = bind(&udc->gadget);
+	if (retval) {
+		dev_err(udc->dev, "bind() returned %d\n", retval);
+		udc->enabled = 0;
+		udc->selfpowered = 0;
+		udc->driver = NULL;
+		udc->gadget.dev.driver = NULL;
+		return retval;
+	}
+
+	dev_dbg(udc->dev, "bound to %s\n", driver->driver.name);
+
+	/* Force VBUS process once to check for cable insertion */
+	udc->last_vbus = udc->vbus = 0;
+	schedule_work(&udc->vbus_wq);
+
+	/* Do not re-enable ATX IRQ (3) */
+	for (i = IRQ_USB_LP; i < IRQ_USB_ATX; i++)
+		enable_irq(udc->udp_irq[i]);
+
+	return 0;
+}
+EXPORT_SYMBOL (usb_gadget_probe_driver);
+
+int usb_gadget_unregister_driver (struct usb_gadget_driver *driver)
+{
+	int i;
+	struct lpc32xx_udc *udc = &controller;
+
+	if (!driver || driver != udc->driver || !driver->unbind)
+		return -EINVAL;
+
+	/* Disable USB pullup */
+	isp1301_pullup_enable(udc, 0, 1);
+
+	for (i = IRQ_USB_LP; i <= IRQ_USB_ATX; i++)
+		disable_irq(udc->udp_irq[i]);
+
+	if (udc->clocked) {
+
+		spin_lock(&udc->lock);
+		stop_activity(udc);
+		spin_unlock(&udc->lock);
+
+                /*
+		 *  Wait for all the endpoints to disable,
+		 *  before disabling clocks. Don't wait if
+		 *  endpoints are not enabled.
+		 */
+		if(atomic_read(&udc->enabled_ep_cnt))
+			wait_event_interruptible(udc->ep_disable_wait_queue,
+					(atomic_read(&udc->enabled_ep_cnt) == 0));
+
+		spin_lock(&udc->lock);
+		udc_clk_set(udc, 0);
+		spin_unlock(&udc->lock);
+	}
+
+	udc->enabled = 0;
+	pullup(udc, 0);
+
+	driver->unbind(&udc->gadget);
+	udc->gadget.dev.driver = NULL;
+	udc->driver = NULL;
+
+	dev_dbg(udc->dev, "unbound from %s\n", driver->driver.name);
+	return 0;
+}
+EXPORT_SYMBOL (usb_gadget_unregister_driver);
+
+/*-------------------------------------------------------------------------*/
+
+static void lpc32xx_udc_shutdown(struct platform_device *dev)
+{
+	/* Force disconnect on reboot */
+	struct lpc32xx_udc *udc = &controller;
+
+	pullup(udc, 0);
+}
+
+static int __init lpc32xx_udc_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct lpc32xx_udc *udc = &controller;
+	int retval, i;
+	struct resource *res;
+	dma_addr_t dma_handle;
+	struct i2c_adapter *i2c_adap;
+	struct i2c_board_info i2c_info;
+
+	/* init software state */
+	udc->gadget.dev.parent = dev;
+	udc->pdev = pdev;
+	udc->dev = &pdev->dev;
+	udc->enabled = 0;
+
+	if (!dev->platform_data) {
+		dev_err(udc->dev, "missing platform_data\n");
+		return -ENODEV;
+	}
+
+	udc->board = (struct lpc32xx_usbd_cfg *) dev->platform_data;
+
+	/*
+	 * Resources are mapped as follows:
+	 *  [0] = IORESOURCE_MEM, base address and size of USB space
+	 *  [1] = IORESOURCE_IRQ, USB device low priority interrupt number
+	 *  [2] = IORESOURCE_IRQ, USB device high priority interrupt number
+	 *  [3] = IORESOURCE_IRQ, USB device interrupt number
+	 *  [4] = IORESOURCE_IRQ, USB transciever interrupt number
+	 */
+	if (pdev->num_resources != 5) {
+		dev_err(udc->dev, "invalid num_resources\n");
+		return -ENODEV;
+	}
+
+	if (pdev->resource[0].flags != IORESOURCE_MEM) {
+		dev_err(udc->dev, "invalid resource type\n");
+		return -ENODEV;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -ENXIO;
+
+	spin_lock_init(&udc->lock);
+
+	/* Get IRQs */
+	for (i = 0; i < 4; i++) {
+		if (pdev->resource[i + 1].flags != IORESOURCE_IRQ) {
+			dev_err(udc->dev, "invalid resource type\n");
+			return -ENODEV;
+		}
+		udc->udp_irq[i] = platform_get_irq(pdev, i);
+	}
+
+	udc->io_p_start = res->start;
+	udc->io_p_size = res->end - res->start + 1;
+	if (!request_mem_region(udc->io_p_start, udc->io_p_size, driver_name)) {
+		dev_err(udc->dev, "someone's using UDC memory\n");
+		return -EBUSY;
+	}
+
+	/* Enable AHB slave USB clock, needed for further USB clock control */
+	__raw_writel(USB_SLAVE_HCLK_EN | (1 << 19), USB_CTRL);
+
+	/* Get required clocks */
+	udc->usb_pll_clk = clk_get(&pdev->dev, "ck_pll5");
+	if (IS_ERR(udc->usb_pll_clk)) {
+		dev_err(udc->dev, "failed to acquire USB PLL");
+		retval = PTR_ERR(udc->usb_pll_clk);
+		goto pll_get_fail;
+	}
+	udc->usb_slv_clk = clk_get(&pdev->dev, "ck_usbd");
+	if (IS_ERR(udc->usb_slv_clk)) {
+		dev_err(udc->dev, "failed to acquire USB device clock");
+		retval = PTR_ERR(udc->usb_slv_clk);
+		goto usb_clk_get_fail;
+	}
+
+	/* Setup PLL clock to 48MHz */
+	retval = clk_enable(udc->usb_pll_clk);
+	if (retval < 0) {
+		dev_err(udc->dev, "failed to start USB PLL");
+		goto pll_enable_fail;
+	}
+
+	retval = clk_set_rate(udc->usb_pll_clk, 48000);
+	if (retval < 0) {
+		dev_err(udc->dev, "failed to set USB clock rate");
+		goto pll_set_fail;
+	}
+
+	__raw_writel(__raw_readl(USB_CTRL) | USB_DEV_NEED_CLK_EN, USB_CTRL);
+
+	/* Enable USB device clock */
+	retval = clk_enable(udc->usb_slv_clk);
+	if (retval < 0) {
+		dev_err(udc->dev, "failed to start USB device clock");
+		goto usb_clk_enable_fail;
+	}
+
+	/* Set to enable all needed USB OTG clocks */
+	__raw_writel(USB_CLOCK_MASK, USB_OTG_CLK_CTRL);
+
+	i = 1000;
+	while (((__raw_readl(USB_OTG_CLK_STAT) & USB_CLOCK_MASK) !=
+			USB_CLOCK_MASK) && (i > 0))
+		i--;
+	if (!i)
+		dev_dbg(udc->dev, "USB OTG clocks not correctly enabled\n");
+
+	/* Setup deferred workqueue data */
+	udc->poweron = udc->pullup = 0;
+	INIT_WORK(&udc->pullup_wq, pullup_work);
+	INIT_WORK(&udc->vbus_wq, vbus_work);
+#ifdef CONFIG_PM
+	INIT_WORK(&udc->power_wq, power_work);
+#endif
+
+	/* All clocks are now on */
+	udc->clocked = 1;
+
+	retval = i2c_add_driver(&isp1301_driver);
+	if (retval < 0) {
+		dev_err(udc->dev, "Failed to add ISP1301 driver \n");
+		goto i2c_add_fail;
+	}
+	i2c_adap = i2c_get_adapter(2);
+	memset(&i2c_info, 0, sizeof(struct i2c_board_info));
+	isp1301_i2c_client = i2c_new_probed_device(i2c_adap, &i2c_info,
+			normal_i2c, NULL);
+	i2c_put_adapter(i2c_adap);
+	if (!isp1301_i2c_client) {
+		dev_err(udc->dev,"failed to connect I2C to ISP1301 USB Transceiver");
+		goto i2c_probe_fail;
+	}
+
+	dev_info(udc->dev, "I2C device at address 0x%x", isp1301_i2c_client->addr);
+
+	isp1301_udc_configure(udc);
+	/* Map register space */
+	udc->udp_baseaddr = ioremap(udc->io_p_start, udc->io_p_size);
+	if (!udc->udp_baseaddr) {
+		retval = -ENOMEM;
+		dev_err(udc->dev, "IO map failure");
+		goto io_map_fail;
+	}
+
+	/* Allocate memory for the UDCA */
+	udc->udca_v_base = dma_alloc_coherent(&pdev->dev, UDCA_BUFF_SIZE,
+			&dma_handle, (GFP_KERNEL | GFP_DMA));
+	if (!udc->udca_v_base)
+	{
+		dev_err(udc->dev, "error getting UDCA region");
+		retval = -ENOMEM;
+		goto dma_alloc_fail;
+	}
+	udc->udca_p_base = (void *) dma_handle;
+	dev_dbg(udc->dev, "DMA buffer(0x%x bytes), P:0x%08x, V:0x%08x",
+			UDCA_BUFF_SIZE, (u32) udc->udca_p_base, (u32) udc->udca_v_base);
+
+	/* Setup the DD DMA memory pool */
+	udc->dd_cache = dma_pool_create ("udc_dd", udc->dev,
+			sizeof (struct lpc32xx_usbd_dd_gad), sizeof (u32), 0);
+	if (!udc->dd_cache) {
+		dev_err(udc->dev, "error getting DD DMA region");
+		retval = -ENOMEM;
+		goto dma2_alloc_fail;
+	}
+
+	/* Clear USB peripheral and initialize gadget endpoints */
+	udc_disable(udc);
+	udc_reinit(udc);
+
+	retval = device_register(&udc->gadget.dev);
+	if (retval < 0) {
+		dev_err(udc->dev, "Device registration failure");
+		goto dev_register_fail;
+	}
+
+	/* Request IRQs - low and high priority USB device IRQs are routed to the
+	   same handler, while the DMA interrupt is routed elsewhere */
+	retval = request_irq(udc->udp_irq[IRQ_USB_LP], lpc32xx_usb_lp_irq,
+			0, "udc_lp", udc);
+	if (retval < 0) {
+		dev_err(udc->dev, "LP request irq %d failed", udc->udp_irq[IRQ_USB_LP]);
+		goto irq_lp_fail;
+	}
+	retval = request_irq(udc->udp_irq[IRQ_USB_HP], lpc32xx_usb_hp_irq,
+			0, "udc_hp", udc);
+	if (retval < 0) {
+		dev_err(udc->dev, "HP request irq %d failed", udc->udp_irq[IRQ_USB_HP]);
+		goto irq_hp_fail;
+	}
+
+	retval = request_irq(udc->udp_irq[IRQ_USB_DEVDMA], lpc32xx_usb_devdma_irq,
+			0, "udc_dma", udc);
+	if (retval < 0) {
+		dev_err(udc->dev, "DEV request irq %d failed", udc->udp_irq[IRQ_USB_DEVDMA]);
+		goto irq_dev_fail;
+	}
+
+	/* The transceiver interrupt is used for VBUS detection and will
+	   kick off the VBUS handler function */
+	retval = request_irq(udc->udp_irq[IRQ_USB_ATX], lpc32xx_usb_vbus_irq,
+				 0, "udc_otg", udc);
+	if (retval < 0) {
+		dev_err(udc->dev, "VBUS request irq %d failed\n", udc->udp_irq[IRQ_USB_ATX]);
+		goto irq_xcvr_fail;
+	}
+
+        /* Initialize wait queue */
+        init_waitqueue_head(&udc->ep_disable_wait_queue);
+        atomic_set(&udc->enabled_ep_cnt,0);
+
+	/* Keep all IRQs disabled until GadgetFS starts up */
+	for (i = IRQ_USB_LP; i <= IRQ_USB_ATX; i++)
+		disable_irq(udc->udp_irq[i]);
+
+	dev_set_drvdata(dev, udc);
+	device_init_wakeup(dev, 1);
+	create_debug_file(udc);
+
+	/* Disable clocks for now */
+	udc_clk_set(udc, 0);
+
+	dev_info(udc->dev, "%s version %s\n", driver_name, DRIVER_VERSION);
+	return 0;
+
+irq_xcvr_fail:
+	free_irq(udc->udp_irq[IRQ_USB_DEVDMA], udc);
+irq_dev_fail:
+	free_irq(udc->udp_irq[IRQ_USB_HP], udc);
+irq_hp_fail:
+	free_irq(udc->udp_irq[IRQ_USB_LP], udc);
+irq_lp_fail:
+	device_unregister(&udc->gadget.dev);
+dev_register_fail:
+	dma_pool_destroy(udc->dd_cache);
+dma2_alloc_fail:
+	dma_free_coherent(&pdev->dev, UDCA_BUFF_SIZE,
+			udc->udca_v_base, (dma_addr_t) udc->udca_p_base);
+dma_alloc_fail:
+	iounmap(udc->udp_baseaddr);
+io_map_fail:
+        i2c_unregister_device(isp1301_i2c_client);
+        isp1301_i2c_client = NULL;
+i2c_probe_fail:
+	i2c_del_driver(&isp1301_driver);
+i2c_add_fail:
+	clk_disable(udc->usb_slv_clk);
+usb_clk_enable_fail:
+pll_set_fail:
+	clk_disable(udc->usb_pll_clk);
+pll_enable_fail:
+	clk_put(udc->usb_slv_clk);
+usb_clk_get_fail:
+	clk_put(udc->usb_pll_clk);
+pll_get_fail:
+	release_mem_region(udc->io_p_start, udc->io_p_size);
+	dev_err(udc->dev, "%s probe failed, %d\n", driver_name, retval);
+
+	return retval;
+}
+
+static int __exit lpc32xx_udc_remove(struct platform_device *pdev)
+{
+	struct lpc32xx_udc *udc = platform_get_drvdata(pdev);
+
+	if (udc->driver)
+		return -EBUSY;
+
+	udc_clk_set(udc, 1);
+	udc_disable(udc);
+	pullup(udc, 0);
+
+	free_irq(udc->udp_irq[IRQ_USB_ATX], udc);
+
+	device_init_wakeup(&pdev->dev, 0);
+	remove_debug_file(udc);
+
+	dma_pool_destroy(udc->dd_cache);
+	dma_free_coherent(&pdev->dev, UDCA_BUFF_SIZE,
+			udc->udca_v_base, (dma_addr_t) udc->udca_p_base);
+	free_irq(udc->udp_irq[IRQ_USB_DEVDMA], udc);
+	free_irq(udc->udp_irq[IRQ_USB_HP], udc);
+	free_irq(udc->udp_irq[IRQ_USB_LP], udc);
+
+	device_unregister(&udc->gadget.dev);
+
+	clk_disable(udc->usb_slv_clk);
+	clk_put(udc->usb_slv_clk);
+	clk_disable(udc->usb_pll_clk);
+	clk_put(udc->usb_pll_clk);
+	iounmap(udc->udp_baseaddr);
+	i2c_unregister_device(isp1301_i2c_client);
+	isp1301_i2c_client = NULL;
+	i2c_del_driver(&isp1301_driver);
+	release_mem_region(udc->io_p_start, udc->io_p_size);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lpc32xx_udc_suspend(struct platform_device *pdev, pm_message_t mesg)
+{
+	int to = 1000;
+	struct lpc32xx_udc *udc = platform_get_drvdata(pdev);
+
+	if (udc->clocked) {
+		/* Power down ISP */
+		udc->poweron = 0;
+		isp1301_set_powerstate(0);
+
+		/* Disable clocking */
+		udc_clk_set(udc, 0);
+
+		/* Keep clock flag on, so we know to re-enable clocks
+		   on resume */
+		udc->clocked = 1;
+
+		/* Kill OTG and I2C clocks */
+		__raw_writel(0, USB_OTG_CLK_CTRL);
+		while (((__raw_readl(USB_OTG_CLK_STAT) & OTGOFF_CLK_MASK) !=
+				OTGOFF_CLK_MASK) && (to > 0))
+			to--;
+		if (!to)
+			dev_dbg(udc->dev, "USB OTG clocks not correctly enabled\n");
+
+		/* Kill global USB clock */
+		clk_disable(udc->usb_slv_clk);
+	}
+
+	return 0;
+}
+
+static int lpc32xx_udc_resume(struct platform_device *pdev)
+{
+	struct lpc32xx_udc *udc = platform_get_drvdata(pdev);
+
+	if (udc->clocked) {
+		/* Enable global USB clock */
+		clk_enable(udc->usb_slv_clk);
+
+		/* Enable clocking */
+		udc_clk_set(udc, 1);
+
+		/* ISP back to normal power mode */
+		udc->poweron = 1;
+		isp1301_set_powerstate(1);
+	}
+
+	return 0;
+}
+#else
+#define	lpc32xx_udc_suspend	NULL
+#define	lpc32xx_udc_resume	NULL
+#endif
+
+static struct platform_driver lpc32xx_udc_driver = {
+	.probe          = lpc32xx_udc_probe,
+	.remove		= __exit_p(lpc32xx_udc_remove),
+	.shutdown	= lpc32xx_udc_shutdown,
+	.suspend	= lpc32xx_udc_suspend,
+	.resume		= lpc32xx_udc_resume,
+	.driver		= {
+		.name	= (char *) driver_name,
+		.owner	= THIS_MODULE,
+	},
+};
+
+static int __init udc_init_module(void)
+{
+	return platform_driver_register(&lpc32xx_udc_driver);
+}
+module_init(udc_init_module);
+
+static void __exit udc_exit_module(void)
+{
+	platform_driver_unregister(&lpc32xx_udc_driver);
+}
+module_exit(udc_exit_module);
+
+MODULE_DESCRIPTION("LPC32XX udc driver");
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:lpc32xx_udc");
+
diff --git a/drivers/usb/gadget/lpc32xx_udc.h b/drivers/usb/gadget/lpc32xx_udc.h
new file mode 100644
index 0000000..0eeb307
--- /dev/null
+++ b/drivers/usb/gadget/lpc32xx_udc.h
@@ -0,0 +1,174 @@
+/*
+ * drivers/usb/gadget/lpc32xx_udc.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2009 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef LPC32XX_UDC_H
+#define LPC32XX_UDC_H
+
+/*
+ * controller driver data structures
+ */
+
+/* 16 endpoints (not to be confused with 32 hardware endpoints) */
+#define	NUM_ENDPOINTS	16
+
+/*
+ * IRQ indices make reading the code a little easier
+ */
+#define IRQ_USB_LP	0
+#define IRQ_USB_HP	1
+#define IRQ_USB_DEVDMA	2
+#define IRQ_USB_ATX	3
+
+#define EP_OUT 0 /* RX (from host) */
+#define EP_IN 1 /* TX (to host) */
+
+/* Returns the interrupt mask for the selected hardware endpoint */
+#define EP_MASK_SEL(ep, dir) (1 << (((ep) * 2) + dir))
+
+#define EP_INT_TYPE 0
+#define EP_ISO_TYPE 1
+#define EP_BLK_TYPE 2
+#define EP_CTL_TYPE 3
+
+/* EP0 states */
+#define WAIT_FOR_SETUP 0 /* Wait for setup packet */
+#define DATA_IN        1 /* Expect dev->host transfer */
+#define DATA_OUT       2 /* Expect host->dev transfer */
+
+/* DD (DMA Descriptor) structure, requires word alignment, this is already defined
+   in the LPC32XX USB device header file, but this version si slightly modified to
+   tag some work data with each DMA descriptor. */
+struct lpc32xx_usbd_dd_gad;
+struct lpc32xx_usbd_dd_gad
+{
+	struct lpc32xx_usbd_dd_gad *dd_next_phy;
+	u32 dd_setup;
+	u32 dd_buffer_addr;
+	u32 dd_status;
+	u32 *dd_iso_ps_mem_addr;
+	dma_addr_t this_dma;
+	u32 iso_status[6]; /* 5 spare */
+	struct lpc32xx_usbd_dd_gad *dd_next_v;
+};
+
+/*
+ * Logical endpoint structure
+ */
+struct lpc32xx_ep {
+	struct usb_ep		ep;
+	struct list_head	queue;
+	struct lpc32xx_udc	*udc;
+
+	u32			hwep_num_base; /* Physical hardware EP */
+	u32			hwep_num; /* Maps to hardware endpoint */
+	u32			maxpacket;
+	u32			lep;
+
+	u32			is_in:1;
+	volatile u32		req_pending:1;
+	u32			eptype;
+
+	u32                     totalints;
+
+	const struct usb_endpoint_descriptor *desc;
+};
+
+/*
+ * Common UDC structure
+ */
+struct lpc32xx_udc {
+	struct usb_gadget	gadget;
+	struct usb_gadget_driver *driver;
+	struct platform_device	*pdev;
+	struct device		*dev;
+	struct proc_dir_entry	*pde;
+	spinlock_t		lock;
+
+	/* Board and device specific */
+	struct lpc32xx_usbd_cfg	*board;
+	u32			io_p_start;
+	u32			io_p_size;
+	void __iomem		*udp_baseaddr;
+	int			udp_irq[4];
+	struct clk		*usb_pll_clk;
+	struct clk		*usb_slv_clk;
+
+	/* DMA support */
+	u32			*udca_v_base;
+	u32			*udca_p_base;
+	struct dma_pool		*dd_cache;
+
+	/* Common EP and control data */
+	u32			enabled_devints;
+	u32			enabled_hwepints;
+	u32			dev_status;
+	u32			realized_eps;
+
+	/* VBUS detection, pullup, and power flags */
+	u8			vbus;
+	u8			last_vbus;
+	int			pullup;
+	int			poweron;
+
+	/* Work queues related to I2C support */
+	struct work_struct	pullup_wq;
+	struct work_struct	vbus_wq;
+	struct work_struct	power_wq;
+
+	/* USB device peripheral - various */
+	struct lpc32xx_ep	ep[NUM_ENDPOINTS];
+	u32			enabled:1;
+	u32			clocked:1;
+	u32			suspended:1;
+	u32			selfpowered:1;
+	int                     ep0state;
+        atomic_t                enabled_ep_cnt;
+        wait_queue_head_t       ep_disable_wait_queue;
+};
+
+/*
+ * Endpoint request
+ */
+struct lpc32xx_request {
+	struct usb_request	req;
+	struct list_head	queue;
+	struct lpc32xx_usbd_dd_gad *dd_desc_ptr;
+	u32			mapped:1;
+	u32			send_zlp:1;
+};
+
+static inline struct lpc32xx_udc *to_udc(struct usb_gadget *g)
+{
+	return container_of(g, struct lpc32xx_udc, gadget);
+}
+
+#define ep_dbg(epp, fmt, arg...) \
+	dev_dbg(epp->udc->dev, "%s:%s: " fmt, epp->ep.name, __func__, ## arg)
+#define ep_err(epp, fmt, arg...) \
+	dev_err(epp->udc->dev, "%s:%s: " fmt, epp->ep.name, __func__, ## arg)
+#define ep_info(epp, fmt, arg...) \
+	dev_info(epp->udc->dev, "%s:%s: " fmt, epp->ep.name, __func__, ## arg)
+#define ep_warn(epp, fmt, arg...) \
+	dev_warn(epp->udc->dev, "%s:%s:" fmt, epp->ep.name, __func__, ## arg)
+
+#endif
+
diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c
index 34b9edd..4285335 100644
--- a/drivers/usb/host/ohci-hcd.c
+++ b/drivers/usb/host/ohci-hcd.c
@@ -1055,6 +1055,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		usb_hcd_pnx4008_driver
 #endif
 
+#ifdef CONFIG_ARCH_LPC32XX
+#include "ohci-pnx4008.c"
+#define PLATFORM_DRIVER		usb_hcd_pnx4008_driver
+#endif
+
 #ifdef CONFIG_ARCH_DAVINCI_DA8XX
 #include "ohci-da8xx.c"
 #define PLATFORM_DRIVER		ohci_hcd_da8xx_driver
diff --git a/drivers/usb/host/ohci-pnx4008.c b/drivers/usb/host/ohci-pnx4008.c
index 0013db7..41e9545 100644
--- a/drivers/usb/host/ohci-pnx4008.c
+++ b/drivers/usb/host/ohci-pnx4008.c
@@ -28,6 +28,12 @@
 #include <mach/irqs.h>
 #include <asm/gpio.h>
 
+
+#if defined(CONFIG_ARCH_LPC32XX)
+#define PNX4008_PWRMAN_BASE LPC32XX_CLK_PM_BASE
+#define PNX4008_USB_CONFIG_BASE LPC32XX_USB_BASE
+#endif
+
 #define USB_CTRL	IO_ADDRESS(PNX4008_PWRMAN_BASE + 0x64)
 
 /* USB_CTRL bit defines */
@@ -143,8 +149,18 @@ static void i2c_write(u8 buf, u8 subaddr)
 	i2c_master_send(isp1301_i2c_client, &tmpbuf[0], 2);
 }
 
+static u16 i2c_read16(u8 subaddr)
+{
+	u16 data;
+
+	i2c_master_send(isp1301_i2c_client, &subaddr, 1);
+	i2c_master_recv(isp1301_i2c_client, (u8 *) &data, 2);
+	return data;
+}
+
 static void isp1301_configure(void)
 {
+#if !defined(CONFIG_ARCH_LPC32XX)
 	/* PNX4008 only supports DAT_SE0 USB mode */
 	/* PNX4008 R2A requires setting the MAX603 to output 3.6V */
 	/* Power up externel charge-pump */
@@ -166,6 +182,40 @@ static void isp1301_configure(void)
 		  ISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR);
 	i2c_write(0xFF,
 		  ISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR);
+#else
+	/* LPC32XX only supports DAT_SE0 USB mode */
+	/* This sequence is important */
+
+	/* Disable transparent UART mode first */
+	i2c_write(MC1_UART_EN, (ISP1301_I2C_MODE_CONTROL_1 |
+				ISP1301_I2C_REG_CLEAR_ADDR));
+
+	i2c_write(~MC1_SPEED_REG, (ISP1301_I2C_MODE_CONTROL_1 |
+				ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write(MC1_SPEED_REG, ISP1301_I2C_MODE_CONTROL_1);
+	i2c_write(~0, (ISP1301_I2C_MODE_CONTROL_2 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write((MC2_BI_DI | MC2_PSW_EN | MC2_SPD_SUSP_CTRL),
+			ISP1301_I2C_MODE_CONTROL_2);
+	i2c_write(~0, (ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write(MC1_DAT_SE0, ISP1301_I2C_MODE_CONTROL_1);
+	i2c_write((OTG1_DM_PULLDOWN | OTG1_DP_PULLDOWN),
+			ISP1301_I2C_OTG_CONTROL_1);
+	i2c_write((OTG1_DM_PULLUP | OTG1_DP_PULLUP),
+			(ISP1301_I2C_OTG_CONTROL_1 | ISP1301_I2C_REG_CLEAR_ADDR));
+	i2c_write(~0,
+			ISP1301_I2C_INTERRUPT_LATCH | ISP1301_I2C_REG_CLEAR_ADDR);
+	i2c_write(~0,
+			ISP1301_I2C_INTERRUPT_FALLING | ISP1301_I2C_REG_CLEAR_ADDR);
+	i2c_write(~0,
+			ISP1301_I2C_INTERRUPT_RISING | ISP1301_I2C_REG_CLEAR_ADDR);
+
+	/* Enable usb_need_clk clock after transceiver is initialized */
+	__raw_writel((__raw_readl(USB_CTRL) | (1 << 22)), USB_CTRL);
+
+	printk(KERN_INFO "ISP1301 Vendor ID  : 0x%04x\n", i2c_read16(0x00));
+	printk(KERN_INFO "ISP1301 Product ID : 0x%04x\n", i2c_read16(0x02));
+	printk(KERN_INFO "ISP1301 Version ID : 0x%04x\n", i2c_read16(0x14));
+#endif
 
 }
 
@@ -257,6 +307,7 @@ static const struct hc_driver ohci_pnx4008_hc_driver = {
 
 static void pnx4008_set_usb_bits(void)
 {
+#if !defined(CONFIG_ARCH_LPC32XX)
 	start_int_set_falling_edge(SE_USB_OTG_ATX_INT_N);
 	start_int_ack(SE_USB_OTG_ATX_INT_N);
 	start_int_umask(SE_USB_OTG_ATX_INT_N);
@@ -280,16 +331,19 @@ static void pnx4008_set_usb_bits(void)
 	start_int_set_rising_edge(SE_USB_AHB_NEED_CLK_INT);
 	start_int_ack(SE_USB_AHB_NEED_CLK_INT);
 	start_int_umask(SE_USB_AHB_NEED_CLK_INT);
+#endif
 }
 
 static void pnx4008_unset_usb_bits(void)
 {
+#if !defined(CONFIG_ARCH_LPC32XX)
 	start_int_mask(SE_USB_OTG_ATX_INT_N);
 	start_int_mask(SE_USB_OTG_TIMER_INT);
 	start_int_mask(SE_USB_I2C_INT);
 	start_int_mask(SE_USB_INT);
 	start_int_mask(SE_USB_NEED_CLK_INT);
 	start_int_mask(SE_USB_AHB_NEED_CLK_INT);
+#endif
 }
 
 static int __devinit usb_hcd_pnx4008_probe(struct platform_device *pdev)
@@ -320,6 +374,16 @@ static int __devinit usb_hcd_pnx4008_probe(struct platform_device *pdev)
 	/* Enable AHB slave USB clock, needed for further USB clock control */
 	__raw_writel(USB_SLAVE_HCLK_EN | (1 << 19), USB_CTRL);
 
+#if defined(CONFIG_ARCH_LPC32XX)
+	if ((__raw_readl(USB_OTG_CLK_STAT) & I2C_CLOCK_ON) != I2C_CLOCK_ON) {
+		/* Enable I2C clock in the OTG block if it isn't on */
+		__raw_writel(I2C_CLOCK_ON, USB_OTG_CLK_CTRL);
+
+		/* Ideally, a timeout based on jiffies would be nice here */
+		while (__raw_readl(USB_OTG_CLK_STAT) != I2C_CLOCK_ON);
+	}
+#endif
+
 	ret = i2c_add_driver(&isp1301_driver);
 	if (ret < 0) {
 		err("failed to add ISP1301 driver");
diff --git a/drivers/video/amba-clcd.c b/drivers/video/amba-clcd.c
index 0a2cce7..e9f4ec1 100644
--- a/drivers/video/amba-clcd.c
+++ b/drivers/video/amba-clcd.c
@@ -25,6 +25,7 @@
 #include <linux/amba/clcd.h>
 #include <linux/clk.h>
 #include <linux/hardirq.h>
+#include <linux/console.h>
 
 #include <asm/sizes.h>
 
@@ -77,6 +78,8 @@ static void clcdfb_disable(struct clcd_fb *fb)
 		writel(val, fb->regs + fb->off_cntl);
 	}
 
+	clcdfb_sleep(20);
+
 	/*
 	 * Disable CLCD clock source.
 	 */
@@ -96,6 +99,8 @@ static void clcdfb_enable(struct clcd_fb *fb, u32 cntl)
 		clk_enable(fb->clk);
 	}
 
+	clcdfb_sleep(20);
+
 	/*
 	 * Bring up by first enabling..
 	 */
@@ -575,7 +580,7 @@ static int clcdfb_probe(struct amba_device *dev, const struct amba_id *id)
 	if (ret)
 		goto free_fb;
 
-	ret = clcdfb_register(fb); 
+	ret = clcdfb_register(fb);
 	if (ret == 0) {
 		amba_set_drvdata(dev, fb);
 		goto out;
@@ -613,6 +618,34 @@ static int clcdfb_remove(struct amba_device *dev)
 	return 0;
 }
 
+#ifdef CONFIG_PM
+static int clcdfb_suspend(struct amba_device *dev, pm_message_t msg)
+{
+	struct clcd_fb *fb = amba_get_drvdata(dev);
+	console_lock();
+	fb_set_suspend(&fb->fb,1);
+	clcdfb_disable(fb);
+  console_unlock();
+
+	return 0;
+}
+
+static int clcdfb_resume(struct amba_device *dev)
+{
+	struct clcd_fb *fb = amba_get_drvdata(dev);
+
+	console_lock();
+	clcdfb_enable(fb, fb->clcd_cntl);
+	fb_set_suspend(&fb->fb,0);
+  console_unlock();
+
+	return 0;
+}
+#else
+#define clcdfb_suspend	NULL
+#define clcdfb_resume	NULL
+#endif
+
 static struct amba_id clcdfb_id_table[] = {
 	{
 		.id	= 0x00041110,
@@ -629,6 +662,8 @@ static struct amba_driver clcd_driver = {
 	},
 	.probe		= clcdfb_probe,
 	.remove		= clcdfb_remove,
+	.suspend	= clcdfb_suspend,
+	.resume		= clcdfb_resume,
 	.id_table	= clcdfb_id_table,
 };
 
diff --git a/drivers/watchdog/pnx4008_wdt.c b/drivers/watchdog/pnx4008_wdt.c
index dfae030..d7b64fa 100644
--- a/drivers/watchdog/pnx4008_wdt.c
+++ b/drivers/watchdog/pnx4008_wdt.c
@@ -228,6 +228,10 @@ static int pnx4008_wdt_release(struct inode *inode, struct file *file)
 	if (!test_bit(WDT_OK_TO_CLOSE, &wdt_status))
 		printk(KERN_WARNING "WATCHDOG: Device closed unexpectedly\n");
 
+	/* We should not disable watchdog if nowayout is set */
+	if (nowayout)
+		return 0;
+
 	wdt_disable();
 	clk_disable(wdt_clk);
 	clear_bit(WDT_IN_USE, &wdt_status);
diff --git a/include/linux/amba/clcd.h b/include/linux/amba/clcd.h
index e82e3ee..de490f8 100644
--- a/include/linux/amba/clcd.h
+++ b/include/linux/amba/clcd.h
@@ -281,17 +281,32 @@ static inline void clcdfb_decode(struct clcd_fb *fb, struct clcd_regs *regs)
 
 static inline int clcdfb_check(struct clcd_fb *fb, struct fb_var_screeninfo *var)
 {
+	u32 hbp, hfp, hsw;
+
+	/*
+	 * These clock constraints are for the pl11x DMA latency. TFT mode
+	 * is slightly faster than STN
+	 */
+	if (fb->panel->cntl & CNTL_LCDTFT) {
+		/* No TFT constraint given for min TFT HFP clocks in TRM */
+		hbp = hfp = (2 + 1);
+		hsw = (2 + 1);
+	} else {
+		hbp = hfp = (5 + 1);
+		hsw = (3 + 1);
+	}
+
 	var->xres_virtual = var->xres = (var->xres + 15) & ~15;
 	var->yres_virtual = var->yres = (var->yres + 1) & ~1;
 
 #define CHECK(e,l,h) (var->e < l || var->e > h)
-	if (CHECK(right_margin, (5+1), 256) ||	/* back porch */
-	    CHECK(left_margin, (5+1), 256) ||	/* front porch */
-	    CHECK(hsync_len, (5+1), 256) ||
-	    var->xres > 4096 ||
+	if (CHECK(right_margin, hbp, 256) ||	/* back porch */
+	    CHECK(left_margin, hfp, 256) ||	/* front porch */
+	    CHECK(hsync_len, hsw, 256) ||
+	    var->xres > 1024 ||
 	    var->lower_margin > 255 ||		/* back porch */
 	    var->upper_margin > 255 ||		/* front porch */
-	    var->vsync_len > 32 ||
+	    var->vsync_len > 64 ||
 	    var->yres > 1024)
 		return -EINVAL;
 #undef CHECK
diff --git a/include/linux/i2c-pnx.h b/include/linux/i2c-pnx.h
index a87124d..6732200 100644
--- a/include/linux/i2c-pnx.h
+++ b/include/linux/i2c-pnx.h
@@ -12,6 +12,8 @@
 #ifndef __I2C_PNX_H__
 #define __I2C_PNX_H__
 
+#include <linux/i2c.h>
+
 struct platform_device;
 struct clk;
 
@@ -24,9 +26,27 @@ struct i2c_pnx_mif {
 	int			len;		/* Length of data buffer */
 };
 
+struct i2c_pnx_smbus {
+	int ret; /* Return value from ISR */
+	int index; /* ISR use it for tx */
+	int rx_cnt; /* Number of data received */
+	u16 tx_buf[I2C_SMBUS_BLOCK_MAX+8]; /* Tx buffer */
+	u8 *rx_buf; /* Rx buffer */
+	int max_rx_len; /* Max. len. of expected Rx data */
+	struct completion complete;
+	int len; /* Length of data to be transmitted */
+#define I2C_PNX_SMBUS_NEED_RESET  1 /* Bus needs reset */
+#define I2C_PNX_SMBUS_ACTIVE      2 /* SMBus active */
+#define I2C_PNX_SMBUS_BLOCK_RX    4 /* Block transfer */
+#define I2C_PNX_SMBUS_WORD_RX     8 /* Word transfer */
+	u32 flags; /* Updated by ISR */
+	int slave_addr;
+};
+
 struct i2c_pnx_algo_data {
 	void __iomem		*ioaddr;
 	struct i2c_pnx_mif	mif;
+	struct i2c_pnx_smbus smb;
 	int			last;
 	struct clk		*clk;
 	struct i2c_pnx_data	*i2c_pnx;
diff --git a/init/main.c b/init/main.c
index 45a7bf5..1d5023d 100644
--- a/init/main.c
+++ b/init/main.c
@@ -6,7 +6,7 @@
  *  GK 2/5/95  -  Changed to support mounting root fs via NFS
  *  Added initrd & change_root: Werner Almesberger & Hans Lermen, Feb '96
  *  Moan early if gcc is old, avoiding bogus kernels - Paul Gortmaker, May '96
- *  Simplified starting of init:  Michael A. Griffith <grif@acm.org> 
+ *  Simplified starting of init:  Michael A. Griffith <grif@acm.org>
  */
 
 #include <linux/types.h>
diff --git a/sound/soc/Kconfig b/sound/soc/Kconfig
index 35e662d..613ed3f 100644
--- a/sound/soc/Kconfig
+++ b/sound/soc/Kconfig
@@ -45,6 +45,7 @@ source "sound/soc/s6000/Kconfig"
 source "sound/soc/sh/Kconfig"
 source "sound/soc/tegra/Kconfig"
 source "sound/soc/txx9/Kconfig"
+source "sound/soc/lpc3xxx/Kconfig"
 
 # Supported codecs
 source "sound/soc/codecs/Kconfig"
diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 9ea8ac8..6f27b5d 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -22,3 +22,4 @@ obj-$(CONFIG_SND_SOC)	+= s6000/
 obj-$(CONFIG_SND_SOC)	+= sh/
 obj-$(CONFIG_SND_SOC)	+= tegra/
 obj-$(CONFIG_SND_SOC)	+= txx9/
+obj-$(CONFIG_SND_SOC)	+= lpc3xxx/
diff --git a/sound/soc/codecs/uda1380.c b/sound/soc/codecs/uda1380.c
index 4f1b23d..174f61e 100644
--- a/sound/soc/codecs/uda1380.c
+++ b/sound/soc/codecs/uda1380.c
@@ -151,7 +151,11 @@ static int uda1380_reset(struct snd_soc_codec *codec)
 
 	if (gpio_is_valid(pdata->gpio_reset)) {
 		gpio_set_value(pdata->gpio_reset, 1);
+#ifdef CONFIG_MACH_PHY3250
+		udelay(5);
+#else
 		mdelay(1);
+#endif
 		gpio_set_value(pdata->gpio_reset, 0);
 	} else {
 		u8 data[3];
@@ -524,6 +528,43 @@ static int uda1380_trigger(struct snd_pcm_substream *substream, int cmd,
 	return 0;
 }
 
+static int uda1380_pcm_prepare(struct snd_pcm_substream *substream,
+                struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_codec *codec = rtd->codec;
+	int reg, reg_start, reg_end, clk;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		reg_start = UDA1380_MVOL;
+		reg_end = UDA1380_MIXER;
+	} else {
+		reg_start = UDA1380_DEC;
+		reg_end = UDA1380_AGC;
+	}
+
+	clk = uda1380_read_reg_cache(codec, UDA1380_CLK);
+	uda1380_write(codec, UDA1380_CLK, clk & ~R00_DAC_CLK);
+
+	for (reg = reg_start; reg <= reg_end; reg++) {
+		pr_debug("uda1380: flush reg %x val %x:", reg,
+				uda1380_read_reg_cache(codec, reg));
+		if(reg == UDA1380_MIXER)
+			uda1380_write(codec, reg,
+							uda1380_read_reg_cache(codec, reg) | R14_SILENCE);
+		/* Disable DAC mute */
+		else if(reg == UDA1380_PGA)
+			uda1380_write(codec, reg,
+					uda1380_read_reg_cache(codec, reg) & ~R21_MT_ADC);
+		else
+			uda1380_write(codec, reg, uda1380_read_reg_cache(codec, reg));
+	}
+
+	uda1380_write(codec, UDA1380_CLK, clk | R00_DAC_CLK);
+
+	return 0;
+}
+
 static int uda1380_pcm_hw_params(struct snd_pcm_substream *substream,
 				 struct snd_pcm_hw_params *params,
 				 struct snd_soc_dai *dai)
@@ -604,7 +645,9 @@ static int uda1380_set_bias_level(struct snd_soc_codec *codec,
 		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
 			if (gpio_is_valid(pdata->gpio_power)) {
 				gpio_set_value(pdata->gpio_power, 1);
+#ifndef CONFIG_MACH_PHY3250
 				mdelay(1);
+#endif
 				uda1380_reset(codec);
 			}
 
@@ -635,6 +678,7 @@ static int uda1380_set_bias_level(struct snd_soc_codec *codec,
 static const struct snd_soc_dai_ops uda1380_dai_ops = {
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
+	.prepare	= uda1380_pcm_prepare,
 	.trigger	= uda1380_trigger,
 	.set_fmt	= uda1380_set_dai_fmt_both,
 };
@@ -642,6 +686,7 @@ static const struct snd_soc_dai_ops uda1380_dai_ops = {
 static const struct snd_soc_dai_ops uda1380_dai_ops_playback = {
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
+	.prepare	= uda1380_pcm_prepare,
 	.trigger	= uda1380_trigger,
 	.set_fmt	= uda1380_set_dai_fmt_playback,
 };
@@ -649,6 +694,7 @@ static const struct snd_soc_dai_ops uda1380_dai_ops_playback = {
 static const struct snd_soc_dai_ops uda1380_dai_ops_capture = {
 	.hw_params	= uda1380_pcm_hw_params,
 	.shutdown	= uda1380_pcm_shutdown,
+	.prepare	= uda1380_pcm_prepare,
 	.trigger	= uda1380_trigger,
 	.set_fmt	= uda1380_set_dai_fmt_capture,
 };
@@ -702,7 +748,16 @@ static int uda1380_suspend(struct snd_soc_codec *codec)
 
 static int uda1380_resume(struct snd_soc_codec *codec)
 {
+	u16 clk = uda1380_read_reg_cache(codec, UDA1380_CLK);
+	u16 pm = uda1380_read_reg_cache(codec, UDA1380_PM);
+
 	uda1380_set_bias_level(codec, SND_SOC_BIAS_STANDBY);
+
+	/* Set WSPLL power if running from this clock */
+	if (clk & R00_DAC_CLK) {
+		uda1380_write(codec, UDA1380_PM, R02_PON_PLL | pm);
+	}
+
 	return 0;
 }
 
diff --git a/sound/soc/lpc3xxx/Kconfig b/sound/soc/lpc3xxx/Kconfig
new file mode 100644
index 0000000..194f030
--- /dev/null
+++ b/sound/soc/lpc3xxx/Kconfig
@@ -0,0 +1,55 @@
+config SND_LPC3XXX_SOC
+        tristate "SoC Audio for the NXP LPC32XX System-on-a-Chip"
+        depends on ARCH_LPC32XX && SND_SOC
+        help
+          Say Y or M if you want to add support for codecs attached to 
+          the LPC3XXX I2S interface.  You will also need to to select
+          the audio interfaces to support below.
+
+config SND_LPC3XXX_SOC_I2S_UDA1380
+        tristate "SoC Audio support for Phytec 3250 board with the UDA1380"
+        depends on SND_LPC3XXX_SOC
+        select I2C
+        select SND_SOC_UDA1380
+        select SND_LPC32XX_USEI2S1
+        select SND_LPC32XX_SLAVE_TX_CLK_TO_RX
+        help
+          Say Y or M here if you want to add support for SoC audio
+          on the Phytec 3250 board. This requires an I2C channel connected
+          to the I2C interface of the UDA1380 codec.
+
+config SND_LPC32XX_USEI2S1
+        bool "Use I2S1 channel instead of I2S0"
+        depends on SND_LPC3XXX_SOC
+        help
+	  The LPC32XX has 2 I2S channels (0 and 1). Normally, I2S0 is
+	  used for communications with an I2S codec. If I2S1 should be
+	  used instead, select this option. For LPC32XX systems that
+	  used the LCD interface, I2S1 must be used.
+
+config SND_LPC32XX_USEI2S_SLAVE_MODETX
+        bool "Use slave mode on the TX channel instead of master mode"
+        depends on SND_LPC3XXX_SOC
+	default n
+        help
+	  In this mode, the TX WS and bit clocks are driven from the audio
+	  CODEC instead of from the LPC32x0. For most CODECs, this won't
+	  be the case, but CODECs that have their own clocking may be able
+	  to provide TX clocking.
+
+config SND_LPC32XX_USEI2S_SLAVE_MODERX
+        bool "Use slave mode on the RX channel instead of master mode"
+        depends on SND_LPC3XXX_SOC
+	default n
+        help
+	  In this mode, the RX WS and bit clocks are driven from the audio
+	  CODEC instead of from the LPC32x0.
+
+config SND_LPC32XX_SLAVE_TX_CLK_TO_RX
+        bool "Enable TX WS clock during RX"
+        depends on SND_LPC3XXX_SOC
+	default n
+        help
+	  This enables the TX WS clock during RX transfers. Some CODECS use
+	  the TX clock for internal clock or for RX clocking.
+
diff --git a/sound/soc/lpc3xxx/Makefile b/sound/soc/lpc3xxx/Makefile
new file mode 100644
index 0000000..6447b89
--- /dev/null
+++ b/sound/soc/lpc3xxx/Makefile
@@ -0,0 +1,10 @@
+# LPC3XXX Platform Support
+snd-soc-lpc3xxx-objs := lpc3xxx-pcm.o
+snd-soc-lpc3xxx-i2s-objs := lpc3xxx-i2s.o
+
+obj-$(CONFIG_SND_LPC3XXX_SOC) += snd-soc-lpc3xxx.o snd-soc-lpc3xxx-i2s.o
+
+# LPC3XXX Machine Support
+snd-soc-lpc3xxx-uda1380-objs := lpc3xxx-uda1380.o
+
+obj-$(CONFIG_SND_LPC3XXX_SOC_I2S_UDA1380) += snd-soc-lpc3xxx-uda1380.o
diff --git a/sound/soc/lpc3xxx/lpc3xxx-i2s.c b/sound/soc/lpc3xxx/lpc3xxx-i2s.c
new file mode 100644
index 0000000..e4f40a5
--- /dev/null
+++ b/sound/soc/lpc3xxx/lpc3xxx-i2s.c
@@ -0,0 +1,639 @@
+/*
+ * sound/soc/lpc3xxx/lpc3xxx-i2s.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/soc.h>
+
+#include <mach/platform.h>
+#include <mach/hardware.h>
+#include "lpc3xxx-pcm.h"
+#include "lpc3xxx-i2s.h"
+
+#include <mach/clkdev.h>
+
+#define I2S_NAME "lpc3xxx-i2s"
+
+#define CLK_NAME (8)
+
+#define LPC3XXX_I2S_RATES \
+    (SNDRV_PCM_RATE_8000  | SNDRV_PCM_RATE_11025 | SNDRV_PCM_RATE_16000 | \
+     SNDRV_PCM_RATE_22050 | SNDRV_PCM_RATE_32000 | SNDRV_PCM_RATE_44100 | \
+     SNDRV_PCM_RATE_48000)
+
+#define LPC3XXX_I2S_FORMATS (SNDRV_PCM_FMTBIT_S8 | SND_SOC_DAIFMT_I2S | \
+    SNDRV_PCM_FMTBIT_S16 | SNDRV_PCM_FMTBIT_S32)
+
+#define CLKPWR_IOBASE io_p2v(CLK_PM_BASE)
+
+static struct lpc3xxx_i2s_info *i2s_info = NULL;
+
+#if 0
+static struct lpc3xxx_i2s_info i2s_info[NUM_I2S_DEVICES] = {
+	{
+	 .name = "i2s0",
+	 .lock = __SPIN_LOCK_UNLOCKED(i2s_info[0].lock),
+	 .initialized = 0,
+	 .clkname = "i2s0_ck",
+	 .baseio = LPC32XX_I2S0_BASE,
+	 },
+	{
+	 .name = "i2s1",
+	 .lock = __SPIN_LOCK_UNLOCKED(i2s_info[1].lock),
+	 .initialized = 0,
+	 .clkname = "i2s1_ck",
+	 .baseio = LPC32XX_I2S1_BASE,
+	 },
+};
+#endif
+
+static u32 absd32(u32 v1, u32 v2) {
+	if (v1 > v2) {
+		return v1 - v2;
+	}
+
+	return v2 - v1;
+}
+
+static void __lpc3xxx_find_clkdiv(u32 *clkx, u32 *clky, int freq,
+				  int xbytes, u32 clkrate) {
+	u32 i2srate;
+	u32 idxx, idyy;
+	u32 savedbitclkrate, diff, trate, baseclk;
+
+	/* Adjust rate for sample size (bits) and 2 channels and offset for
+	   divider in clock output */
+	i2srate = (freq / 100) * 2 * (8 * xbytes);
+	i2srate = i2srate << 1;
+	clkrate = clkrate / 100;
+	baseclk = clkrate;
+	*clkx = 1;
+	*clky = 1;
+
+	/* Find the best divider */
+	*clkx = *clky = 0;
+	savedbitclkrate = 0;
+	diff = ~0;
+	for (idxx = 1; idxx < 0xFF; idxx++) {
+		for (idyy = 1; idyy < 0xFF; idyy++) {
+			trate = (baseclk * idxx) / idyy;
+			if (absd32(trate, i2srate) < diff) {
+				diff = absd32(trate, i2srate);
+				savedbitclkrate = trate;
+				*clkx = idxx;
+				*clky = idyy;
+			}
+		}
+	}
+}
+
+static int lpc3xxx_i2s_startup(struct snd_pcm_substream *substream,
+			       struct snd_soc_dai *dai)
+{
+	u32 clkx, clky;
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[rtd->cpu_dai->id];
+	u32 dmamask;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dmamask = I2S_DMA_XMIT;
+	}
+	else {
+		dmamask = I2S_DMA_RECV;
+	}
+
+	if (dmamask & i2s_info_p->dma_flags) {
+		/* This channel already enabled! */
+		pr_warning("%s: I2S DMA channel is busy!\n",
+			I2S_NAME);
+		return -EBUSY;
+	}
+
+	/* Enable I2S clock */
+	clk_enable(i2s_info_p->clk);
+
+	/* I2S is setup here with a dummy configuration to allow the
+	bit clock to toggle. The CODEC attached to the I2S may not
+	work without this clock. The actual values here do not yet
+	matter and will be reconfigured when needed by the I2S hw
+	setup function. To match the default selected PLL setting,
+	this clock should be between 6.25 and 12.5KHz */
+	__raw_writel(I2S_DMA0_TX_DEPTH(4), I2S_DMA1(i2s_info_p->iomem));
+	__lpc3xxx_find_clkdiv(&clkx, &clky, 9000, 2, i2s_info_p->clkrate);
+	__raw_writel(((clkx << 8) | clky), I2S_TX_RATE(i2s_info_p->iomem));
+	__raw_writel(0x83C1, I2S_DAO(i2s_info_p->iomem));
+
+	i2s_info_p->dma_flags |= dmamask;
+
+	return 0;
+}
+
+static void lpc3xxx_i2s_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[rtd->cpu_dai->id];
+	u32 dmamask, tmp;
+
+	/* Disable I2S based on stream */
+	spin_lock_irq(&i2s_info_p->lock);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		dmamask = I2S_DMA_XMIT;
+		tmp = __raw_readl(I2S_DAO(i2s_info_p->iomem));
+		tmp |= I2S_STOP;
+		__raw_writel(tmp, I2S_DAO(i2s_info_p->iomem));
+		__raw_writel(0, I2S_TX_RATE(i2s_info_p->iomem));
+	}
+	else {
+		dmamask = I2S_DMA_RECV;
+		tmp = __raw_readl(I2S_DAI(i2s_info_p->iomem));
+		tmp |= I2S_STOP;
+		__raw_writel(tmp, I2S_DAI(i2s_info_p->iomem));
+		__raw_writel(0, I2S_RX_RATE(i2s_info_p->iomem));
+	}
+
+#if defined(CONFIG_SND_LPC32XX_SLAVE_TX_CLK_TO_RX)
+	/* Slave the RX WSI signal to the TX WSI signal */
+	tmp = __raw_readl(LPC32XX_CLKPWR_I2S_CLK_CTRL);
+	tmp &= ~(1 << 6);
+	__raw_writel(tmp, LPC32XX_CLKPWR_I2S_CLK_CTRL);
+#endif
+
+	spin_unlock_irq(&i2s_info_p->lock);
+
+	/* If both streams are shut down, then disable I2S to save power */
+	i2s_info_p->dma_flags &= ~dmamask;
+	if(i2s_info_p->dma_flags == 0) {
+		clk_disable(i2s_info_p->clk);
+	}
+}
+
+static int lpc3xxx_i2s_set_dai_sysclk(struct snd_soc_dai *cpu_dai,
+				      int clk_id, unsigned int freq, int dir)
+{
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[cpu_dai->id];
+
+	/* Will use in HW params later */
+	i2s_info_p->freq = freq;
+
+	return 0;
+}
+
+static int lpc3xxx_i2s_set_dai_fmt(struct snd_soc_dai *cpu_dai,
+				   unsigned int fmt)
+{
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[cpu_dai->id];
+
+	/* Will use in HW params later */
+	i2s_info_p->daifmt = fmt;
+
+	return 0;
+}
+
+static int lpc3xxx_i2s_set_dai_clkdiv(struct snd_soc_dai *cpu_dai,
+				      int div_id, int div)
+{
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[cpu_dai->id];
+
+	/* This function doesn't help, but save the value anyways.
+	   HW params will determine the correct clock divider based
+	   on the frequency */
+	i2s_info_p->clkdiv = div;
+
+	return 0;
+}
+
+static int lpc3xxx_i2s_hw_params(struct snd_pcm_substream *substream,
+			         struct snd_pcm_hw_params *params,
+				 struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int id = rtd->cpu_dai->id;
+	struct lpc3xxx_i2s_info *i2s_info_p;
+	int xfersize;
+	u32 tmp, tmp2, clkx, clky;
+
+	(void) tmp2;
+	i2s_info_p = &i2s_info[id];
+
+	/* Build the I2S setup word */
+	tmp = 0;
+
+	if ((i2s_info_p->daifmt & SND_SOC_DAIFMT_MASTER_MASK) ==
+		SND_SOC_DAIFMT_CBM_CFM) {
+		tmp |= I2S_WS_SEL;
+	}
+
+	switch (i2s_info_p->daifmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+		case SNDRV_PCM_FMTBIT_S8:
+			tmp |= I2S_WW8 | I2S_WS_HP(I2S_WW8_HP);
+			xfersize = 1;
+			break;
+
+		case SNDRV_PCM_FMTBIT_S16:
+		case SND_SOC_DAIFMT_I2S:
+			tmp |= I2S_WW16 | I2S_WS_HP(I2S_WW16_HP);
+			xfersize = 2;
+			break;
+
+		case SNDRV_PCM_FMTBIT_S32:
+			tmp |= I2S_WW32 | I2S_WS_HP(I2S_WW32_HP);
+			xfersize = 4;
+			break;
+
+		default:
+			pr_warning("%s: Unsupported audio data format\n",
+				I2S_NAME);
+			return -EINVAL;
+	}
+
+	/* Mono or stereo? */
+	if (params_channels(params) == 1) {
+		tmp |= I2S_MONO;
+	}
+
+	/* Find the best clock dividers to generate the requested
+	   frequency */
+	__lpc3xxx_find_clkdiv(&clkx, &clky, i2s_info_p->freq, xfersize, i2s_info_p->clkrate);
+
+	pr_debug("Desired clock rate    : %d\n", i2s_info_p->freq);
+	pr_debug("Base clock rate       : %d\n", i2s_info_p->clkrate);
+	pr_debug("Transfer size (bytes) : %d\n", xfersize);
+	pr_debug("Clock divider (x)     : %d\n", clkx);
+	pr_debug("Clock divider (y)     : %d\n", clky);
+	pr_debug("Channels              : %d\n", params_channels(params));
+	pr_debug("Data format           : %d\n", i2s_info_p->daifmt);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/* Enable DAO support, correct clock rate, and DMA */
+		__raw_writel(I2S_DMA1_TX_EN | I2S_DMA0_TX_DEPTH(4),
+			I2S_DMA1(i2s_info_p->iomem));
+		__raw_writel(((clkx << 8) | clky),
+			I2S_TX_RATE(i2s_info_p->iomem));
+		__raw_writel(tmp, I2S_DAO(i2s_info_p->iomem));
+
+		pr_debug("TX DMA1               : 0x%x\n",
+			__raw_readl(I2S_DMA1(i2s_info_p->iomem)));
+		pr_debug("TX dividers           : 0x%x\n",
+			__raw_readl(I2S_TX_RATE(i2s_info_p->iomem)));
+		pr_debug("TX DAO                : 0x%x\n",
+			__raw_readl(I2S_DAO(i2s_info_p->iomem)));
+	}
+	else {
+		/* Enable DAI support, correct clock rate, and DMA */
+		__raw_writel(I2S_DMA0_RX_EN | I2S_DMA1_RX_DEPTH(4),
+			I2S_DMA0(i2s_info_p->iomem));
+		__raw_writel(((clkx << 8) | clky), I2S_RX_RATE(i2s_info_p->iomem));
+
+#if defined(CONFIG_SND_LPC32XX_SLAVE_TX_CLK_TO_RX)
+		/* Slave the RX WS signal to the TX WS signal */
+		tmp2 = __raw_readl(LPC32XX_CLKPWR_I2S_CLK_CTRL);
+		tmp2 |= (1 << 6);
+		__raw_writel(tmp2, LPC32XX_CLKPWR_I2S_CLK_CTRL);
+
+		/* The DAO interface needs to be enabled to route the clock from
+		   RX to TX */
+		__raw_writel((tmp & ~I2S_WS_SEL), I2S_DAO(i2s_info_p->iomem));
+#endif
+
+		__raw_writel(tmp, I2S_DAI(i2s_info_p->iomem));
+
+		pr_debug("RX DMA0               : 0x%x\n",
+			__raw_readl(I2S_DMA0(i2s_info_p->iomem)));
+		pr_debug("RX dividers           : 0x%x\n",
+			__raw_readl(I2S_RX_RATE(i2s_info_p->iomem)));
+		pr_debug("RX DAI                : 0x%x\n",
+			__raw_readl(I2S_DAI(i2s_info_p->iomem)));
+	}
+
+	return 0;
+}
+
+static int lpc3xxx_i2s_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	/* Nothing to do here */
+	return 0;
+}
+
+static int lpc3xxx_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+		struct snd_soc_dai *dai)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int id = rtd->cpu_dai->id;
+	struct lpc3xxx_i2s_info *i2s_info_p;
+	u32 tmp;
+	int ret = 0;
+
+	i2s_info_p = &i2s_info[id];
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			tmp = __raw_readl(I2S_DAO(i2s_info_p->iomem));
+			tmp |= I2S_STOP;
+			__raw_writel(tmp, I2S_DAO(i2s_info_p->iomem));
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			tmp = __raw_readl(I2S_DAO(i2s_info_p->iomem));
+			tmp &= ~I2S_STOP;
+			__raw_writel(tmp, I2S_DAO(i2s_info_p->iomem));
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+#ifdef CONFIG_PM
+static int lpc3xxx_i2s_suspend(struct snd_soc_dai *cpu_dai)
+{
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[cpu_dai->id];
+
+	if (!cpu_dai->active)
+		return 0;
+
+	/* Save DA0, DAI, and IRQ register states */
+	i2s_info_p->dao_save = __raw_readl(I2S_DAO(i2s_info_p->iomem));
+	i2s_info_p->dai_save = __raw_readl(I2S_DAI(i2s_info_p->iomem));
+	i2s_info_p->irq_save = __raw_readl(I2S_IRQ(i2s_info_p->iomem));
+
+	/* Disable system clock */
+	clk_disable(i2s_info_p->clk);
+
+	return 0;
+}
+
+static int lpc3xxx_i2s_resume(struct snd_soc_dai *cpu_dai)
+{
+	struct lpc3xxx_i2s_info *i2s_info_p = &i2s_info[cpu_dai->id];
+
+	if (!cpu_dai->active)
+		return 0;
+
+	/* Restore system clock */
+	clk_enable(i2s_info_p->clk);
+
+	/* Restore saved DA0, DAI, and IRQ register states */
+	__raw_writel(i2s_info_p->dao_save, I2S_DAO(i2s_info_p->iomem));
+	__raw_writel(i2s_info_p->dai_save, I2S_DAI(i2s_info_p->iomem));
+	__raw_writel(i2s_info_p->irq_save, I2S_IRQ(i2s_info_p->iomem));
+
+	return 0;
+}
+
+#else
+#  define lpc3xxx_i2s_suspend	NULL
+#  define lpc3xxx_i2s_resume	NULL
+#endif
+
+static struct snd_soc_dai_ops lpc3xxx_i2s_dai_ops = {
+	.startup = lpc3xxx_i2s_startup,
+	.shutdown = lpc3xxx_i2s_shutdown,
+	.prepare = lpc3xxx_i2s_prepare,
+	.trigger = lpc3xxx_i2s_trigger,
+	.hw_params = lpc3xxx_i2s_hw_params,
+	.set_sysclk = lpc3xxx_i2s_set_dai_sysclk,
+	.set_fmt = lpc3xxx_i2s_set_dai_fmt,
+	.set_clkdiv = lpc3xxx_i2s_set_dai_clkdiv,
+};
+
+struct snd_soc_dai_driver lpc3xxx_i2s_dai[NUM_I2S_DEVICES] = {
+{
+	.name = "lpc3xxx-i2s0",
+	.id = 0,
+	.suspend = lpc3xxx_i2s_suspend,
+	.resume = lpc3xxx_i2s_resume,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC3XXX_I2S_RATES,
+		.formats = LPC3XXX_I2S_FORMATS,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC3XXX_I2S_RATES,
+		.formats = LPC3XXX_I2S_FORMATS,
+	},
+	.ops = &lpc3xxx_i2s_dai_ops,
+},
+{
+	.name = "lpc3xxx-i2s1",
+	.id = 1,
+	.suspend = lpc3xxx_i2s_suspend,
+	.resume = lpc3xxx_i2s_resume,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC3XXX_I2S_RATES,
+		.formats = LPC3XXX_I2S_FORMATS,
+	},
+	.capture = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = LPC3XXX_I2S_RATES,
+		.formats = LPC3XXX_I2S_FORMATS,
+	},
+	.ops = &lpc3xxx_i2s_dai_ops,
+},
+};
+
+/*
+ * Platform probe function
+ */
+static __devinit int lpc3xxx_i2s_plat_probe(struct platform_device *pdev)
+{
+	char clk_name[2 * CLK_NAME];
+	int ret, i, j;
+	struct resource *res;
+	resource_size_t size;
+	u32 clkx, clky;
+	struct lpc3xxx_i2s_info *i2s;
+
+	/* Allocate mem for i2s_info structure */
+	i2s_info = devm_kzalloc(&pdev->dev,
+			(sizeof(struct lpc3xxx_i2s_info) * pdev->num_resources), GFP_KERNEL);
+	if (unlikely(!i2s_info)) {
+		dev_err(&pdev->dev, "Can't allocate i2s_info \n");
+		return -ENOMEM;
+	}
+	dev_set_drvdata(&pdev->dev, i2s_info);
+
+	for(i = 0; i < pdev->num_resources; i++) {
+		i2s = &i2s_info[i];
+
+		/* Enable I2S clock */
+		snprintf(&clk_name[i * CLK_NAME], CLK_NAME, "i2s%d_ck", i);
+		i2s->clkname = &clk_name[i * CLK_NAME];
+		i2s->clk = clk_get(NULL, i2s->clkname);
+		if (IS_ERR(i2s->clk)) {
+			i2s->clk = NULL;
+			pr_warning("%s: Failed enabling the I2S clock: %s\n",
+				I2S_NAME, i2s->clkname);
+			return -ENODEV;
+		}
+
+		clk_enable(i2s->clk);
+		i2s->clkrate = clk_get_rate(i2s->clk);
+		if (i2s->clkrate == 0) {
+			pr_warning("%s: Invalid returned clock rate\n",
+				I2S_NAME);
+			clk_disable(i2s->clk);
+			clk_put(i2s->clk);
+			i2s->clk = NULL;
+			return -ENODEV;
+		}
+
+		/* Get Virtual CPU address for I2S */
+		res = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!res) {
+			dev_err(&pdev->dev, "No memory resource\n");
+			clk_disable(i2s->clk);
+			clk_put(i2s->clk);
+			i2s->clk = NULL;
+			ret = -ENODEV;
+			goto err_res;
+		}
+
+		size = resource_size(res);
+		if (!devm_request_mem_region(&pdev->dev, res->start, size,
+				     pdev->name)) {
+			dev_err(&pdev->dev, "I2S registers are not free\n");
+			clk_disable(i2s->clk);
+			clk_put(i2s->clk);
+			i2s->clk = NULL;
+			ret = -EBUSY;
+			goto err_res;
+		}
+		i2s->iomem = devm_ioremap(&pdev->dev, res->start, size);
+		if (!i2s->iomem) {
+			dev_err(&pdev->dev, "Can't map memory\n");
+			clk_disable(i2s->clk);
+			clk_put(i2s->clk);
+			i2s->clk = NULL;
+			ret = -ENOMEM;
+			goto err_res;
+		}
+
+		spin_lock_init(&i2s->lock);
+
+		/* I2S is setup here with a dummy configuration to allow the
+		   bit clock to toggle. The CODEC attached to the I2S may not
+		   work without this clock. The actual values here do not yet
+		   matter and will be reconfigured when needed by the I2S hw
+		   setup function. To match the default selected PLL setting,
+                   this clock should be between 6.25 and 12.5KHz */
+		__raw_writel(I2S_DMA0_TX_DEPTH(4), I2S_DMA1(i2s->iomem));
+		__lpc3xxx_find_clkdiv(&clkx, &clky, 9000, 2, i2s->clkrate);
+		__raw_writel(((clkx << 8) | clky), I2S_TX_RATE(i2s->iomem));
+		__raw_writel(0x83C1, I2S_DAO(i2s->iomem));
+
+		i2s->initialized = 1;
+	}
+
+	/* Regsiter SND SOC driver */
+	ret = snd_soc_register_dais(&pdev->dev, &lpc3xxx_i2s_dai[0], 2);
+	if (ret) {
+		dev_err(&pdev->dev, "Could not register DAI: %d\n", ret);
+		ret = -ENOMEM;
+		goto err_res;
+	}
+
+	return 0;
+
+err_res:
+	for(j =0 ; j < i; j++) {
+		clk_disable(i2s_info[j].clk);
+		clk_put(i2s_info[j].clk);
+		i2s_info[j].clk = NULL;
+	}
+
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	return ret;
+}
+
+static int __devexit lpc3xxx_i2s_plat_remove(struct platform_device *pdev)
+{
+	int j;
+	struct lpc3xxx_i2s_info *i2s = dev_get_drvdata(&pdev->dev);
+
+	snd_soc_unregister_dais(&pdev->dev, 2);
+
+	for(j =0 ; j < pdev->num_resources; j++) {
+		clk_disable(i2s[j].clk);
+		clk_put(i2s[j].clk);
+		i2s[j].clk = NULL;
+	}
+
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	return 0;
+}
+
+static struct platform_driver lpc3xxx_i2s_driver = {
+	.driver = {
+		.name = I2S_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = lpc3xxx_i2s_plat_probe,
+	.remove = __devexit_p(lpc3xxx_i2s_plat_remove),
+};
+
+static int __init lpc3xxx_i2s_dai_init(void)
+{
+	return platform_driver_register(&lpc3xxx_i2s_driver);
+}
+module_init(lpc3xxx_i2s_dai_init);
+
+static void __exit lpc3xxx_i2s_dai_exit(void)
+{
+	return platform_driver_unregister(&lpc3xxx_i2s_driver);
+}
+module_exit(lpc3xxx_i2s_dai_exit)
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("ASoC LPC3XXX I2S interface");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/lpc3xxx/lpc3xxx-i2s.h b/sound/soc/lpc3xxx/lpc3xxx-i2s.h
new file mode 100644
index 0000000..3fa03de
--- /dev/null
+++ b/sound/soc/lpc3xxx/lpc3xxx-i2s.h
@@ -0,0 +1,53 @@
+/*
+ * sound/soc/lpc3xxx/lpc3xxx-i2s.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __SOUND_SOC_LPC3XXX_I2S_H
+#define __SOUND_SOC_LPC3XXX_I2S_H
+
+#include <linux/types.h>
+#include <mach/clkdev.h>
+#include <mach/i2s.h>
+
+#define NUM_I2S_DEVICES		2
+
+#define I2S_DMA_XMIT		0x1
+#define I2S_DMA_RECV		0x2
+
+struct lpc3xxx_i2s_info {
+	char *name;
+	spinlock_t lock;
+	void *iomem;
+	unsigned short initialized;
+	u32 dma_flags;
+	char *clkname;
+	struct clk *clk;
+	u32 clkrate;
+	u32 baseio;
+	int freq;
+	unsigned short daifmt;
+	int clkdiv;
+	u32 dao_save, dai_save, irq_save;
+};
+
+//extern struct snd_soc_dai lpc3xxx_i2s_dai[];
+
+#endif
diff --git a/sound/soc/lpc3xxx/lpc3xxx-pcm.c b/sound/soc/lpc3xxx/lpc3xxx-pcm.c
new file mode 100644
index 0000000..1d60900
--- /dev/null
+++ b/sound/soc/lpc3xxx/lpc3xxx-pcm.c
@@ -0,0 +1,534 @@
+/*
+ * sound/soc/lpc3xxx/lpc3xxx-pcm.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+
+#include <mach/dma.h>
+#include <mach/dmac.h>
+#include <mach/i2s.h>
+#include "lpc3xxx-pcm.h"
+
+#define SND_NAME "lpc3xxx-audio"
+
+static u64 lpc3xxx_pcm_dmamask = 0xffffffff;
+
+#define NUMLINKS (3) /* 3 DMA buffers */
+
+static const struct snd_pcm_hardware lpc3xxx_pcm_hardware = {
+	.info = (SNDRV_PCM_INFO_MMAP |
+		 SNDRV_PCM_INFO_MMAP_VALID |
+		 SNDRV_PCM_INFO_INTERLEAVED |
+		 SNDRV_PCM_INFO_BLOCK_TRANSFER |
+		 SNDRV_PCM_INFO_PAUSE |
+		 SNDRV_PCM_INFO_RESUME),
+	.formats = (SND_SOC_DAIFMT_I2S),
+	.period_bytes_min = 128,
+	.period_bytes_max = 2048,
+	.periods_min = 2,
+	.periods_max = 1024,
+	.buffer_bytes_max = 128 * 1024
+};
+
+struct lpc3xxx_dma_data {
+	dma_addr_t dma_buffer;	/* physical address of DMA buffer */
+	dma_addr_t dma_buffer_end; /* first address beyond DMA buffer */
+	size_t period_size;
+
+	/* DMA configuration and support */
+	int dmach;
+	struct dma_config dmacfg;
+	volatile dma_addr_t period_ptr;	/* physical address of next period */
+	volatile dma_addr_t dma_cur;
+	u32 llptr;		/* Saved for debug only, not used */
+};
+
+static int lpc3xxx_pcm_allocate_dma_buffer(struct snd_pcm *pcm, int stream)
+{
+	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
+	struct snd_dma_buffer *dmabuf = &substream->dma_buffer;
+	size_t size = lpc3xxx_pcm_hardware.buffer_bytes_max;
+
+	dmabuf->dev.type = SNDRV_DMA_TYPE_DEV;
+	dmabuf->dev.dev = pcm->card->dev;
+	dmabuf->private_data = NULL;
+	dmabuf->area = dma_alloc_writecombine(pcm->card->dev, size,
+					   &dmabuf->addr, GFP_KERNEL);
+
+	if (!dmabuf->area)
+		return -ENOMEM;
+
+	dmabuf->bytes = size;
+	return 0;
+}
+
+/*
+ * DMA ISR - occurs when a new DMA buffer is needed
+ */
+static void lpc3xxx_pcm_dma_irq(int channel, int cause,
+				struct snd_pcm_substream *substream) {
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct lpc3xxx_dma_data *prtd = rtd->private_data;
+	static int count = 0;
+
+	count++;
+
+	/* A DMA interrupt occurred - for most cases, this will be the end
+	   of a transmitted buffer in the DMA link list, but errors are also
+	   handled. */
+	if (cause & DMA_ERR_INT) {
+		/* DMA error - this should never happen, but you just never
+		   know. If it does happen, the driver will continue without
+		   any problems except for maybe an audio glitch or pop. */
+		pr_debug("%s: DMA error %s (count=%d)\n", SND_NAME,
+			   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+			   "underrun" : "overrun", count);
+	}
+	/* Dequeue buffer from linked list */
+	lpc32xx_get_free_llist_entry(channel);
+	prtd->dma_cur += prtd->period_size;
+	if (prtd->dma_cur >= prtd->dma_buffer_end) {
+		prtd->dma_cur = prtd->dma_buffer;
+	}
+
+	/* Re-queue buffer another buffer */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		lpc32xx_dma_queue_llist_entry(prtd->dmach, (void *) prtd->period_ptr,
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+			(void *) I2S_TX_FIFO(LPC32XX_I2S1_BASE),
+#else
+			(void *) I2S_TX_FIFO(LPC32XX_I2S0_BASE),
+#endif
+			prtd->period_size);
+	}
+	else {
+		lpc32xx_dma_queue_llist_entry(prtd->dmach,
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+			(void *) I2S_RX_FIFO(LPC32XX_I2S1_BASE),
+#else
+			(void *) I2S_RX_FIFO(LPC32XX_I2S0_BASE),
+#endif
+			(void *) prtd->period_ptr, prtd->period_size);
+	}
+	prtd->period_ptr += prtd->period_size;
+	if (prtd->period_ptr >= prtd->dma_buffer_end)
+		prtd->period_ptr = prtd->dma_buffer;
+
+	/* This only needs to be called once, even if more than 1 period has passed */
+	snd_pcm_period_elapsed(substream);
+}
+
+/*
+ * PCM operations
+ */
+static int lpc3xxx_pcm_hw_params(struct snd_pcm_substream *substream,
+			         struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc3xxx_dma_data *prtd = runtime->private_data;
+
+	/* this may get called several times by oss emulation
+	 * with different params
+	 */
+	snd_pcm_set_runtime_buffer(substream, &substream->dma_buffer);
+	runtime->dma_bytes = params_buffer_bytes(params);
+
+	prtd->dma_buffer = runtime->dma_addr;
+	prtd->dma_buffer_end = runtime->dma_addr + runtime->dma_bytes;
+	prtd->period_size = params_period_bytes(params);
+
+	return 0;
+}
+
+static int lpc3xxx_pcm_hw_free(struct snd_pcm_substream *substream)
+{
+	struct lpc3xxx_dma_data *prtd = substream->runtime->private_data;
+
+	/* Return the DMA channel */
+	if (prtd->dmach != -1) {
+		lpc32xx_dma_ch_disable(prtd->dmach);
+		lpc32xx_dma_dealloc_llist(prtd->dmach);
+		lpc32xx_dma_ch_put(prtd->dmach);
+		prtd->dmach = -1;
+	}
+
+	return 0;
+}
+
+static int lpc3xxx_pcm_prepare(struct snd_pcm_substream *substream)
+{
+	struct lpc3xxx_dma_data *prtd = substream->runtime->private_data;
+
+	/* Setup DMA channel */
+	if (prtd->dmach == -1) {
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			prtd->dmach = DMA_CH_I2S_TX;
+			prtd->dmacfg.ch = DMA_CH_I2S_TX;
+			prtd->dmacfg.tc_inten = 1;
+			prtd->dmacfg.err_inten = 1;
+			prtd->dmacfg.src_size = 4;
+			prtd->dmacfg.src_inc = 1;
+			prtd->dmacfg.src_ahb1 = 1;
+			prtd->dmacfg.src_bsize = DMAC_CHAN_SRC_BURST_4;
+			prtd->dmacfg.src_prph = 0;
+			prtd->dmacfg.dst_size = 4;
+			prtd->dmacfg.dst_inc = 0;
+			prtd->dmacfg.dst_bsize = DMAC_CHAN_DEST_BURST_4;
+			prtd->dmacfg.dst_ahb1 = 0;
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+			prtd->dmacfg.dst_prph = DMAC_DEST_PERIP(DMA_PERID_I2S1_DMA1);
+#else
+			prtd->dmacfg.dst_prph = DMAC_DEST_PERIP(DMA_PERID_I2S0_DMA1);
+#endif
+			prtd->dmacfg.flowctrl = DMAC_CHAN_FLOW_D_M2P;
+			if (lpc32xx_dma_ch_get(&prtd->dmacfg, "dma_i2s_tx",
+				&lpc3xxx_pcm_dma_irq, substream) < 0) {
+				pr_debug(KERN_ERR "Error setting up I2S TX DMA channel\n");
+				return -ENODEV;
+			}
+
+			/* Allocate a linked list for audio buffers */
+			prtd->llptr = lpc32xx_dma_alloc_llist(prtd->dmach, NUMLINKS);
+			if (prtd->llptr == 0) {
+				lpc32xx_dma_ch_put(prtd->dmach);
+				prtd->dmach = -1;
+				pr_debug(KERN_ERR "Error allocating list buffer (I2S TX)\n");
+				return -ENOMEM;
+			}
+		}
+		else {
+			prtd->dmach = DMA_CH_I2S_RX;
+			prtd->dmacfg.ch = DMA_CH_I2S_RX;
+			prtd->dmacfg.tc_inten = 1;
+			prtd->dmacfg.err_inten = 1;
+			prtd->dmacfg.src_size = 4;
+			prtd->dmacfg.src_inc = 0;
+			prtd->dmacfg.src_ahb1 = 1;
+			prtd->dmacfg.src_bsize = DMAC_CHAN_SRC_BURST_4;
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+			prtd->dmacfg.src_prph = DMAC_SRC_PERIP(DMA_PERID_I2S1_DMA0);
+#else
+			prtd->dmacfg.src_prph = DMAC_SRC_PERIP(DMA_PERID_I2S0_DMA0);
+#endif
+			prtd->dmacfg.dst_size = 4;
+			prtd->dmacfg.dst_inc = 1;
+			prtd->dmacfg.dst_ahb1 = 0;
+			prtd->dmacfg.dst_bsize = DMAC_CHAN_DEST_BURST_4;
+			prtd->dmacfg.dst_prph = 0;
+			prtd->dmacfg.flowctrl = DMAC_CHAN_FLOW_D_P2M;
+			if (lpc32xx_dma_ch_get(&prtd->dmacfg, "dma_i2s_rx",
+				&lpc3xxx_pcm_dma_irq, substream) < 0) {
+				pr_debug(KERN_ERR "Error setting up I2S RX DMA channel\n");
+				return -ENODEV;
+			}
+
+			/* Allocate a linked list for audio buffers */
+			prtd->llptr = lpc32xx_dma_alloc_llist(prtd->dmach, NUMLINKS);
+			if (prtd->llptr == 0) {
+				lpc32xx_dma_ch_put(prtd->dmach);
+				prtd->dmach = -1;
+				pr_debug(KERN_ERR "Error allocating list buffer (I2S RX)\n");
+				return -ENOMEM;
+			}
+		}
+	}
+
+	return 0;
+}
+
+static int lpc3xxx_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct lpc3xxx_dma_data *prtd = rtd->private_data;
+	int i, ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		prtd->period_ptr = prtd->dma_cur = prtd->dma_buffer;
+		lpc32xx_dma_flush_llist(prtd->dmach);
+
+		/* Queue a few buffers to start DMA */
+		for (i = 0; i < NUMLINKS; i++) {
+			if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+				lpc32xx_dma_queue_llist_entry(prtd->dmach, (void *) prtd->period_ptr,
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+					(void *) I2S_TX_FIFO(LPC32XX_I2S1_BASE),
+#else
+					(void *) I2S_TX_FIFO(LPC32XX_I2S0_BASE),
+#endif
+					prtd->period_size);
+			}
+			else {
+				lpc32xx_dma_queue_llist_entry(prtd->dmach,
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+				(void *) I2S_RX_FIFO(LPC32XX_I2S1_BASE),
+#else
+				(void *) I2S_RX_FIFO(LPC32XX_I2S0_BASE),
+#endif
+				(void *) prtd->period_ptr, prtd->period_size);
+
+			}
+
+			prtd->period_ptr += prtd->period_size;
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+		lpc32xx_dma_flush_llist(prtd->dmach);
+		lpc32xx_dma_ch_disable(prtd->dmach);
+		break;
+
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		break;
+
+	case SNDRV_PCM_TRIGGER_RESUME:
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		lpc32xx_dma_ch_pause_unpause(prtd->dmach, 1);
+		break;
+
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		lpc32xx_dma_ch_pause_unpause(prtd->dmach, 0);
+		break;
+
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t lpc3xxx_pcm_pointer(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc3xxx_dma_data *prtd = runtime->private_data;
+	snd_pcm_uframes_t x;
+
+	/* Return an offset into the DMA buffer for the next data */
+	x = bytes_to_frames(runtime, (prtd->dma_cur - runtime->dma_addr));
+	if (x >= runtime->buffer_size)
+		x = 0;
+
+	return x;
+}
+
+static int lpc3xxx_pcm_open(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct lpc3xxx_dma_data *prtd;
+	int ret = 0;
+
+	snd_soc_set_runtime_hwparams(substream, &lpc3xxx_pcm_hardware);
+
+	/* ensure that buffer size is a multiple of period size */
+	ret = snd_pcm_hw_constraint_integer(runtime,
+					    SNDRV_PCM_HW_PARAM_PERIODS);
+	if (ret < 0)
+		goto out;
+
+	prtd = kzalloc(sizeof(*prtd), GFP_KERNEL);
+	if (prtd == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	runtime->private_data = prtd;
+	prtd->dmach = -1;
+
+out:
+	return ret;
+}
+
+static int lpc3xxx_pcm_close(struct snd_pcm_substream *substream)
+{
+	struct lpc3xxx_dma_data *prtd = substream->runtime->private_data;
+
+	kfree(prtd);
+	return 0;
+}
+
+static int lpc3xxx_pcm_mmap(struct snd_pcm_substream *substream,
+			    struct vm_area_struct *vma)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+
+	return dma_mmap_writecombine(substream->pcm->card->dev, vma,
+				     runtime->dma_area,
+				     runtime->dma_addr,
+				     runtime->dma_bytes);
+}
+
+static struct snd_pcm_ops lpc3xxx_pcm_ops = {
+	.open = lpc3xxx_pcm_open,
+	.close = lpc3xxx_pcm_close,
+	.ioctl = snd_pcm_lib_ioctl,
+	.hw_params = lpc3xxx_pcm_hw_params,
+	.hw_free = lpc3xxx_pcm_hw_free,
+	.prepare = lpc3xxx_pcm_prepare,
+	.trigger = lpc3xxx_pcm_trigger,
+	.pointer = lpc3xxx_pcm_pointer,
+	.mmap = lpc3xxx_pcm_mmap,
+};
+
+/*
+ * ASoC platform driver
+ */
+static int lpc3xxx_pcm_new(struct snd_card *card,
+			   struct snd_soc_dai *dai,
+			   struct snd_pcm *pcm)
+{
+	int ret = 0;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &lpc3xxx_pcm_dmamask;
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = 0xffffffff;
+
+	if (dai->driver->playback.channels_min) {
+		ret = lpc3xxx_pcm_allocate_dma_buffer(
+			  pcm, SNDRV_PCM_STREAM_PLAYBACK);
+		if (ret)
+			goto out;
+	}
+
+	if (dai->driver->capture.channels_min) {
+		pr_debug("%s: Allocating PCM capture DMA buffer\n", SND_NAME);
+		ret = lpc3xxx_pcm_allocate_dma_buffer(
+			  pcm, SNDRV_PCM_STREAM_CAPTURE);
+		if (ret)
+			goto out;
+	}
+
+out:
+	return ret;
+}
+
+static void lpc3xxx_pcm_free_dma_buffers(struct snd_pcm *pcm)
+{
+	struct snd_pcm_substream *substream;
+	struct snd_dma_buffer *buf;
+	int stream;
+
+	for (stream = 0; stream < 2; stream++) {
+		substream = pcm->streams[stream].substream;
+		if (substream == NULL)
+			continue;
+
+		buf = &substream->dma_buffer;
+		if (!buf->area)
+			continue;
+		dma_free_writecombine(pcm->card->dev, buf->bytes,
+				      buf->area, buf->addr);
+
+		buf->area = NULL;
+	}
+}
+
+#if defined(CONFIG_PM)
+static int lpc3xxx_pcm_suspend(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct lpc3xxx_dma_data *prtd;
+
+	if (runtime == NULL)
+		return 0;
+
+	prtd = runtime->private_data;
+
+	/* Disable the DMA channel */
+	lpc32xx_dma_ch_disable(prtd->dmach);
+
+	return 0;
+}
+
+static int lpc3xxx_pcm_resume(struct snd_soc_dai *dai)
+{
+	struct snd_pcm_runtime *runtime = dai->runtime;
+	struct lpc3xxx_dma_data *prtd;
+
+	if (runtime == NULL)
+		return 0;
+
+	prtd = runtime->private_data;
+
+	/* Enable the DMA channel */
+	lpc32xx_dma_ch_enable(prtd->dmach);
+
+	return 0;
+}
+
+#else
+#define lpc3xxx_pcm_suspend	NULL
+#define lpc3xxx_pcm_resume	NULL
+#endif
+
+static struct snd_soc_platform_driver lpc3xxx_soc_platform = {
+	.ops = &lpc3xxx_pcm_ops,
+	.pcm_new = lpc3xxx_pcm_new,
+	.pcm_free = lpc3xxx_pcm_free_dma_buffers,
+	.suspend = lpc3xxx_pcm_suspend,
+	.resume = lpc3xxx_pcm_resume,
+};
+
+static int __devinit lpc3xxx_pcm_plat_probe(struct platform_device *pdev)
+{
+	return snd_soc_register_platform(&pdev->dev, &lpc3xxx_soc_platform);
+}
+
+static int __devexit lpc3xxx_pcm_plat_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_platform(&pdev->dev);
+	return 0;
+}
+
+static struct platform_driver lpc3xxx_pcm_driver = {
+	.driver = {
+		.name = SND_NAME,
+		.owner = THIS_MODULE,
+	},
+	.probe = lpc3xxx_pcm_plat_probe,
+	.remove = __devexit_p(lpc3xxx_pcm_plat_remove),
+};
+
+static int __init lpc3xxx_soc_platform_init(void)
+{
+	return platform_driver_register(&lpc3xxx_pcm_driver);
+}
+module_init(lpc3xxx_soc_platform_init);
+
+static void __exit lpc3xxx_soc_platform_exit(void)
+{
+	return platform_driver_unregister(&lpc3xxx_pcm_driver);
+}
+module_exit(lpc3xxx_soc_platform_exit)
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("NXP LPC3XXX PCM module");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/lpc3xxx/lpc3xxx-pcm.h b/sound/soc/lpc3xxx/lpc3xxx-pcm.h
new file mode 100644
index 0000000..66f8eab
--- /dev/null
+++ b/sound/soc/lpc3xxx/lpc3xxx-pcm.h
@@ -0,0 +1,29 @@
+/*
+ * sound/soc/lpc3xxx/lpc3xxx-pcm.h
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __SOUND_SOC_LPC3XXX_PCM_H
+#define __SOUND_SOC_LPC3XXX_PCM_H
+
+//extern struct snd_soc_platform lpc3xxx_soc_platform;
+
+#endif
+
diff --git a/sound/soc/lpc3xxx/lpc3xxx-uda1380.c b/sound/soc/lpc3xxx/lpc3xxx-uda1380.c
new file mode 100644
index 0000000..760503e
--- /dev/null
+++ b/sound/soc/lpc3xxx/lpc3xxx-uda1380.c
@@ -0,0 +1,227 @@
+/*
+ * sound/soc/lpc3xxx/lpc3xxx-uda1380.c
+ *
+ * Author: Kevin Wells <kevin.wells@nxp.com>
+ *
+ * Copyright (C) 2008 NXP Semiconductors
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+#include <sound/uda1380.h>
+
+#include <mach/gpio.h>
+
+#include "../codecs/uda1380.h"
+#include "lpc3xxx-pcm.h"
+#include "lpc3xxx-i2s.h"
+
+#define SND_MODNAME "lpc3xxx_uda1380"
+
+static int phy3250_uda1380_hw_params(struct snd_pcm_substream *substream,
+				    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
+	unsigned int fmt = SND_SOC_DAIFMT_I2S;
+	int ret;
+
+	/* The perspective is from the CODEC side, so slave mode means that
+	    the i2s interface is the master. For the UDA1380 and playback,
+	    the CODEC is always a slave and i2s is always a master. */
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		fmt |= SND_SOC_DAIFMT_CBS_CFS;
+	}
+	else {
+
+#if defined(CONFIG_SND_LPC32XX_USEI2S_SLAVE_MODERX)
+		fmt |= SND_SOC_DAIFMT_CBM_CFM;
+#else
+		fmt |= SND_SOC_DAIFMT_CBS_CFS;
+#endif
+	}
+
+	/* Set the CPU I2S rate clock (first) */
+	ret = snd_soc_dai_set_sysclk(cpu_dai, 0, params_rate(params),
+					    SND_SOC_CLOCK_OUT);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set I2S clock (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	/* Set CPU and CODEC DAI format */
+	ret = snd_soc_dai_set_fmt(cpu_dai, fmt);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set CPU DAI format (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+	ret = snd_soc_dai_set_fmt(codec_dai, fmt);
+	if (ret < 0) {
+		pr_warning("%s: "
+			   "Failed to set CODEC DAI format (%d)\n",
+			   SND_MODNAME, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops phy3250_uda1380_ops = {
+	.hw_params = phy3250_uda1380_hw_params,
+};
+
+static const struct snd_soc_dapm_widget phy3250_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_LINE("Line Out", NULL),
+	SND_SOC_DAPM_MIC("Mic Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	/* Headphone connected to VOUTRHP, VOUTLHP */
+	{"Headphone Jack", NULL, "VOUTRHP"},
+	{"Headphone Jack", NULL, "VOUTLHP"},
+
+	/* Line Out connected to VOUTR, VOUTL */
+	{"Line Out", NULL, "VOUTR"},
+	{"Line Out", NULL, "VOUTL"},
+
+	/* Mic connected to VINM */
+	{"VINM", NULL, "Mic Jack"},
+
+	/* Line In connected to VINR, VINL */
+	{"VINL", NULL, "Line In"},
+	{"VINR", NULL, "Line In"},
+};
+
+static int phy3250_uda1380_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int err;
+	struct snd_soc_codec *codec = rtd->codec;
+	struct snd_soc_dapm_context *dapm = &codec->dapm;
+
+	/* Add widgets */
+	err = snd_soc_dapm_new_controls(dapm, phy3250_dapm_widgets,
+				  ARRAY_SIZE(phy3250_dapm_widgets));
+	if (err)
+		return err;
+
+	/* Set up audio_map */
+	err = snd_soc_dapm_add_routes(dapm, intercon, ARRAY_SIZE(intercon));
+	if (err)
+		return err;
+
+	/* Always connected pins */
+	snd_soc_dapm_enable_pin(dapm, "Headphone Jack");
+	snd_soc_dapm_enable_pin(dapm, "Line Out");
+	snd_soc_dapm_enable_pin(dapm, "Mic Jack");
+	snd_soc_dapm_enable_pin(dapm, "Line In");
+
+	snd_soc_dapm_sync(dapm);
+
+	return 0;
+}
+
+/* s3c24xx digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link phy3250_uda1380_dai[] = {
+	{
+		.name		= "uda1380",
+		.stream_name	= "UDA1380 Duplex",
+#if defined(CONFIG_SND_LPC32XX_USEI2S1)
+		.cpu_dai_name	= "lpc3xxx-i2s1",
+#else
+		.cpu_dai_name	= "lpc3xxx-i2s0",
+#endif
+		.codec_dai_name	= "uda1380-hifi",
+		.init		= phy3250_uda1380_init,
+		.platform_name	= "lpc3xxx-audio.0",
+		.codec_name	= "uda1380-codec.0-0018",
+		.ops		= &phy3250_uda1380_ops,
+	},
+};
+
+static struct snd_soc_card phy3250_snd_asoc = {
+	.name = "LPC32XX",
+	.dai_link = &phy3250_uda1380_dai[0],
+	.num_links = ARRAY_SIZE(phy3250_uda1380_dai),
+};
+
+static struct platform_device *phy3250_snd_device;
+
+static int __init phy3250_asoc_init(void)
+{
+	int ret = 0;
+
+	/*
+	 * Create and register platform device
+	 */
+	phy3250_snd_device = platform_device_alloc("soc-audio", 0);
+	if (phy3250_snd_device == NULL) {
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(phy3250_snd_device, &phy3250_snd_asoc);
+
+	ret = platform_device_add(phy3250_snd_device);
+	if (ret) {
+		pr_warning("%s: platform_device_add failed (%d)\n",
+			   SND_MODNAME, ret);
+		goto err_device_add;
+	}
+
+	return 0;
+
+err_device_add:
+	if (phy3250_snd_device != NULL) {
+		platform_device_put(phy3250_snd_device);
+		phy3250_snd_device = NULL;
+	}
+
+	return ret;
+}
+
+static void __exit phy3250_asoc_exit(void)
+{
+	platform_device_unregister(phy3250_snd_device);
+	phy3250_snd_device = NULL;
+}
+
+module_init(phy3250_asoc_init);
+module_exit(phy3250_asoc_exit);
+
+MODULE_AUTHOR("Kevin Wells <kevin.wells@nxp.com>");
+MODULE_DESCRIPTION("ASoC machine driver for LPC3XXX/UDA1380");
+MODULE_LICENSE("GPL");
